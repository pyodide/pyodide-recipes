From e26e64d1910d725089bddd9f7e4fbbc7e616ed02 Mon Sep 17 00:00:00 2001
From: Ilhan Polat <ilhanpolat@gmail.com>
Date: Wed, 25 Jun 2025 22:50:58 +0200
Subject: [PATCH 13/14] ENH:MAINT: sparse.linalg: rewrite ARPACK in C (#22748)

This patch is from the recently merged PR https://github.com/scipy/scipy/pull/22748.
We backport it into the 1.16.x branch as the PR was not too far ahead of the branch.

* MAINT:sparse.linalg: Remove ARPACK F77 code

* ENH:sparse:linalg: Add ARPACK header file

* ENH:sparse.linalg: Add ARPACK C code for nonsym complex

* MAINT:sparse.linalg: Add MSVC guards for complex definitions

SQ: remove complexdefs.h

* ENH:sparse.linalg: Add ARPACK C code for nonsym real

* MAINT:sparse.linalg: Adjust meson file for ARPACK C rewrite

* ENH:sparse.linalg: Add ARPACK C code for sym real

* MAINT:sparse.linalg: Adjust arpack.py for C rewrite

[skip ci]

* MAINT: sparse.linalg: Add undefs for custom macros to header

* MAINT: sparse.linalg: Rename the ishift field to shift in nonsym

* MAINT: sparse.linalg: Fix the LAPACK call syntax in sym code

* MAINT: sparse.linalg: Finish ARPACK full compiled meson file

[skip ci]

* MAINT: sparse.linalg: Finish ARPACK full compiled header file

* MAINT: sparse.linalg: Finish ARPACK full compiled nonsym complex solvers

* MAINT: sparse.linalg: Finish ARPACK full compiled nonsymmetric real solver

* MAINT: sparse.linalg: Finish ARPACK full compiled sym real solvers

* MAINT: sparse.linalg: Modify ARPACK Python driver file

[skip ci]

* MAINT: sparse.linalg: Add new module file for ARPACK interface

* MAINT: sparse.linalg: Clean up gitignore file for removed F77 code

[skip ci]

* MAINT: sparse.linalg: Remove the ARPACK int selection

* MAINT: sparse.linalg: Adjustments to the arpack.py file after rewrite

* MAINT: sparse.linalg: Add nonsymmetric symbols to the header file

* MAINT: sparse.linalg: ARPACK nonsym real fixes and typos

* MAINT: sparse.linalg: Remove dependence to complex dotc routines in ARPACK

* MAINT: sparse.linalg: Create the ARPACK extension module code

* MAINT: sparse.linalg: Adjust meson file for ARPACK ext module

[skip ci]

* MAINT: sparse.linalg: Adjustments to the arpack.py file for rng

* MAINT: sparse.linalg: Temporary changes to module for testing

* MAINT: sparse.linalg: Add ido=5 for random OPX ARPACK operation

* MAINT: sparse.linalg: Fix comments in nonsymmetric complex code

* MAINT: sparse.linalg: Printed version of nonsym real code for segfault fixes

[skip ci]

* MAINT:sparse.linalg: Add more debugging to nonsym ARPACK code

* ENH:sparse.linalg: Add sneupd to the ARPACK module

[skip ci]

* MAINT:sparse.linalg: More troubleshooting segfaults

[skip ci]

* MAINT: sparse.linalg: Segfaults fixed in ARPACK nonsym real solver

[skip ci]

* MAINT:sparse.linalg: Fixes various nonsym real bugs verified large examples

[skip ci]

* FIX:sparse.linalg: Typo in the post-processing nonsym real eigs

[skip ci]

* ENH:sparse.linalg: Complex nonsym solver first pass

[skip ci]

* MAINT:sparse.linalg: Add zneupd to module and convert to multi-phase init

[skip ci]

* MAINT:sparse.linalg: Add missing casts for NumPy pointers in ARPACK module

[skip ci]

* FIX:sparse.linalg: Modify ARPACK codes for random array on Python side

[skip ci]

* ENH:sparse.linalg: Add nonsym complex protos to header file

[skip ci]

* ENH:sparse.linalg: Add nonsym complex ARPACK solvers

[skip ci]

* TMP:sparse.linalg: Turn on pedantic flag on ARPACK

[skip ci]

* SQ: Arpack.py

* ENH:sparse.linalg: Complete the rewrite of ARPACK sym solvers

[skip ci]

* ENH:sparse.linalg: Complete all the function wrapping in ARPACK module

[skip ci]

* SQ: arpack.py

* ENH:sparse.linalg: Expose all the functions in ARPAKC header

* FIX:sparse.linalg: Allow for user defined initial vector in NonSym real ARPACK

* TST:sparse.linalg: Allow for the reentrant ARPACK test

[skip ci]

* BUG:sparse.linalg: Fix the evec reordering in nonsym real ARPACK solver

* BUG:sparse.linalg: Fix reordering in nonsym complex ARPACK solver

* BUG:sparse.linalg: Clear error code after aupd calls in ARPACK

* MAINT:sparse.linalg: Remove unused variables from nonsym real ARPACK code

* MAINT:sparse.linalg: Remove unused variables from nonsym complex ARPACK code

* MAINT:sparse.linalg: Remove hangups from sym ARPACK solver

* MAINT:sparse.linalg: Remove compiler flags from ARPACK meson file

[skip ci]

* BUG:sparse.linalg: Fix a few bugs in ARPACK sym solvers

* TST:sparse.linalg: Enable parallel and reentrance tests

* TST:sparse.linalg: Parametrize ARPACK tests

* MAINT:sparse.linalg: Remove Cpp guards from header

* BUG:sparse.linalg: Correct double parsing in dseupd

* TST:sparse.linalg: Remove unused import

* MAINT:sparse.linalg: int guard ARPACK maxiter value

* BUG:sparse.linalg: Fix typos in ARPACK nonsym complex solver

* MAINT:sparse.linalg: Remove spurious entries from the ARPACK struct and rename symbols

* MAINT:sparse.linalg: Remove spurious entries from the ARPACK dict

* MAINT:sparse.linalg: Add ARPACK license, struct member info and rename symbols

* MAINT:sparse.linalg: Rename exposed symbols with ARPACK prefix

* MAINT:sparse.linalg: Rename exposed symbols with ARPACK prefix

* MAINT:sparse.linalg: Rename exposed symbols with ARPACK prefix
---
 scipy/sparse/linalg/_eigen/_svds.py           |    3 -
 .../linalg/_eigen/arpack/ARPACK/CHANGES       |  431 ----
 .../linalg/_eigen/arpack/ARPACK/COPYING       |   45 -
 .../linalg/_eigen/arpack/ARPACK/README.md     |  376 ---
 .../linalg/_eigen/arpack/ARPACK/README.scipy  |   28 -
 .../linalg/_eigen/arpack/ARPACK/SRC/ccdotc.f  |   36 -
 .../linalg/_eigen/arpack/ARPACK/SRC/cgetv0.f  |  416 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/cnaitr.f  |  850 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/cnapps.f  |  507 ----
 .../linalg/_eigen/arpack/ARPACK/SRC/cnaup2.f  |  801 ------
 .../linalg/_eigen/arpack/ARPACK/SRC/cnaupd.f  |  664 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/cneigh.f  |  257 --
 .../linalg/_eigen/arpack/ARPACK/SRC/cneupd.f  |  876 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/cngets.f  |  178 --
 .../linalg/_eigen/arpack/ARPACK/SRC/csortc.f  |  322 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/cstatn.f  |   51 -
 .../linalg/_eigen/arpack/ARPACK/SRC/debug.h   |   16 -
 .../linalg/_eigen/arpack/ARPACK/SRC/dgetv0.f  |  421 ----
 .../linalg/_eigen/arpack/ARPACK/SRC/dnaitr.f  |  840 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/dnapps.f  |  649 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/dnaup2.f  |  846 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/dnaupd.f  |  693 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/dnconv.f  |  146 --
 .../linalg/_eigen/arpack/ARPACK/SRC/dneigh.f  |  318 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/dneupd.f  | 1071 --------
 .../linalg/_eigen/arpack/ARPACK/SRC/dngets.f  |  231 --
 .../linalg/_eigen/arpack/ARPACK/SRC/dsaitr.f  |  853 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/dsapps.f  |  518 ----
 .../linalg/_eigen/arpack/ARPACK/SRC/dsaup2.f  |  851 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/dsaupd.f  |  690 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/dsconv.f  |  138 -
 .../linalg/_eigen/arpack/ARPACK/SRC/dseigt.f  |  181 --
 .../linalg/_eigen/arpack/ARPACK/SRC/dsesrt.f  |  217 --
 .../linalg/_eigen/arpack/ARPACK/SRC/dseupd.f  |  867 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/dsgets.f  |  219 --
 .../linalg/_eigen/arpack/ARPACK/SRC/dsortc.f  |  344 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/dsortr.f  |  218 --
 .../linalg/_eigen/arpack/ARPACK/SRC/dstatn.f  |   61 -
 .../linalg/_eigen/arpack/ARPACK/SRC/dstats.f  |   47 -
 .../linalg/_eigen/arpack/ARPACK/SRC/dstqrb.f  |  594 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/sgetv0.f  |  421 ----
 .../linalg/_eigen/arpack/ARPACK/SRC/snaitr.f  |  840 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/snapps.f  |  647 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/snaup2.f  |  847 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/snaupd.f  |  693 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/snconv.f  |  146 --
 .../linalg/_eigen/arpack/ARPACK/SRC/sneigh.f  |  318 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/sneupd.f  | 1070 --------
 .../linalg/_eigen/arpack/ARPACK/SRC/sngets.f  |  231 --
 .../linalg/_eigen/arpack/ARPACK/SRC/ssaitr.f  |  853 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/ssapps.f  |  516 ----
 .../linalg/_eigen/arpack/ARPACK/SRC/ssaup2.f  |  850 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/ssaupd.f  |  690 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/ssconv.f  |  138 -
 .../linalg/_eigen/arpack/ARPACK/SRC/sseigt.f  |  181 --
 .../linalg/_eigen/arpack/ARPACK/SRC/ssesrt.f  |  217 --
 .../linalg/_eigen/arpack/ARPACK/SRC/sseupd.f  |  867 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/ssgets.f  |  219 --
 .../linalg/_eigen/arpack/ARPACK/SRC/ssortc.f  |  344 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/ssortr.f  |  218 --
 .../linalg/_eigen/arpack/ARPACK/SRC/sstatn.f  |   61 -
 .../linalg/_eigen/arpack/ARPACK/SRC/sstats.f  |   47 -
 .../linalg/_eigen/arpack/ARPACK/SRC/sstqrb.f  |  594 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/stat.h    |   21 -
 .../linalg/_eigen/arpack/ARPACK/SRC/version.h |   30 -
 .../linalg/_eigen/arpack/ARPACK/SRC/zgetv0.f  |  416 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/znaitr.f  |  850 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/znapps.f  |  507 ----
 .../linalg/_eigen/arpack/ARPACK/SRC/znaup2.f  |  801 ------
 .../linalg/_eigen/arpack/ARPACK/SRC/znaupd.f  |  664 -----
 .../linalg/_eigen/arpack/ARPACK/SRC/zneigh.f  |  257 --
 .../linalg/_eigen/arpack/ARPACK/SRC/zneupd.f  |  876 -------
 .../linalg/_eigen/arpack/ARPACK/SRC/zngets.f  |  178 --
 .../linalg/_eigen/arpack/ARPACK/SRC/zsortc.f  |  322 ---
 .../linalg/_eigen/arpack/ARPACK/SRC/zstatn.f  |   51 -
 .../linalg/_eigen/arpack/ARPACK/SRC/zzdotc.f  |   36 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/cmout.f  |  250 --
 .../linalg/_eigen/arpack/ARPACK/UTIL/cvout.f  |  240 --
 .../linalg/_eigen/arpack/ARPACK/UTIL/dmout.f  |  167 --
 .../linalg/_eigen/arpack/ARPACK/UTIL/dvout.f  |  122 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/icnteq.f |   18 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/icopy.f  |   77 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/iset.f   |   16 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/iswap.f  |   55 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/ivout.f  |  120 -
 .../_eigen/arpack/ARPACK/UTIL/second_NONE.f   |   36 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/smout.f  |  157 --
 .../linalg/_eigen/arpack/ARPACK/UTIL/svout.f  |  112 -
 .../linalg/_eigen/arpack/ARPACK/UTIL/zmout.f  |  250 --
 .../linalg/_eigen/arpack/ARPACK/UTIL/zvout.f  |  240 --
 .../linalg/_eigen/arpack/ARPACK/_arpack.h     |  266 ++
 .../_eigen/arpack/ARPACK/_arpack_n_double.c   | 2101 ++++++++++++++++
 .../_eigen/arpack/ARPACK/_arpack_n_double.h   |   32 +
 .../arpack/ARPACK/_arpack_n_double_complex.c  | 1861 ++++++++++++++
 .../arpack/ARPACK/_arpack_n_double_complex.h  |   45 +
 .../_eigen/arpack/ARPACK/_arpack_n_single.c   | 2101 ++++++++++++++++
 .../_eigen/arpack/ARPACK/_arpack_n_single.h   |   32 +
 .../arpack/ARPACK/_arpack_n_single_complex.c  | 1861 ++++++++++++++
 .../arpack/ARPACK/_arpack_n_single_complex.h  |   45 +
 .../_eigen/arpack/ARPACK/_arpack_s_double.c   | 2238 +++++++++++++++++
 .../_eigen/arpack/ARPACK/_arpack_s_double.h   |   31 +
 .../_eigen/arpack/ARPACK/_arpack_s_single.c   | 2238 +++++++++++++++++
 .../_eigen/arpack/ARPACK/_arpack_s_single.h   |   31 +
 scipy/sparse/linalg/_eigen/arpack/README      |   91 -
 .../linalg/_eigen/arpack/_arpackmodule.c      | 1078 ++++++++
 scipy/sparse/linalg/_eigen/arpack/arpack.py   |  382 +--
 .../linalg/_eigen/arpack/arpack.pyf.src       |  213 --
 scipy/sparse/linalg/_eigen/arpack/meson.build |  122 +-
 .../linalg/_eigen/arpack/tests/test_arpack.py |  169 +-
 109 files changed, 14278 insertions(+), 35406 deletions(-)
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/CHANGES
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/COPYING
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/README.md
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/README.scipy
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ccdotc.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cgetv0.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaitr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnapps.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaup2.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneigh.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cngets.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/csortc.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cstatn.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/debug.h
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dgetv0.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaitr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnapps.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaup2.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnconv.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneigh.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dngets.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaitr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsapps.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaup2.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsconv.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseigt.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsesrt.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsgets.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortc.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstatn.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstats.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstqrb.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sgetv0.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaitr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snapps.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaup2.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snconv.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneigh.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sngets.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaitr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssapps.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaup2.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssconv.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseigt.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssesrt.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssgets.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortc.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstatn.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstats.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstqrb.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/stat.h
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/version.h
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zgetv0.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaitr.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znapps.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaup2.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneigh.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneupd.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zngets.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zsortc.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zstatn.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zzdotc.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cmout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cvout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dmout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dvout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icnteq.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icopy.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iset.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iswap.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/ivout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/second_NONE.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/smout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/svout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zmout.f
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zvout.f
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack.h
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.c
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.h
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.c
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.h
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.c
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.h
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.c
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.h
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.c
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.h
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.c
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.h
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/README
 create mode 100644 scipy/sparse/linalg/_eigen/arpack/_arpackmodule.c
 delete mode 100644 scipy/sparse/linalg/_eigen/arpack/arpack.pyf.src

diff --git a/scipy/sparse/linalg/_eigen/_svds.py b/scipy/sparse/linalg/_eigen/_svds.py
index ce57e841f9..99ae362e5c 100644
--- a/scipy/sparse/linalg/_eigen/_svds.py
+++ b/scipy/sparse/linalg/_eigen/_svds.py
@@ -1,7 +1,5 @@
 import math
 import numpy as np
-
-from .arpack import _arpack  # type: ignore[attr-defined]
 from . import eigsh
 
 from scipy._lib._util import check_random_state, _transition_to_rng
@@ -10,7 +8,6 @@ from scipy.sparse.linalg._eigen.lobpcg import lobpcg  # type: ignore[no-redef]
 from scipy.sparse.linalg._svdp import _svdp
 from scipy.linalg import svd
 
-arpack_int = _arpack.timing.nbx.dtype
 __all__ = ['svds']
 
 
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/CHANGES b/scipy/sparse/linalg/_eigen/arpack/ARPACK/CHANGES
deleted file mode 100644
index 4ad3bd1602..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/CHANGES
+++ /dev/null
@@ -1,431 +0,0 @@
-arpack-ng - 3.9.1
-
-[ Fabien Péan ]
- * pyarpack: Ensure that the matrix properties (symmetric/hermitian) fit the solver (CG/LDL) with which they are used in the tests
- * [BUG FIX] Tests for PARPACK with C/C++ bindings icb_parpack_c and icb_parpack_cpp are now really parallel and split the problem across MPI processes.
- * Update arpackmm test suite: enable solving non-symmetric tests with BiCG solver
- * README: Add details on Windows installation.
- 
-[ Szabolcs Horvát ]
- * [BUG FIX] Ensure that LAPACK RNG state is propagated (regression in 3.9.0).
- * [BUG FIX] Ensure that separate random seeds are used on different parallel thread in D and S versions of functions (issue from original ARPACK).
-
-[ Ruoyu Feng ]
- * ICB(arpackdef.h): distinct intel llvm compiler (icx with clang-cl) from msvc on windows
- * ICB(arpackdef.h): Undef macro I if complex.h from msvc version is loaded, which is an usual name and causes issues on arpackSolver.
-
-[ Franck Houssen ]
- * [BUG FIX] Fix install: headers in /path/to/local/include/arpack for ICB samples
- * [BUG FIX] Fix install: headers in /path/to/local/include/arpack
- * arpackmm: allow for using LA/SA magnitudes.
- * Rename icbexmm option into eigen option.
- * README: document how to use ICB.
- * [BUG FIX] arpackmm: fix restart.
- * README: document where to find arpack user's guide.
-
- -- Franck Houssen <fghoussen@users.noreply.github.com> Sat, 14 Oct 2023 13:37:37 +0200
-
-arpack-ng - 3.9.0
-
-[ Vikas Sharma ]
- * Improve README.
-
-[ Fabien Péan ]
- * CI: Enable job `windows_latest_cmake` to run all tests
- * CMake: Fix BLAS and LAPACK static library order needed to consume the library on Windows with static linkage
- * Fix using ARPACK on Windows with MSVC compiler from C++17 onwards
-
-[ Zhentao Wang ]
- * [BUG FIX] parpack.h and parpack.hpp: type of rwork should be real instead of complex.
- * Allow ritz_option {"LR", "SR", "LI", "SI"} for complex eigenvalue problems in ICB.
-
-[ Jose E. Roman ]
- * Avoid using isnan() in tests, since is GNU-specific
-
-[ Tom Payerle ]
- * Change the continuation line format for stat.h, debug.h
-
-[ John Doe ]
- * Avoid calling [c|z]dotc for better portability on macOS
-
-[ Dima Pasechnik ]
- * [BUG FIX] autotools: replace obsolete AC_TRY_COMPILE macros.
- * Support for NAG's nagfor Fortran compiler
-
-[ Franck Houssen ]
- * Create one .cmake file per arpack-ng flavor (32-bits, 64-bits, ILP64).
- * Test autotools pkg-config (*.pc files) with/without LIBSUFFIX/ITF64SUFFIX.
- * Test CMake find_package (*.cmake files) with/without LIBSUFFIX/ITF64SUFFIX.
- * [BUG FIX] autotools: ICB must be checked first (MPI changes compilers).
- * [BUG FIX] BLAS/LAPACK: allow suffixes in case BLAS/LAPACK can not provide ICB.
- * [BUG FIX] Compile C programs with ICB.
- * arpackmm: command line bug fix.
- * arpackmm: restart bug fix.
- * pyarpack: fix compilation warning, test on macos and latest boost-python (1.79).
- * arpackSolver: fix error messages.
- * [BUG FIX] Make sure iseed is always initialized to values allowed by lapack ?larnv.
- * [BUG FIX] According to lapack doc of ?larnv, iseed(4) must be odd.
- * [BUG FIX] Use MPI ICB types (mpi_f08) instead of integer(kind=i_int).
- * parpack: no ILP64 support.
-
-[ Haoyang Liu ]
- * CMake: minimum required version changed to 3.0
- * CMake: add C99 standard checking
- * CI: Support for centos7 added.
- * CI: Add `scripts/travis_centos.sh` for centos builds
-
-[ Robert Schütz ]
- * use CMAKE_INSTALL_FULL_<dir> in arpack.pc
-
-[ Markus Mützel ]
- * CMake: Handle libraries without "lib" prefix.
- * CMake: Don't override BLAS/LAPACK/MPI flags. Directly use results from the Find* modules instead.
-
-[ Juan José García-Ripoll ]
- * Adapt the C/C++ interface to accept also MSVC's non-standard complex types.
- * Propagate dependencies to CMake targets that use arpack-ng:
-   - Create CMake-generated targets and configuration files that keep track of
-     arpack's dependencies (libraries, directories) and expose them to users.
-   - Install those files under ${prefix}/lib/cmake/arpackng* so that arpack can be
-     found using 'find_package(arpackng)' from CMake files.
-   - Add code to the arpackng-config.cmake to find required dependencies when this
-     module is loaded by find_package(arpackng).
-
- -- Sylvestre Ledru <sylvestre@debian.org> Mon, 07 Dec 2020 11:37:40 +0100
-
-arpack-ng - 3.8.0
-
-[ Myron Oikonomakis ]
- * [BUG FIX]: bmat return "G" instead of "B" for generalized matrix in arpack.hpp
- * [BUG FIX]: pass arrays of chars as scalar in fortran calls in order not to crash
- * when calling subroutines through icb interface
-
-[ Izaak "Zaak" Beekman ]
- * [BUG FIX]: fix 'Unknown CMake command "check_symbol_exists".' when ICB=ON.
-
-[ Franck Houssen ]
- * CI: Support for Mac OS X added in automation (GNU + "-ff2c -fno-second-underscore" options).
- * CI: Support for centos added in automation.
- * CI: Support for opensuse added in automation.
- * arpackSolver/arpackmm: switch eigen version to 3.3.
- * [BUG FIX] fix arpackdef.h (resp. arpackicb.h) must be included only by C/C++ (resp. F77/F90).
- * [BUG FIX] iparam/ipntr sizes may change depending on cases.
- * pyarpack: python binding based on Boost.Python.Numpy exposing C++ API.
- * [CLEAN] arpackSolver API: more convenient, suppress template parameters when possible.
- * [BUG FIX] ICB using rvec/select: rvec/select turned to integer
-   bool should be, but, is not always supported (depend on compiler, options).
- * extract arpackSolver.hpp from arpakmm.cpp.
- * arpackmm: add --slvItrPC option (PC: Jacobi, ILU).
- * arpackmm: add --slv LLT LDLT (for SPD matrices).
- * arpackmm: add --simplePrec option (to enable use of s*upd).
- * arpackmm: add --dense option.
- * autotools: provide *.cmake files (in addition to *.pc file).
- * [BUG FIX] ILP64 support: using debug_c and stat_c.
- * [BUG FIX] fix check precision which may fail with some ATLAS versions.
-
-[ Kyle Guinn ]
- * [BUG FIX]: fix 'eval: Syntax error: "(" unexpected' error at build time.
- * Only build shared libraries by default.  To build static libraries, use
-   --enable-static (autotools) or -DBUILD_SHARED_LIBS=OFF (cmake).
- * Add parpack.pc and arpackSolver.pc.
-
-[ David Schwörer ]
- * Support of gfortran 10
-
- -- Sylvestre Ledru <sylvestre@debian.org> Mon, 07 Dec 2020 11:35:57 +0100
-
-arpack-ng - 3.7.0
-
-[ Franck Houssen ]
- * [BUG FIX] ICB: missing workev for *[ds]neupd (real+not-sym) => API/ABI change for *[ds]neupd_c.
- * [BUG FIX] autotools - make distcheck: fix circular dependencies.
- * arpackmm: utility to test arpack with matrix market files.
- * ICB: add ILP64 support.
-    The idea is:
-    - autoheader/cmake generates arpackdef.h/arpackicb.h from arpackdef.h.in/arpackicb.h.in
-      - in C/C++ files: arpackdef.h defines a_int according to architecture.
-      - in F77/F90 files: arpackicb.h defines i_int to architecture.
-    - MPI does not support ILP64: integer*4 must be imposed in all
-      calls involving MPI (f90 example/test code).
-    To enable ILP64 users to compile/link, arpackdef.h/arpackicb.h is added in
-    the arpack installation (make install).
-
- [ Kyle Guinn ]
- * Autoconf/Automake simplifications and fixes.
- * Simplify the generation of arpackdef.h.
-
- -- Sylvestre Ledru <sylvestre@debian.org> Sat, 12 Jan 2019 16:24:00 +0100
-
-arpack-ng - 3.6.3
-
-[ Franck Houssen ]
- * Add Fortran common initialization (block data).
-
- [ Marco Caliari ]
- * Give up forcing the initial residual to be in the range of the operator OP after a restart (Closes: #142).
-
- -- Sylvestre Ledru <sylvestre@debian.org> Wed, 19 Sep 2018 09:59:59 +0200
-
-arpack-ng - 3.6.2
-
- * Remove all trailing whitespaces
-
- [ Franck Houssen ]
- * Install: move headers into a dedicated directory (local/include/arpack).
-   (Closes #126)
- * Add configuration summary.
- * Improve the flag detection. Hopefully fix the ppc64el and other archs
-   issues in Debian
-
- -- Sylvestre Ledru <sylvestre@debian.org> Sat, 23 Jun 2018 14:56:54 +0200
-
-arpack-ng - 3.6.1
-
- [ Ruslan Kabatsayev ]
- * Fix a regression on i386 and other archs (Closes #123)
-
- -- Sylvestre Ledru <sylvestre@debian.org> Thu Jun 7 21:41:16 2018 +0200
-
-arpack-ng - 3.6.0
-
- [ Franck Houssen ]
- * Add support for ISO_C_BINDING (Fortran 2003) for ARPACK, PARPACK (Fortran <-> C/C++).
-   ARPACK:  example of   C/Fortran binding can be found in the         TESTS/icb_arpack_c.c          file.
-   ARPACK:  example of C++/Fortran binding can be found in the         TESTS/icb_arpack_cpp.cpp      file.
-   PARPACK: example of   C/Fortran binding can be found in the PARPACK/TESTS/MPI/icb_parpack_c.c     file.
-   PARPACK: example of C++/Fortran binding can be found in the PARPACK/TESTS/MPI/icb_parpack_cpp.cpp file.
-   DEBUG:   add support for debug.
-   STAT:    add support for statistics (timers, nb operations, ...).
- * Provide tarball generation using cmake (cpack).
- * Provide find_package for (cmake) users to find arpack-ng.
-
- [ Denis Davydov ]
- * Rename pslamch to pslamch10 to avoid symbol collision with Scalapack 2.0.2 in MPI context.
-
- [ Kyle Guinn ]
- * Autoconf cleanup; move generated files to the build-aux subdirectory.
-
- [ Marco Caliari ]
- * Force the initial residual to be in the range of the operator OP in the standard case, too (Closes: #79).
-
- [ Sylvestre Ledru ]
- * Add coverage information to improve testing: https://coveralls.io/github/opencollab/arpack-ng
-
- [ Darcy Beurle]
- * Add C++11 interface through arpack.hpp and parpack.hpp
- * Rewrite C++ examples / tests demonstrating new C++11 interface
- * Pre-C++11 interface available through arpack.h and parpack.h
-
- -- Sylvestre Ledru <sylvestre@debian.org> Mon, 30 Oct 2017 14:21:48 +0200
-
-arpack-ng - 3.5.0
-
- [ Julien Schueller ]
- * Improve cmake build system: disable C++ detection, set default build type.
-
- [ Marco Atzeri]
- * Use AC_PROG_FC instead of AC_PROG_F77 for proper inizialization
-   for the usage of AC_FC_LINE_LENGTH. Noted on Cygwin.
-
- [ Denis Davydov ]
- * Improve cmake build system: add make install and fix shared libraries.
-
- [ Zhang Z ]
- * fix usages of DLACPY to not alias inputs
-   (patch from https://software.intel.com/en-us/articles/how-to-resolve-arpack-issues-with-intel-mkl-110-update-3)
-
- [ Iskakov Sergei ]
- *  Fix possible deadlock when PARPACK call uses communicator with a larger
-    number of CPUs than previous call
-
- [ Kyle Guinn ]
- * Portability improvements to the autotools build system.
- * Let cmake guess the default installation directories.  Can be
-   overridden by changing CMAKE_INSTALL_LIBDIR and CMAKE_INSTALL_BINDIR.
- * Shared libraries built by cmake now have their SONAME set identical to
-   those built by autotools.
-
- [ Marco Caliari ]
- * Avoid purification stage in [d,s]neupd.f if it requires division
-    by zero (Closes: #58)
-
- -- Sylvestre Ledru <sylvestre@debian.org>  Mon, 15 May 2017 14:21:48 +0200
-
-arpack-ng - 3.4.0
-
-  [ Milan Bouchet-Valat ]
-  * Allow adding suffixes to symbols and library names to build ILP64 version
-    based on ILP64 BLAS/LAPACK with suffixes. This avoids conflicts when loading
-    libraries with different integer sizes in the same program.
-
-  [ Martin Reuter ]
-  * Add the support of cmake build system
-
- -- Sylvestre Ledru <sylvestre@debian.org>  Sat, 02 Jul 2016 21:51:52 +0200
-
-arpack-ng - 3.3.0
-
- [ Denis Davydov ]
- * Rename pdlamch to pdlamch10 to avoid symbol collision with Scalapack 2.0.2 in MPI context.
-
- [ Kyle Guinn ]
- * General improvements on the build system
- * libparpack links against libarpack (instead of doing a static link)
-
- [ Guillaume Horel ]
- * reverts using {d,s}lahqr from lapack 2
- * use dlahqr from lapack 3 instead of dlaqrb (credit to Marco Caliari)
-
- -- Sylvestre Ledru <sylvestre@debian.org>  Mon, 12 October 2015 08:40:51 +0200
-
-arpack-ng - 3.2.0
-
- * Switch to github - https://github.com/opencollab/arpack-ng/
-
- * Fix dsneupd select/calculate wrong eigenpairs if rvec = true
-   by using dlahqr and slahqr from lapack2 (Closes: #3)
-
- -- Sylvestre Ledru <sylvestre@debian.org>  Sat, 14 Nov 2014 16:25:36 +0200
-
-arpack-ng - 3.1.5
-
- * Build all examples and run them as tests
-
- * Fix the version of arpack-ng itself
-
- * Switch to automake 1.14.1
-
- [ Ruediger Meier ]
- * Do not install test binaries (Closes: #1348)
-
- [ Nikita Styopin ]
- * Fix the diagonal matrix example (dndrv5) (Closes: #1397)
-
- -- Sylvestre Ledru <sylvestre@debian.org>  Sat, 15 Feb 2014 14:24:42 +0200
-
-arpack-ng - 3.1.4
-
- * libparpack2: missing dependency on MPI:
-   http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=718790
-
- * Replace LAPACK second function with ARPACK's own arscnd in PARPACK
-
- * Fix issue #1259 in DSEUPD and SSEUPD
-   The Ritz vector purification step assumes workl(iq) still contains the
-   original Q matrix. This is however overwritten by the call to xGEQR2
-   earlier.
-   .
-   This patch fixes the issue by making a copy of the last row of the
-   eigenvector matrix, after it is recomputed after QR by xORM2R. The work
-   space WORKL(IW+NCV:IW+2*NCV) is not used later in the routine, and can
-   be used for this.
-
- * Use configure supplied blas and lapack in the pkg-config.
-   Thanks to Ward Poelmans (Closes: #1320)
-
- * Switch to automake 1.14 + libtool 2.4.2.
-   Thanks to Ward Poelmans (Closes: #1321)
-
- * dseupd routine may lead to a segmentation fault
-   Thanks to Edouard Canot (Closes: #1323)
-
- * dsaupd and 'BE' option returns wrong eigenvalues for a SPD matrix
-   Thanks to Edouard Canot (Closes: #1329)
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Mon, 07 Oct 2013 14:24:42 +0200
-
-arpack-ng - 3.1.3
-
-  [ Jordi Gutiérrez Hermoso ]
-  * Replace depcomp symlink with actual file.
-  * Update libtool usage. Thanks to John W. Eaton <jwe@octave.org>.
-  * Replace arpack.pc with proper autotooled arpack.pc.in
-  * Add debug.h to TESTS/Makefile.am sources
-
-  * "make dist" is functional
-  * Also build the library "libparpacksrcblacs" (PARPACK/UTIL/BLACS/)
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Tue, 02 Apr 2013 10:53:08 +0200
-
-arpack-ng - 3.1.2
-
-   * Wrong call to pdlamch was causing segfaults
-     Thanks to Kyrre Sjøbæk for finding the bug and the fix.
-   * Get rid of the mpif.h occurrences in the source code (Closes: #782)
-   * Compile also PARPACK / MPI example (Closes: #783)
-   * Configure detected built-in LAPACK and BLAS, but refused to use them
-     (Closes: #784)
-   * Fixed division by zero in smlnum by using p[d,s]lamch instead of the
-     serial. Thanks to Umberto De Giovannini.
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Fri, 22 Jun 2012 22:05:41 +0200
-
-arpack-ng - 3.1.1
-
-   * Option --enable-maintainer-mode added to the configure
-   * --disable-mpi disables the build of parpack (Closes: #714)
-   * Switch to automake 1.11.3
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Mon, 21 May 2012 09:08:41 +0200
-
-arpack-ng - 3.1.0
-
-   * Many bug fixes in the parpack lib. It is an old patch from upstream.
-     Thanks to Viral Shah for pinging us on this subject.
-     See the PARPACK_CHANGES file for the details.
-   * Change the bug report from arpack@caam.rice.edu to
-     http://forge.scilab.org/index.php/p/arpack-ng/issues/
-   * Provide a M4 macro (detect_arpack_bug.m4) to check if the underlying
-     arpack is buggy (ie not arpack-ng). This allows developer applications
-     to perform the check in their autotools build system (configure).
-   * Fixed a lack of appropriate bounds check in DNAUP2. Thanks to Pauli Virtanen
-     for the patch (Closes: #632)
-   * Update of the doc about TOL in dnaupd.
-   * Reorder bug fixed when eigenvectors are requested and the resulting
-     number of converged eigenvalues is less than the number requested.
-     Patches from Tim Mitchell. (Closes: #664)
-   * TESTS/ directory added and built.
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Wed, 22 Feb 2012 10:58:39 +0100
-
-arpack-ng - 3.0.2
-
-   * Fix a long line in pznaup2.f which was showing some wrong symbols
-     (Closes: #620)
-   * README content updated regarding ARPACK-NG
-   * arpack.pc (pkg-config) file added
-   * Update the title & version in the configure.ac
-   * Always search for MPILIBS (in order to have the variable correctly set)
-   * Explicitly link against MPI fortran libs for parpack
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Wed, 28 Dec 2011 13:45:53 +0100
-
-arpack-ng - 3.0.1
-
-   * libtool was missing (Closes: #615)
-   * Missing license information (Closes: #614)
-   * TODO added
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Tue, 13 Dec 2011 16:33:25 +0100
-
-arpack-ng - 3.0
-
-   * Patches from Scilab
-     second_NONE used by default (TO DO replace by second in LAPACK)
-     second_NONE works with all fortrans compilers (used by default with Scilab)
-
-     sneupd.f, cneupd.f: modified for scilab add a check on nconv value (Scilab bug fix)
-     dnaupd.f: modified  NEV Integer: INPUT/OUTPUT before only INPUT (Scilab bug fix)
-
-   * Patches from Octave: (Thanks to John W. EATON)
-     dneupd.f: Restore value of nconv
-     dseupd.f: Restore value of nconv
-     sseupd.f: Change GOTO target to eliminate warning about landing on end if.
-     zneupd.f: Restore value of nconv
-
-   * Compilation
-     Apply gentoo patches to use an autotools build system
-     Build system updated to build with Visual Studio 2010 + Intel fortran 2011 compiles on Windows.
-     Specify the SONAME to libarpack.so.2 (no API/ABI changes compare to version 2.0)
-
- -- Sylvestre Ledru <sylvestre.ledru@scilab-enterprises.com>  Sat, 10 Dec 2011 20:32:45 +0100
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/COPYING b/scipy/sparse/linalg/_eigen/arpack/ARPACK/COPYING
deleted file mode 100644
index e87667e1b8..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/COPYING
+++ /dev/null
@@ -1,45 +0,0 @@
-
-BSD Software License
-
-Pertains to ARPACK and P_ARPACK
-
-Copyright (c) 1996-2008 Rice University.
-Developed by D.C. Sorensen, R.B. Lehoucq, C. Yang, and K. Maschhoff.
-All rights reserved.
-
-Arpack has been renamed to arpack-ng.
-
-Copyright (c) 2001-2011 - Scilab Enterprises
-Updated by Allan Cornet, Sylvestre Ledru.
-
-Copyright (c) 2010 - Jordi Gutiérrez Hermoso (Octave patch)
-
-Copyright (c) 2007 - Sébastien Fabbro (gentoo patch)
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-- Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer listed
-  in this license in the documentation and/or other materials
-  provided with the distribution.
-
-- Neither the name of the copyright holders nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/README.md b/scipy/sparse/linalg/_eigen/arpack/ARPACK/README.md
deleted file mode 100644
index a38fa76fd0..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/README.md
+++ /dev/null
@@ -1,376 +0,0 @@
-# arpack-ng [![arpack-ng CI/CD](https://github.com/opencollab/arpack-ng/actions/workflows/jobs.yml/badge.svg)](https://github.com/opencollab/arpack-ng/actions/workflows/jobs.yml)
-
-ARPACK-NG is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.
-| mandatory dependencies | optional dependencies     | category      |
-|------------------------|---------------------------|---------------|
-| BLAS, LAPACK           | MPI, Eigen3, Boost.Python | LinearAlgebra |
-
-## About the project
-
-This project started as a joint project between Debian, Octave and Scilab in order to provide a common and maintained version of arpack.
-This is now a community project maintained by a few volunteers.
-Indeed, no single release has been published by Rice university for the last few years and since many software (Octave, Scilab, R, Matlab...)
-forked it and implemented their own modifications, arpack-ng aims to tackle this by providing a common repository, maintained versions with a testsuite.
-`arpack-ng` is replacing arpack almost everywhere.
-
-## Important Features
-
-- Reverse Communication Interface (RCI).
-- Single and Double Precision Real Arithmetic Versions for Symmetric, Non-symmetric, Standard or Generalized Problems.
-- Single and Double Precision Complex Arithmetic Versions for Standard or Generalized Problems.
-- Routines for Banded Matrices - Standard or Generalized Problems.
-- Routines for The Singular Value Decomposition.
-- Example driver routines that may be used as templates to implement numerous
-- Shift-Invert strategies for all problem types, data types and precision.
-- `arpackmm`: utility to test arpack with matrix market files. Note: to run this utility, you need the eigen library (to handle RCI).
-
-## Documentation
-
-Within DOCUMENTS directory there are three files for templates on how to invoke the computational modes of ARPACK.
-
-- ex-sym.doc
-- ex-nonsym.doc and
-- ex-complex.doc
-
-Also look in the README.MD file for explanations concerning the
-other documents.
-
-## ILP64 support
-
-About ILP64 support:
-
-- Sequential arpack supports [ILP64](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-linux-developer-guide/top/linking-your-application-with-onemkl/linking-in-detail/linking-with-interface-libraries/using-the-ilp64-interface-vs-lp64-interface.html), but, parallel arpack doesn't.
-- Reminder: you can NOT mix `ILP64` with `LP64`. If you compile `arpack-ng` with `ILP64` (resp. `LP64`) support, you MUST insure your BLAS/LAPACK is compliant with `ILP64` (resp. `LP64`).
-- Set `INTERFACE64` at configure time.
-
-Note for F77/F90 developers:
-
-- All files which needs `ILP64` support must include `"arpackicb.h"`.
-- When coding, use `i_int` (defined in `arpackicb.h`) instead of `c_int`. `i_int` stands for ISO_C_BINDING integer: it's `#defined` to `c_int` or `c_int64_t` according to the architecture.
-
-Note for C/C++ developers:
-
-- All files which needs `ILP64` support must include `"arpackdef.h"`.
-- When coding, use `a_int` (defined in `arpackdef.h`) instead of `int`. Here, `a_int` stands for "architecture int": it's `#defined` to `int` or `int64_t` according to the architecture.
-
-**Example**: to test arpack with sequential `ILP64` MKL assuming you use gnu compilers
-
-```bash
-$ ./bootstrap
-$ export FFLAGS='-DMKL_ILP64 -I/usr/include/mkl'
-$ export FCFLAGS='-DMKL_ILP64 -I/usr/include/mkl'
-$ export LIBS='-Wl,--no-as-needed -L/usr/lib/x86_64-linux-gnu -lmkl_sequential -lmkl_core -lpthread -lm -ldl'
-$ export INTERFACE64=1
-$ ./configure --with-blas=mkl_gf_ilp64 --with-lapack=mkl_gf_ilp64
-$ make all check
-```
-
-## ISO_C_BINDING support
-
-About ISO_C_BINDING support:
-
-- The install will now provide `arpack.h/hpp`, `parpack.h/hpp` and friends.
-- Examples of use can be found in `./TESTS` and` ./PARPACK/TESTS/MPI`.
-
-ISO_C_BINDING is a feature of modern Fortran meant to handle safely interoperability between Fortran and C (in practice, no more need to use ugly tricks to link F77 functions to C code using "underscored" symbols). Basically, ISO_C_BINDING make sure all fortran variables are typed (which may not always be the case when using `implicit` keyword in fortran): this way, C compilers can link properly. For more informations on ISO_C_BINDING, you can checkout the following links:
-
-- <http://fortranwiki.org/fortran/show/ISO_C_BINDING>
-- <http://fortranwiki.org/fortran/show/Generating+C+Interfaces>
-
-Using ICB is seamless:
-
-- Compile `arpack-ng` with ISO_C_BINDING: you'll get both old-fashion fortran symbols and new ISO_C_BINDING symbols available for linking.
-- Add `#include "arpack.h"` in your C code.
-- Replace all [sdcz][ae]upd calls by [sdcz][ae]upd_c: functions suffixed with _c are ISO_C_BINDING compliant (exposing same arguments than original fortran functions).
-
-**Example**: to test arpack with ISO_C_BINDING
-
-```bash
-$ ./configure --enable-icb
-$ cmake -D ICB=ON
-```
-
-## Eigen support
-
-`arpack-ng` provides C++ eigensolver based on both ISO_C_BINDING and `eigen`.
-
-Check out `./EXAMPLES/MATRIX_MARKET/README` for more details.
-
-**Example**: to test arpack with `eigen`
-
-```bash
-$ mkdir build
-$ cd build
-$ cmake -D EXAMPLES=ON -D ICB=ON -D EIGEN=ON ..
-$ make all check
-```
-
-## Python support
-
-`pyarpack`: python support based on `Boost.Python.Numpy` exposing C++ API.
-`pyarpack` exposes in python the `arpack-ng` C++ eigensolver (based on `eigen`).
-
-Check out `./EXAMPLES/PYARPACK/README` for more details.
-
-**Example**: to test arpack with python3
-
-```bash
-$ mkdir build
-$ cd build
-$ cmake -D EXAMPLES=ON -D ICB=ON -D EIGEN=ON -D PYTHON3=ON ..
-$ make all check
-```
-
-## 📁 Directory structure
-
-- You have successfully unbundled ARPACK-NG` and are now in the ARPACK-NG directory that was created for you.
-
-- The directory SRC contains the top level routines including the highest level **reverse communication interface** routines
-
-  - `ssaupd`, `dsaupd`: symmetric single and double precision
-  - `snaupd`, `dnaupd`: non-symmetric single and double precision
-  - `cnaupd`, `znaupd`: complex non-symmetric single and double precision
-  - The headers of these routines contain full documentation of calling sequence and usage.
-  - Additional information is given in the `/DOCUMENTS` directory.
-
-- The directory `PARPACK` contains the Parallel ARPACK routines.
-
-- Example driver programs that illustrate all the computational modes, data types and precisions may be found in the EXAMPLES directory. Upon executing the `ls EXAMPLES` command you should see the following directories
-
-  ```bash
-  ├── BAND
-  ├── COMPLEX
-  ├── Makefile.am
-  ├── MATRIX_MARKET
-  ├── NONSYM
-  ├── PYARPACK
-  ├── README
-  ├── SIMPLE
-  ├── SVD
-  └── SYM
-  ```
-
-  - Example programs for banded, complex, nonsymmetric, symmetric, and singular value decomposition may be found in the directories BAND, COMPLEX, NONSYM, SYM, SVD respectively.
-  - Look at the README file for further information.
-  - To get started, get into the SIMPLE directory to see example programs that illustrate the use of ARPACK in the simplest modes of operation for the most commonly posed standard eigenvalue problems.
-
-> Example programs for Parallel ARPACK may be found in the directory `PARPACK/EXAMPLES`. Look at the README file for further information.
-
-## Install 🚀
-
-### Getting arpack-ng
-
-Unlike ARPACK, ARPACK-NG is providing autotools and cmake based build system. In addition, `ARPACK-NG` also provides
-ISO_C_BINDING support, which enables to call fortran subroutines natively from C or C++.
-
-First, obtain the source code 📥 from github:
-
-```bash
-$ git clone https://github.com/opencollab/arpack-ng.git
-$ cd ./arpack-ng
-```
-
-If you prefer the ssh to obtain the source code, then use:
-
-```bash
-$ git clone git@github.com:opencollab/arpack-ng.git
-$ cd ./arpack-ng
-```
-
-> Note, It is recommended to install `arpack` at standard location on your system by using your root privilege.
-
-### Using autotools
-
-In the source directory, use the following commands to configure, build and install `arpack-ng`.
-
-```bash
-$ sh bootstrap
-$ ./configure --enable-mpi
-$ make
-$ make check
-$ sudo make install
-```
-
-Congratulations 🎉, you have installed `arpack` lib using autotools (caution: you need `sudo` to install in your system).
-
-The above-mentioned process will build everything including the examples and parallel support using MPI.
-
-### Using cmake
-
-You can install `ARPACK-NG` by using cmake. If you do not have cmake, then please download the binary from `pip` using:
-
-```bash
-$ python3 -m pip install cmake
-$ which cmake && cmake --version
-```
-
-After installing cmake, follow the instruction given below.
-
-Caution: Make sure you are in source directory of ARPACK-NG.
-
-```bash
-$ mkdir build
-$ cd build
-$ cmake -D EXAMPLES=ON -D MPI=ON -D BUILD_SHARED_LIBS=ON ..
-$ make
-$ sudo make install
-```
-
-✨ Congratulations, you have installed `arpack` lib using cmake (caution: you need `sudo` to install in your system).
-
-The above-mentioned process will build everything including the examples and parallel support using MPI.
-
-### Customize build / install
-
-You can also customize the installation of `arpack` using the autotools.
-
-To customize the install directories:
-
-```bash
-$ LIBSUFFIX="64" ./configure
-$ make all install
-```
-
-To enable ILP64 support:
-
-```bash
-$ INTERFACE64="1" ITF64SUFFIX="ILP64" ./configure
-$ make all install
-```
-
-To enable ISO_C_BINDING support:
-
-```bash
-$ ./configure --enable-icb
-```
-
-You can customize the build by declaring the cmake options during configuration.
-
-To customize the install directories:
-
-```bash
-$ cmake -D LIBSUFFIX="64" ..
-$ make all install
-```
-
-To enable ILP64 support:
-
-```bash
-$ cmake -D INTERFACE64=ON -D ITF64SUFFIX="ILP64" ..
-$ make all install
-```
-
-To enable ISO_C_BINDING support:
-
-```bash
-$ cmake -D ICB=ON
-```
-
-## Supported Operating Systems:
-
-### Linux support
-
-`arpack-ng` runs on debian-based distros.
-
-### Mac OS support
-
-On mac OS, with GNU compilers, you may need to customize options:
-
-```bash
-$ LIBS="-framework Accelerate" FFLAGS="-ff2c -fno-second-underscore" FCFLAGS="-ff2c -fno-second-underscore" ./configure
-```
-
-### Windows support
-
-`arpack-ng` can be installed on Windows as a MinGW-w64 package via various distribution, for example through [MSYS2](https://packages.msys2.org/package/mingw-w64-x86_64-arpack) with `pacman -S mingw-w64-x86_64-arpack`. It can also be built and installed through [vcpkg](https://github.com/microsoft/vcpkg) with `vcpkg install arpack-ng`.
-
-## Using arpack-ng from your own codebase
-
-The `*.pc` and `*.cmake` files provided by `arpack-ng` are only pointing to arpack libraries.
-If you need other libraries (like MPI), you must add them alongside arpack (see CMake example below).
-
-Typically, if you need
-
-- ARPACK: at compile/link time, you'll need to provide BLAS and LAPACK.
-
-- ARPACK with eigen support (arpackSolver): at compile/link time, you'll need to provide BLAS, LAPACK and Eigen.
-
-- PARPACK: at compile/link time, you'll need to provide BLAS, LAPACK and MPI.
-
-Examples are provided in `tstCMakeInstall.sh` and `tstAutotoolsInstall.sh` generated after running cmake/configure.
-
-### With autotools
-
-First, set `PKG_CONFIG_PATH` to the location in the installation directory where `arpack.pc` lies.
-
-Then, insert the following lines in your `configure.ac`:
-```
-PKG_CHECK_MODULES([ARPACK], [arpack])
-AC_SUBST([ARPACK_CFLAGS])
-AC_SUBST([ARPACK_LIBS])
-```
-
-Note: make sure you have installed `pkg-config`.
-
-### With CMake
-
-You can use arpack in your CMake builds by using `ARPACK::ARPACK` target. For example,
-
-```cmake
-FIND_PACKAGE(arpackng)
-ADD_EXECUTABLE(main main.f)
-TARGET_INCLUDE_DIRECTORIES(main PUBLIC ARPACK::ARPACK)
-TARGET_LINK_LIBRARIES(main ARPACK::ARPACK)
-```
-
-To use PARPACK in your Cmake builds, use `PARPACK::PARPACK` target:
-
-```cmake
-FIND_PACKAGE(arpackng)
-FIND_PACKAGE(MPI REQUIRED COMPONENTS Fortran)
-ADD_EXECUTABLE(main main.f)
-TARGET_INCLUDE_DIRECTORIES(main PUBLIC PARPACK::PARPACK)
-TARGET_LINK_LIBRARIES(main PARPACK::PARPACK)
-TARGET_INCLUDE_DIRECTORIES(main PUBLIC MPI::MPI_Fortran)
-TARGET_LINK_LIBRARIES(main MPI::MPI_Fortran)
-```
-
-Note: Make sure to update `CMAKE_MODULE_PATH` env variable (otheriwse, `find_package` won't find arpack-ng cmake file).
-
-### FAQ
-
-- Where can I find ARPACK user's guide?
-
-  http://li.mit.edu/Archive/Activities/Archive/CourseWork/Ju_Li/MITCourses/18.335/Doc/ARPACK/Lehoucq97.pdf
-
-- Calling arpack's aupd methods returns `info = -9 - Starting vector is zero.`: why?
-
-  Residuals are null. Try to set `resid` to small values (like epsilon machine magnitude) but *not exactly* zero.
-  Residuals `resid = A*v - lamdba*v` target *exactly* the zero vector.
-  When `resid` is close enough to zero, the iterative procedure stops.
-
-- Say I have an estimate of an eigen value, how to give this information to arpack?
-
-  You need to shift of an amount of about this estimate of `lambda`. Grep `backTransform` in `arpackSolver.hpp` to see an example.
-  For more informations, checkout "NUMERICAL METHODS FOR LARGE EIGENVALUE PROBLEMS" by Yousef Saad: https://www-users.cse.umn.edu/~saad/eig_book_2ndEd.pdf (paragraph 4.1.2. and section 4.1.).
-
-- Say I have an estimate of an eigen vector, how to give this information to arpack?
-
-  You need to copy this eigen vector estimate in `v` (not `resid`) and set `info` to 1 before calling aupd methods.
-  The `v` vector targets a non-null vector such that `resid = 0`, that is, such that `A*v = lambda*v`.
-
-- Using PARPACK, I get incorrect eigen values.
-
-  Make sure each MPI processor handles a subpart of the eigen system (matrices) only.
-  ARPACK handles and solves the whole eigen problem (matrices) at once.
-  PARPACK doesn't: each MPI processor must handle and solve a subpart of the eigen system (matrices) only (independently from the other processors).
-  See examples for Fortran in folder `PARPACK/EXAMPLES/MPI`, and for C/C++ examples in `PARPACK/TESTS/MPI/icb_parpack_c.c` and `PARPACK/TESTS/MPI/icb_parpack_cpp.cpp`
-
-## Using MKL instead of BLAS / LAPACK
-
-How to use arpack-ng with Intel MKL:
-
-- Let autotools/cmake find MKL for you based on pkg-config files (setting `PKG_CONFIG_PATH`) or cmake options (`BLA_VENDOR=Intel10_64lp` for lp64, `BLA_VENDOR=Intel10_64ilp` for ilp64).
-- Refers to the Intel Link Advisor: <https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl-link-line-advisor.html>.
-
-## Good luck and enjoy 🎊
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/README.scipy b/scipy/sparse/linalg/_eigen/arpack/ARPACK/README.scipy
deleted file mode 100644
index eea037c4f9..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/README.scipy
+++ /dev/null
@@ -1,28 +0,0 @@
-This directory contains a bundled version of ARPACK-NG 3.9.1,
-https://github.com/opencollab/arpack-ng
-
-NOTE FOR VENDORS: it is in general safe to use a system version of ARPACK
-instead. Note, however, that ARPACK and early versions of ARPACK-NG have
-certain bugs, so using those over the bundled version is not recommended.
-
-For versions of ARPACK-NG prior to 3.9.0, the bundled version has the 
-following patch applied:
-
-Replace calls to certain Fortran functions with wrapper
-functions, to avoid various ABI mismatches on OSX. These changes are
-made with the following command:
-
-perl -pi -e '
-s@\bcdotc\b@wcdotc@g;
-s@\bzdotc\b@wzdotc@g;
-s@\bcdotu\b@wcdotu@g;
-s@\bzdotu\b@wzdotu@g;
-s@\bcladiv\b@wcladiv@g;
-s@\bzladiv\b@wzladiv@g;
-s@\bslamch\b@slamch@g;' \
-SRC/*.f UTIL/*.f
-
-For versions 3.9.0+, this is not necessary anymore and the issue is resolved
-via vendoring the copies of ccdotc and zzdotc.
-
-See https://github.com/opencollab/arpack-ng/pull/346 for more details.
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ccdotc.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ccdotc.f
deleted file mode 100644
index f0f94f4223..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ccdotc.f
+++ /dev/null
@@ -1,36 +0,0 @@
-      complex function ccdotc(n,zx,incx,zy,incy)
-c
-c     forms the dot product of a vector.
-c     jack dongarra, 3/11/78.
-c     modified 12/3/93, array(1) declarations changed to array(*)
-c
-      complex zx(*),zy(*),ztemp
-      integer i,incx,incy,ix,iy,n
-      ztemp = (0.0d0,0.0d0)
-      ccdotc = (0.0d0,0.0d0)
-      if(n.le.0)return
-      if(incx.eq.1.and.incy.eq.1)go to 20
-c
-c        code for unequal increments or equal increments
-c          not equal to 1
-c
-      ix = 1
-      iy = 1
-      if(incx.lt.0)ix = (-n+1)*incx + 1
-      if(incy.lt.0)iy = (-n+1)*incy + 1
-      do 10 i = 1,n
-        ztemp = ztemp + conjg(zx(ix))*zy(iy)
-        ix = ix + incx
-        iy = iy + incy
-   10 continue
-      ccdotc = ztemp
-      return
-c
-c        code for both increments equal to 1
-c
-   20 do 30 i = 1,n
-        ztemp = ztemp + conjg(zx(i))*zy(i)
-   30 continue
-      ccdotc = ztemp
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cgetv0.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cgetv0.f
deleted file mode 100644
index c231eadcb4..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cgetv0.f
+++ /dev/null
@@ -1,416 +0,0 @@
-c\BeginDoc
-c
-c\Name: cgetv0
-c
-c\Description:
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.
-c
-c\Usage:
-c  call cgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM,
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to cgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that cgetv0 is called.
-c          It should be set to 1 on the initial call to cgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Complex N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Real scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Complex work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     cvout   ARPACK utility routine that prints vectors.
-c     clarnv  LAPACK routine for generating a random vector.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.3   DATE OF SID: 08/27/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cgetv0
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm,
-     &     ipntr, workd, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &            rzero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Real
-     &           rnorm0
-      Complex
-     &           cnorm
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy, cgemv, clarnv, cvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           scnrm2, slapy2
-      Complex
-     &           ccdotc
-      external   ccdotc, scnrm2, slapy2
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call clarnv (idist, iseed, n, resid)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (itry .eq. 1) then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call ccopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         else if (itry .gt. 1 .and. bmat .eq. 'G') then
-            call ccopy (n, resid, 1, workd(n + 1), 1)
-         end if
-      end if
-c
-c     %----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing OP*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c
-      call arscnd (t3)
-      tmvopx = tmvopx + (t3 - t2)
-c
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (itry .eq. 1) call ccopy (n, workd(n + 1), 1, resid, 1)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call ccopy (n, resid, 1, workd, 1)
-      end if
-c
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          cnorm  = ccdotc (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(slapy2(real(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-           rnorm0 = scnrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call cgemv ('C', n, j-1, one, v, ldv, workd, 1,
-     &            zero, workd(n+1), 1)
-      call cgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1,
-     &            one, resid, 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call ccopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call ccopy (n, resid, 1, workd, 1)
-      end if
-c
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      if (bmat .eq. 'G') then
-         cnorm = ccdotc (n, resid, 1, workd, 1)
-         rnorm = sqrt(slapy2(real(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-         rnorm = scnrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call svout (logfil, 1, [rnorm0], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, [rnorm], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c
-      iter = iter + 1
-      if (iter .le. 1) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = rzero
-         ierr = -1
-      end if
-c
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, 1, [rnorm], ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 2) then
-         call cvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cgetv0 |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaitr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaitr.f
deleted file mode 100644
index 3759760dfb..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaitr.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaitr
-c
-c\Description:
-c  Reverse communication interface for applying NP additional steps to
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in cnaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call cnaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See cnaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.
-c          Only work for NB = 1 right now.  The goal is to have a
-c          program that implement both the block and non-block method.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Complex N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     cgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     clanhs  LAPACK routine that computes various norms of a matrix.
-c     clascl  LAPACK routine for careful scaling of a matrix.
-c     slabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     caxpy   Level 1 BLAS that computes a vector triad.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     cscal   Level 1 BLAS that scales a vector.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.3   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k};
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in cnaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh,
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rone, rzero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rone = 1.0E+0, rzero = 0.0E+0)
-c
-c     %--------------%
-c     | Local Arrays |
-c     %--------------%
-c
-      Real
-     &           rtemp(2)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Real
-     &           ovfl, smlnum, tst1, ulp, unfl, betaj,
-     &           temp1, rnorm1, wnorm
-      Complex
-     &           cnorm
-c
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   caxpy, ccopy, cscal, csscal, cgemv, cgetv0,
-     &           slabad, cvout, cmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Complex
-     &           ccdotc
-      Real
-     &           slamch,  scnrm2, clanhs, slapy2
-      external   ccdotc, scnrm2, clanhs, slamch, slapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, real, max, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine clahqr     |
-c        %-----------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = real(one / unfl)
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mcaitr
-c
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         cgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [j], ndigit,
-     &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, [rnorm], ndigit,
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determine whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. rzero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [j], ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            betaj  = rzero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call cgetv0 (ido, bmat, itry, .false., n, j, v, ldv,
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tcaitr = tcaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call ccopy (n, resid, 1, v(1,j), 1)
-         if ( rnorm .ge. unfl) then
-             temp1 = rone / rnorm
-             call csscal (n, temp1, v(1,j), 1)
-             call csscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine clascl               |
-c            %-----------------------------------------%
-c
-             call clascl ('General', i, i, rnorm, rone,
-     &                    n, 1, v(1,j), n, infol)
-             call clascl ('General', i, i, rnorm, rone,
-     &                    n, 1, workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call ccopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c
-         go to 9000
-   50    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call ccopy (n, workd(irj), 1, resid, 1)
-c
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             cnorm = ccdotc (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             wnorm = scnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         call cgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. |
-c        %--------------------------------------%
-c
-         call cgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = cmplx(betaj, rzero)
-c
-         call arscnd (t4)
-c
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then
-            cnorm = ccdotc (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-            rnorm = scnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if ( rnorm .gt. 0.717*wnorm ) go to 100
-c
-         iter  = 0
-         nrorth = nrorth + 1
-c
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            rtemp(1) = wnorm
-            rtemp(2) = rnorm
-            call svout (logfil, 2, rtemp, ndigit,
-     &      '_naitr: re-orthogonalization; wnorm and rnorm are')
-            call cvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call cgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call cgemv ('N', n, j, -one, v, ldv, workd(irj), 1,
-     &               one, resid, 1)
-         call caxpy (j, one, workd(irj), 1, h(1,j), 1)
-c
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             cnorm  = ccdotc (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt( slapy2(real(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             rnorm1 = scnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, [j], ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                rtemp(1) = rnorm
-                rtemp(2) = rnorm1
-                call svout (logfil, 2, rtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if ( rnorm1 .gt. 0.717*rnorm ) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = rzero
-         end if
-c
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c
-         rstart = .false.
-         orth2  = .false.
-c
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tcaitr = tcaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine clahqr        |
-c              %--------------------------------------------%
-c
-               tst1 = slapy2(real(h(i,i)),aimag(h(i,i)))
-     &              + slapy2(real(h(i+1,i+1)), aimag(h(i+1,i+1)))
-               if( tst1.eq.real(zero) )
-     &              tst1 = clanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( slapy2(real(h(i+1,i)),aimag(h(i+1,i))) .le.
-     &                    max( ulp*tst1, smlnum ) )
-     &             h(i+1,i) = zero
- 110        continue
-c
-            if (msglvl .gt. 2) then
-               call cmout (logfil, k+np, k+np, h, ldh, ndigit,
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cnaitr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnapps.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnapps.f
deleted file mode 100644
index c3a55623f8..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnapps.f
+++ /dev/null
@@ -1,507 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call cnapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ,
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Complex array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Complex N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper
-c          Hessenberg matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k}
-c          in the first KEV locations.
-c
-c  Q       Complex KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Complex work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     clacpy  LAPACK matrix copy routine.
-c     clanhs  LAPACK routine that computes various norms of a matrix.
-c     clartg  LAPACK Givens rotation construction routine.
-c     claset  LAPACK matrix initialization routine.
-c     slabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     cgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     caxpy   Level 1 BLAS that computes a vector triad.
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     cscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.3   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine clahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     Upon output, the subdiagonals of H are enforced to be non-negative
-c     real numbers.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq,
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           h(ldh,kev+np), resid(n), shift(np),
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rzero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, istart, j, jj, kplusp, msglvl
-      logical    first
-      Complex
-     &           cdum, f, g, h11, h21, r, s, sigma, t
-      Real
-     &           c,  ovfl, smlnum, ulp, unfl, tst1
-      save       first, ovfl, smlnum, ulp, unfl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   caxpy, ccopy, cgemv, cscal, clacpy, clartg,
-     &           cvout, claset, slabad, cmout, arscnd, ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           clanhs, slamch, slapy2
-      external   clanhs, slamch, slapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, aimag, conjg, cmplx, max, min, real
-c
-c     %---------------------%
-c     | Statement Functions |
-c     %---------------------%
-c
-      Real
-     &           cabs1
-      cabs1( cdum ) = abs( real( cdum ) ) + abs( aimag( cdum ) )
-c
-c     %----------------%
-c     | Data statements |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine clahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = real(one / unfl)
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcapps
-c
-      kplusp = kev + np
-c
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call claset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      do 110 jj = 1, np
-         sigma = shift(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, [jj], ndigit,
-     &               '_napps: shift number.')
-            call cvout (logfil, 1, [sigma], ndigit,
-     &               '_napps: Value of the shift ')
-         end if
-c
-         istart = 1
-   20    continue
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine clahqr    |
-c           %----------------------------------------%
-c
-            tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
-            if( tst1.eq.rzero )
-     &         tst1 = clanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if ( abs(real(h(i+1,i)))
-     &           .le. max(ulp*tst1, smlnum) )  then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, [i], ndigit,
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, [jj], ndigit,
-     &                 '_napps: matrix splitting with shift number.')
-                  call cvout (logfil, 1, h(i+1,i), ndigit,
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, [istart], ndigit,
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, [iend], ndigit,
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        | or if the current block starts after the point |
-c        | of compression since we'll discard this stuff  |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend .or. istart .gt. kev) go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         f = h11 - sigma
-         g = h21
-c
-         do 80 i = istart, iend-1
-c
-c           %------------------------------------------------------%
-c           | Construct the plane rotation G to zero out the bulge |
-c           %------------------------------------------------------%
-c
-            call clartg (f, g, c, s, r)
-            if (i .gt. istart) then
-               h(i,i-1) = r
-               h(i+1,i-1) = zero
-            end if
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the left of H;  H <- G'*H |
-c           %---------------------------------------------%
-c
-            do 50 j = i, kplusp
-               t        =  c*h(i,j) + s*h(i+1,j)
-               h(i+1,j) = -conjg(s)*h(i,j) + c*h(i+1,j)
-               h(i,j)   = t
-   50       continue
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the right of H;  H <- H*G |
-c           %---------------------------------------------%
-c
-            do 60 j = 1, min(i+2,iend)
-               t        =  c*h(j,i) + conjg(s)*h(j,i+1)
-               h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-               h(j,i)   = t
-   60       continue
-c
-c           %-----------------------------------------------------%
-c           | Accumulate the rotation in the matrix Q;  Q <- Q*G' |
-c           %-----------------------------------------------------%
-c
-            do 70 j = 1, min(i+jj, kplusp)
-               t        =   c*q(j,i) + conjg(s)*q(j,i+1)
-               q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-               q(j,i)   = t
-   70       continue
-c
-c           %---------------------------%
-c           | Prepare for next rotation |
-c           %---------------------------%
-c
-            if (i .lt. iend-1) then
-               f = h(i+1,i)
-               g = h(i+2,i)
-            end if
-   80    continue
-c
-c        %-------------------------------%
-c        | Finished applying the shift.  |
-c        %-------------------------------%
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %---------------------------------------------------%
-c     | Perform a similarity transformation that makes    |
-c     | sure that the compressed H will have non-negative |
-c     | real subdiagonal elements.                        |
-c     %---------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( real( h(j+1,j) ) .lt. rzero .or.
-     &        aimag( h(j+1,j) ) .ne. rzero ) then
-            t = h(j+1,j) / slapy2(real(h(j+1,j)),aimag(h(j+1,j)))
-            call cscal( kplusp-j+1, conjg(t), h(j+1,j), ldh )
-            call cscal( min(j+2, kplusp), t, h(1,j+1), 1 )
-            call cscal( min(j+np+1,kplusp), t, q(1,j+1), 1 )
-            h(j+1,j) = cmplx( real( h(j+1,j) ), rzero )
-         end if
-  120 continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine clahqr.       |
-c        | Note: Since the subdiagonals of the        |
-c        | compressed H are nonnegative real numbers, |
-c        | we take advantage of this.                 |
-c        %--------------------------------------------%
-c
-         tst1 = cabs1( h( i, i ) ) + cabs1( h( i+1, i+1 ) )
-         if( tst1 .eq. rzero )
-     &       tst1 = clanhs( '1', kev, h, ldh, workl )
-         if( real( h( i+1,i ) ) .le. max( ulp*tst1, smlnum ) )
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call cgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero,
-     &                workd(n+1), 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call cgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call ccopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call clacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call ccopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call cscal (n, q(kplusp,kev), resid, 1)
-      if ( real( h(kev+1,kev) ) .gt. rzero )
-     &   call caxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call cvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call cvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, [kev], ndigit,
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call cmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tcapps = tcapps + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of cnapps |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaup2.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaup2.f
deleted file mode 100644
index e361542472..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaup2.f
+++ /dev/null
@@ -1,801 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaup2
-c
-c\Description:
-c  Intermediate level interface called by cnaupd.
-c
-c\Usage:
-c  call cnaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, RWORK, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in cnaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in cnaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse communication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Complex  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex  array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV)  contains the computed Ritz values of OP.
-c
-c  BOUNDS  Complex  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Complex  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in CNAUPD.
-c
-c  RWORK   Real    work array of length  NEV+NP ( WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     cgetv0  ARPACK initial vector generation routine.
-c     cnaitr  ARPACK Arnoldi factorization routine.
-c     cnapps  ARPACK application of implicit shifts routine.
-c     cneigh  ARPACK compute Ritz values and error bounds routine.
-c     cngets  ARPACK reorder Ritz values and error bounds routine.
-c     csortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     cswap   Level 1 BLAS that swaps two vectors.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice Universitya
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.6   DATE OF SID: 06/01/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds,
-     &     q, ldq, workl, ipntr, workd, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Complex
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np),
-     &           resid(n), ritz(nev+np),  v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-       Real
-     &           rwork(nev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rzero
-      parameter (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) ,
-     &           rzero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    cnorm , getv0, initv , update, ushift
-      integer    ierr  , iter , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0   , nptemp, i    ,
-     &           j
-      Complex
-     &           cmpnorm
-      Real
-     &           rnorm , eps23, rtemp
-      character  wprime*2
-c
-      save       cnorm,  getv0, initv , update, ushift,
-     &           rnorm,  iter , kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0   , eps23
-c
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(3)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy, cgetv0, cnaitr, cneigh, cngets, cnapps,
-     &           csortc, cswap, cmout, cvout, ivout, arscnd
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Complex
-     &           ccdotc
-      Real
-     &           scnrm2, slamch, slapy2
-      external   ccdotc, scnrm2, slamch, slapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, real , min, max
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mcaup2
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvalues.     |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------%
-c        | Get machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call cgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. rzero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call cnaitr (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [iter], ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine cnapps.                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [nev], ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, [np], ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call cnaitr(ido, bmat, n, nev, np,    mode,  resid, rnorm,
-     &               v  , ldv , h, ldh, ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, [rnorm], ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call cneigh (rnorm, kplusp, h, ldh, ritz, bounds,
-     &                q, ldq, workl, rwork,  ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZ,    |
-c        | and BOUNDS respectively.                          |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-c
-c        %--------------------------------------------------%
-c        | Make a copy of Ritz values and the corresponding |
-c        | Ritz estimates obtained from cneigh.             |
-c        %--------------------------------------------------%
-c
-         call ccopy(kplusp,ritz,1,workl(kplusp**2+1),1)
-         call ccopy(kplusp,bounds,1,workl(kplusp**2+kplusp+1),1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | bounds are in the last NEV loc. of RITZ           |
-c        | BOUNDS respectively.                              |
-c        %---------------------------------------------------%
-c
-         call cngets (ishift, which, nev, np, ritz, bounds)
-c
-c        %------------------------------------------------------------%
-c        | Convergence test: currently we use the following criteria. |
-c        | The relative accuracy of a Ritz value is considered        |
-c        | acceptable if:                                             |
-c        |                                                            |
-c        | error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)). |
-c        |                                                            |
-c        %------------------------------------------------------------%
-c
-         nconv  = 0
-c
-         do 25 i = 1, nev
-            rtemp = max( eps23, slapy2( real (ritz(np+i)),
-     &                                  aimag(ritz(np+i)) ) )
-            if ( slapy2(real (bounds(np+i)),aimag(bounds(np+i)))
-     &                 .le. tol*rtemp ) then
-               nconv = nconv + 1
-            end if
-   25    continue
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_naup2: NEV, NP, NCONV are')
-            call cvout (logfil, kplusp, ritz, ndigit,
-     &           '_naup2: The eigenvalues of H')
-            call cvout (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. nev0) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call cvout(logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Eigenvalues computed by _neigh:')
-               call cvout(logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Ritz estimates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to cneupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = cmplx(rnorm,rzero)
-c
-c           %----------------------------------------------%
-c           | Sort Ritz values so that converged Ritz      |
-c           | values appear within the first NEV locations |
-c           | of ritz and bounds, and the most desired one |
-c           | appears at the front.                        |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call csortc(wprime, .true., kplusp, ritz, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23, magnitude of the Ritz value).  |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-                rtemp = max( eps23, slapy2( real (ritz(j)),
-     &                                       aimag(ritz(j)) ) )
-                bounds(j) = bounds(j)/rtemp
- 35         continue
-c
-c           %---------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz |
-c           | estimates.  This will push all the converged ones |
-c           | towards the front of ritz, bounds (in the case    |
-c           | when NCONV < NEV.)                                |
-c           %---------------------------------------------------%
-c
-            wprime = 'LM'
-            call csortc(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                rtemp = max( eps23, slapy2( real (ritz(j)),
-     &                                       aimag(ritz(j)) ) )
-                bounds(j) = bounds(j)*rtemp
- 40         continue
-c
-c           %-----------------------------------------------%
-c           | Sort the converged Ritz values again so that  |
-c           | the "threshold" value appears at the front of |
-c           | ritz and bound.                               |
-c           %-----------------------------------------------%
-c
-            call csortc(which, .true., nconv, ritz, bounds)
-c
-            if (msglvl .gt. 1) then
-               call cvout (logfil, kplusp, ritz, ndigit,
-     &            '_naup2: Sorted eigenvalues')
-               call cvout (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev0) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0)  info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. nev0) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call cngets (ishift, which, nev, np, ritz, bounds)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [nconv], ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call cvout (logfil, nev, ritz(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values ')
-               call cvout (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: pop back out to get the shifts |
-c           | and return them in the first 2*NP locations of WORKL. |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-   50    continue
-         ushift = .false.
-c
-         if ( ishift .ne. 1 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZ, to free up WORKL           |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call ccopy (np, workl, 1, ritz, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [np], ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call cvout (logfil, np, ritz, ndigit,
-     &                  '_naup2: values of the shifts')
-            if ( ishift .eq. 1 )
-     &          call cvout (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call cnapps (n, nev, np, ritz, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to cnaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call ccopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call ccopy (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            cmpnorm = ccdotc (n, resid, 1, workd, 1)
-            rnorm = sqrt(slapy2(real (cmpnorm),aimag(cmpnorm)))
-         else if (bmat .eq. 'I') then
-            rnorm = scnrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, [rnorm], ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call cmout (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tcaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of cnaup2 |
-c     %---------------%
-c
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaupd.f
deleted file mode 100644
index 57be328bf6..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cnaupd.f
+++ /dev/null
@@ -1,664 +0,0 @@
-c\BeginDoc
-c
-c\Name: cnaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This is intended to be used to find a few eigenpairs of a
-c  complex linear operator OP with respect to a semi-inner product defined
-c  by a hermitian positive semi-definite real matrix B. B may be the identity
-c  matrix.  NOTE: if both OP and B are real, then ssaupd or snaupd should
-c  be used.
-c
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  cnaupd is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M hermitian positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M hermitian semi-definite
-c           ===> OP =  inv[A - sigma*M]*M   and  B = M.
-c           ===> shift-and-invert mode
-c           If OP*x = amu*x, then lambda = sigma + 1/amu.
-c
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call cnaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to cnaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          cnaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = M * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute and return the shifts in the first
-c                    NP locations of WORKL.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          After the initialization phase, when the routine is used in
-c          the "shift-and-invert" mode, the vector M * X is already
-c          available and does not need to be recomputed in forming OP*X.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Real   scalar.  (INPUT)
-c          Stopping criteria: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = slamch('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine slamch).
-c
-c  RESID   Complex  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 1 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x. (See remark 4 below.)
-c
-c  V       Complex  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to filter out
-c          the components of the unwanted eigenvector.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are to be provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the Hessenberg matrix H are returned in the part
-c                      of WORKL array corresponding to RITZ.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration from the beginning
-c                      after updating the starting vector with a linear
-c                      combination of Ritz vectors associated with the
-c                      "wanted" eigenvalues.
-c          ISHIFT = 2: other choice of internal shift to be defined.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3; See under \Description of cnaupd for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), _naupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP < NCV-NEV.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg
-c                    matrix H in WORKL.
-c          IPNTR(6): pointer to the  ritz value array  RITZ
-c          IPNTR(7): pointer to the (projected) ritz vector array Q
-c          IPNTR(8): pointer to the error BOUNDS array in WORKL.
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by cneupd. See Remark 2 below.
-c
-c          IPNTR(9): pointer to the NCV RITZ values of the
-c                    original system.
-c          IPNTR(10): Not Used
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     cneupd if RVEC = .TRUE. See Remark 2 below.
-c
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note below.
-c
-c  WORKL   Complex  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 5*NCV.
-c
-c  RWORK   Real   work array of length NCV (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   User input error highly likely.  Please
-c                   check actual array dimensions and layout.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when using
-c     Mode = 3.  When operating in Mode = 3 setting WHICH = 'LM' will
-c     compute the NEV eigenvalues of the original problem that are
-c     closest to the shift SIGMA . After convergence, approximate eigenvalues
-c     of the original problem may be obtained with the ARPACK subroutine cneupd.
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call cneupd immediately following
-c     completion of cnaupd. This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 1.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) complex shifts in locations
-c     WORKL(IPNTR(14)), WORKL(IPNTR(14)+1), ... , WORKL(IPNTR(14)+NP).
-c     Eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are ordered
-c     according to the order defined by WHICH.  The associated Ritz estimates
-c     are located in WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... ,
-c     WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Complex  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Complex  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "_Complex_ Shift and Invert Strategies for
-c     _Real_ Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     cnaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     cstatn  ARPACK routine that initializes the timing variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     cvout   ARPACK utility routine that prints vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cnaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Complex
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-      Real
-     &           rwork(ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      parameter (one = (1.0E+0, 0.0E+0) , zero = (0.0E+0, 0.0E+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   cnaup2, cvout, ivout, arscnd, cstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call cstatn
-         call arscnd (t0)
-         msglvl = mcaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 5*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 3) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. 0.0E+0  )			tol = slamch('EpsMach')
-         if (ishift .ne. 0  .and.
-     &       ishift .ne. 1  .and.
-     &       ishift .ne. 2) 			ishift = 1
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 5*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values             |
-c        | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds        |
-c        | workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace       |
-c        | The final workspace is needed by subroutine cneigh called   |
-c        | by cnaup2. Subroutine cneigh calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + ldh*ncv
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = iq
-         ipntr(8) = bounds
-         ipntr(14) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call cnaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, rwork, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP.              |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within cnaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [mxiter], ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, [np], ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call cvout (logfil, np, workl(ritz), ndigit,
-     &               '_naupd: The final Ritz values')
-         call cvout (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tcaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tcaupd, tcaup2, tcaitr, titref,
-     &                  tgetv0, tceigh, tcgets, tcapps, tcconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Complex implicit Arnoldi update code      =',/
-     &      5x, '= Version Number: ', ' 2.3' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of cnaupd |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneigh.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneigh.f
deleted file mode 100644
index 2e2d4d7265..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneigh.f
+++ /dev/null
@@ -1,257 +0,0 @@
-c\BeginDoc
-c
-c\Name: cneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call cneigh
-c     ( RNORM, N, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, RWORK, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Complex N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex array of length N.  (OUTPUT)
-c          On output, RITZ(1:N) contains the eigenvalues of H.
-c
-c  BOUNDS  Complex array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues held in RITZ.  This is equal to RNORM
-c          times the last components of the eigenvectors corresponding
-c          to the eigenvalues in RITZ.
-c
-c  Q       Complex N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  RWORK   Real  work array of length N (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from clahqr or ctrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     svout   ARPACK utility routine that prints vectors.
-c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine to compute the Schur form of an
-c             upper Hessenberg matrix.
-c     claset  LAPACK matrix initialization routine.
-c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form
-c     ccopy   Level 1 BLAS that copies one vector to another.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cneigh (rnorm, n, h, ldh, ritz, bounds,
-     &                   q, ldq, workl, rwork, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           bounds(n), h(ldh,n), q(ldq,n), ritz(n),
-     &           workl(n*(n+3))
-      Real
-     &           rwork(n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      Real
-     &           rone
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0),
-     &           rone = 1.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    j,  msglvl
-      Complex
-     &           vl(1)
-      Real
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   clacpy, clahqr, ctrevc, ccopy,
-     &           csscal, cmout, cvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           scnrm2
-      external   scnrm2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mceigh
-c
-      if (msglvl .gt. 2) then
-          call cmout (logfil, n, n, h, ldh, ndigit,
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the   |
-c     |    corresponding Schur vectors and the full Schur form T |
-c     |    of the current upper Hessenberg matrix H.             |
-c     |    clahqr returns the full Schur form of H               |
-c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
-c     %----------------------------------------------------------%
-c
-      call clacpy ('All', n, n, h, ldh, workl, n)
-      call claset ('All', n, n, zero, one, q, ldq)
-      call clahqr (.true., .true., n, 1, n, workl, ldh, ritz,
-     &             1, n, q, ldq, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      call ccopy (n, q(n-1,1), ldq, bounds, 1)
-      if (msglvl .gt. 1) then
-         call cvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and |
-c     |    apply the Schur vectors to get the corresponding      |
-c     |    eigenvectors.                                         |
-c     %----------------------------------------------------------%
-c
-      call ctrevc ('Right', 'Back', select, n, workl, n, vl, n, q,
-     &             ldq, n, n, workl(n*n+1), rwork, ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | Euclidean norms are all one. LAPACK subroutine |
-c     | ctrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      do 10 j=1, n
-            temp = scnrm2( n, q(1,j), 1 )
-            call csscal ( n, rone / temp, q(1,j), 1 )
-   10 continue
-c
-      if (msglvl .gt. 1) then
-         call ccopy(n, q(n,1), ldq, workl, 1)
-         call cvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      call ccopy(n, q(n,1), n, bounds, 1)
-      call csscal(n, rnorm, bounds, 1)
-c
-      if (msglvl .gt. 2) then
-         call cvout (logfil, n, ritz, ndigit,
-     &              '_neigh: The eigenvalues of H')
-         call cvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd(t1)
-      tceigh = tceigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of cneigh |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneupd.f
deleted file mode 100644
index 29154ce37e..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cneupd.f
+++ /dev/null
@@ -1,876 +0,0 @@
-c\BeginDoc
-c
-c\Name: cneupd
-c
-c\Description:
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to CNAUPD.  CNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.   The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  The definition of OP as well as other terms and the relation of computed
-c  Ritz values and vectors of OP with respect to the given problem
-c  A*z = lambda*B*z may be found in the header of CNAUPD.  For a brief
-c  description, see definitions of IPARAM(7), MODE and WHICH in the
-c  documentation of CNAUPD.
-c
-c\Usage:
-c  call cneupd
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV, BMAT,
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD,
-c       WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the  Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE..
-c          If HOWMNY = 'A' or 'P', SELECT need not be initialized
-c          but it is used as internal workspace.
-c
-c  D       Complex array of dimension NEV+1.  (OUTPUT)
-c          On exit, D contains the  Ritz  approximations
-c          to the eigenvalues lambda for A*z = lambda*B*z.
-c
-c  Z       Complex N by NEV array    (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of
-c          Z represents approximate eigenvectors (Ritz vectors) corresponding
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          If RVEC = .FALSE. or HOWMNY = 'P', then Z is NOT REFERENCED.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by CNAUPD.  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ) is required.
-c          In any case,  LDZ .ge. 1 is required.
-c
-c  SIGMA   Complex  (INPUT)
-c          If IPARAM(7) = 3 then SIGMA represents the shift.
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  WORKEV  Complex work array of dimension 2*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to CNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, RWORK, INFO
-c
-c         must be passed directly to CNEUPD following the last call
-c         to CNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to CNAUPD and the call to CNEUPD.
-c
-c  Three of these parameters (V, WORKL and INFO) are also output parameters:
-c
-c  V       Complex N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by CNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Real work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+2*ncv) contains information obtained in
-c          cnaupd.  They are not changed by cneupd.
-c          WORKL(ncv*ncv+2*ncv+1:3*ncv*ncv+4*ncv) holds the
-c          untransformed Ritz values, the untransformed error estimates of
-c          the Ritz values, the upper triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by cneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): Not used
-c          IPNTR(11): pointer to the NCV corresponding error estimates.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     cneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine csheqr
-c                could not be reordered by LAPACK routine ctrsen.
-c                Re-enter subroutine cneupd with IPARAM(5)=NCV and
-c                increase the size of the array D to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation.
-c                This should never happened.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine ctrevc.
-c          = -10: IPARAM(7) must be 1,2,3
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: CNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: CNEUPD got a different count of the number of converged
-c                 Ritz values than CNAUPD got.  This indicates the user
-c                 probably made an error in passing data from CNAUPD to
-c                 CNEUPD or that the data was modified before entering
-c                 CNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B. Nour-Omid, B. N. Parlett, T. Ericsson and P. S. Jensen,
-c     "How to Implement the Spectral Transformation", Math Comp.,
-c     Vol. 48, No. 178, April, 1987 pp. 664-673.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     cmout   ARPACK utility routine that prints matrices
-c     cvout   ARPACK utility routine that prints vectors.
-c     cgeqr2  LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     clacpy  LAPACK matrix copy routine.
-c     clahqr  LAPACK routine that computes the Schur form of a
-c             upper Hessenberg matrix.
-c     claset  LAPACK matrix initialization routine.
-c     ctrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form.
-c     ctrsen  LAPACK routine that re-orders the Schur form.
-c     cunm2r  LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     slamch  LAPACK routine that determines machine constants.
-c     ctrmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     cgeru   Level 2 BLAS rank one update to a matrix.
-c     ccopy   Level 1 BLAS that copies one vector to another .
-c     cscal   Level 1 BLAS that scales a vector.
-c     csscal  Level 1 BLAS that scales a complex vector by a real number.
-c     scnrm2  Level 1 BLAS that computes the norm of a complex vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .true. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c       transpose( V(:,1:IPARAM(5)) ) * V(:,1:IPARAM(5)) = I
-c     are approximately satisfied.
-c     Here T is the leading submatrix of order IPARAM(5) of the
-c     upper triangular matrix stored workl(ipntr(12)).
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine cneupd(rvec , howmny, select, d     ,
-     &                   z    , ldz   , sigma , workev,
-     &                   bmat , n     , which , nev   ,
-     &                   tol  , resid , ncv   , v     ,
-     &                   ldv  , iparam, ipntr , workd ,
-     &                   workl, lworkl, rwork , info  )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Complex
-     &           sigma
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Real
-     &           rwork(ncv)
-      Complex
-     &           d(nev)     , resid(n)     , v(ldv,ncv),
-     &           z(ldz, nev),
-     &           workd(3*n) , workl(lworkl), workev(2*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      parameter  (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds, iheig , nconv ,
-     &           invsub, iuptri, iwev  , j    , ldh   , ldq   ,
-     &           mode  , msglvl, ritz  , wr   , k     , irz   ,
-     &           ibd   , outncv, iq    , np   , numcnv, jj    ,
-     &           ishift, nconv2
-      Complex
-     &           rnorm, temp, vl(1)
-      Real
-     &           conds, sep, rtemp, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ccopy , cgeru, cgeqr2, clacpy, cmout,
-     &           cunm2r, ctrmm, cvout, ivout,
-     &           clahqr
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           scnrm2, slamch, slapy2
-      external   scnrm2, slamch, slapy2
-c
-      Complex
-     &           ccdotc
-      external   ccdotc
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mceupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-c     %-------------------------------%
-c     | Quick return                  |
-c     | Check for incompatible input  |
-c     %-------------------------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 4*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, WORKEV, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values            |
-c     | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds     |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by CNEUPD.                 |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed |
-c     |                                      Ritz values.         |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                                      error bounds of      |
-c     |                                      the Ritz values      |
-c     | workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper |
-c     |                                      triangular matrix    |
-c     |                                      for H.               |
-c     | workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the    |
-c     |                                      associated matrix    |
-c     |                                      representation of    |
-c     |                                      the invariant        |
-c     |                                      subspace for H.      |
-c     | GRAND total of NCV * ( 3 * NCV + 4 ) locations.           |
-c     %-----------------------------------------------------------%
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      iq     = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheig  = bounds + ldh
-      ihbds  = iheig  + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheig
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wr = 1
-      iwev = wr + ncv
-c
-c     %-----------------------------------------%
-c     | irz points to the Ritz values computed  |
-c     |     by _neigh before exiting _naup2.    |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irz = ipntr(14) + ncv*ncv
-      ibd = irz + ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call cvout(logfil, ncv, workl(irz), ndigit,
-     &   '_neupd: Ritz values passed in from _NAUPD.')
-         call cvout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(ibd)       |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call cngets(ishift, which     , nev          ,
-     &                np    , workl(irz), workl(bounds))
-c
-         if (msglvl .gt. 2) then
-            call cvout (logfil, ncv, workl(irz), ndigit,
-     &      '_neupd: Ritz values after calling _NGETS.')
-            call cvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            rtemp = max(eps23,
-     &                 slapy2 ( real(workl(irz+ncv-j)),
-     &                          aimag(workl(irz+ncv-j)) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          slapy2( real(workl(ibd+jj-1)),
-     &          aimag(workl(ibd+jj-1)) )
-     &          .le. tol*rtemp) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nconv) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, [numcnv], ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, [nconv], ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-------------------------------------------------------%
-c        | Call LAPACK routine clahqr to compute the Schur form |
-c        | of the upper Hessenberg matrix returned by CNAUPD.   |
-c        | Make a copy of the upper Hessenberg matrix.           |
-c        | Initialize the Schur vector matrix Q to the identity. |
-c        %-------------------------------------------------------%
-c
-         call ccopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call claset('All', ncv, ncv          ,
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call clahqr(.true., .true.       , ncv          ,
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheig) , 1            ,
-     &                ncv   , workl(invsub), ldq          ,
-     &                ierr)
-         call ccopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call cvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H')
-            call cvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call cmout (logfil       , ncv, ncv   ,
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------%
-c           | Reorder the computed upper triangular matrix. |
-c           %-----------------------------------------------%
-c
-            call ctrsen('None'       , 'V'          , select      ,
-     &                   ncv          , workl(iuptri), ldh         ,
-     &                   workl(invsub), ldq          , workl(iheig),
-     &                   nconv2       , conds        , sep         ,
-     &                   workev       , ncv          , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call cvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call cmout(logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &              '_neupd: Triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------------%
-c        | Copy the last row of the Schur basis matrix |
-c        | to workl(ihbds).  This vector will be used  |
-c        | to compute the Ritz estimates of converged  |
-c        | Ritz values.                                |
-c        %---------------------------------------------%
-c
-         call ccopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-c        %--------------------------------------------%
-c        | Place the computed eigenvalues of H into D |
-c        | if a spectral transformation was not used. |
-c        %--------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call ccopy(nconv, workl(iheig), 1, d, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call cgeqr2(ncv , nconv , workl(invsub),
-     &                ldq , workev, workev(ncv+1),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q using cunm2r.                    |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | * Postmultiply Z by R.                                 |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(iheig). The first NCONV       |
-c        | columns of V are now approximate Schur vectors         |
-c        | associated with the upper triangular matrix of order   |
-c        | NCONV in workl(iuptri).                                |
-c        %--------------------------------------------------------%
-c
-         call cunm2r('Right', 'Notranspose', n            ,
-     &                ncv    , nconv        , workl(invsub),
-     &                ldq    , workev       , v            ,
-     &                ldv    , workd(n+1)   , ierr)
-         call clacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | triangular form of workl(iuptri,ldq).             |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones.          |
-c           %---------------------------------------------------%
-c
-            if ( real( workl(invsub+(j-1)*ldq+j-1) ) .lt.
-     &                  real(zero) ) then
-               call cscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call cscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call ctrevc('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , rwork        , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | ctrevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1.                                   |
-c           %------------------------------------------------%
-c
-            do 40 j=1, nconv
-                  rtemp = scnrm2(ncv, workl(invsub+(j-1)*ldq), 1)
-                  rtemp = real(one) / rtemp
-                  call csscal ( ncv, rtemp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-c                 %------------------------------------------%
-c                 | Ritz estimates can be obtained by taking |
-c                 | the inner product of the last row of the |
-c                 | Schur basis of H with eigenvectors of T. |
-c                 | Note that the eigenvector matrix of T is |
-c                 | upper triangular, thus the length of the |
-c                 | inner product can be set to j.           |
-c                 %------------------------------------------%
-c
-                  workev(j) = ccdotc(j, workl(ihbds), 1,
-     &                        workl(invsub+(j-1)*ldq), 1)
- 40         continue
-c
-            if (msglvl .gt. 2) then
-               call ccopy(nconv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &            '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call cmout(logfil       , ncv, ncv   ,
-     &                        workl(invsub), ldq, ndigit,
-     &               '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call ccopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %----------------------------------------------%
-c           | The eigenvector matrix Q of T is triangular. |
-c           | Form Z*Q.                                    |
-c           %----------------------------------------------%
-c
-            call ctrmm('Right'   , 'Upper'      , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-         end if
-c
-      else
-c
-c        %--------------------------------------------------%
-c        | An approximate invariant subspace is not needed. |
-c        | Place the Ritz values computed CNAUPD into D.    |
-c        %--------------------------------------------------%
-c
-         call ccopy(nconv, workl(ritz), 1, d, 1)
-         call ccopy(nconv, workl(ritz), 1, workl(iheig), 1)
-         call ccopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec)
-     &      call cscal(ncv, rnorm, workl(ihbds), 1)
-c
-      else
-c
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (rvec)
-     &      call cscal(ncv, rnorm, workl(ihbds), 1)
-c
-         do 50 k=1, ncv
-            temp = workl(iheig+k-1)
-            workl(ihbds+k-1) = workl(ihbds+k-1) / temp / temp
-  50     continue
-c
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | *  Transform the Ritz values back to the original system. |
-c     |    For TYPE = 'SHIFTI' the transformation is              |
-c     |             lambda = 1/theta + sigma                      |
-c     | NOTES:                                                    |
-c     | *The Ritz vectors are not affected by the transformation. |
-c     %-----------------------------------------------------------%
-c
-      if (type .eq. 'SHIFTI') then
-         do 60 k=1, nconv
-            d(k) = one / workl(iheig+k-1) + sigma
-  60     continue
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call cvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Untransformed Ritz values.')
-         call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Ritz estimates of the untransformed Ritz values.')
-      else if ( msglvl .gt. 1) then
-         call cvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Converged Ritz values.')
-         call cvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3. See reference 3.                  |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta.                           |
-c        %------------------------------------------------%
-c
-         do 100 j=1, nconv
-            if (workl(iheig+j-1) .ne. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheig+j-1)
-            endif
- 100     continue
-
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call cgeru (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of cneupd|
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cngets.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cngets.f
deleted file mode 100644
index 20626a2d50..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cngets.f
+++ /dev/null
@@ -1,178 +0,0 @@
-c\BeginDoc
-c
-c\Name: cngets
-c
-c\Description:
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call cngets
-c      ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest REAL part.
-c          'SR' -> want the KEV eigenvalues of smallest REAL part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV     Integer.  (INPUT)
-c          The number of desired eigenvalues.
-c
-c  NP      Integer.  (INPUT)
-c          The number of shifts to compute.
-c
-c  RITZ    Complex array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are
-c          selected, the unwanted part corresponds to the shifts to
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Complex array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex
-c
-c\Routines called:
-c     csortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     cvout   ARPACK utility routine that prints vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. This routine does not keep complex conjugate pairs of
-c        eigenvalues together.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine cngets ( ishift, which, kev, np, ritz, bounds)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           bounds(kev+np), ritz(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex
-     &           one, zero
-      parameter (one = (1.0E+0, 0.0E+0), zero = (0.0E+0, 0.0E+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   cvout,  csortc, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcgets
-c
-      call csortc (which, .true., kev+np, ritz, bounds)
-c
-      if ( ishift .eq. 1 ) then
-c
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine cnapps.                     |
-c        | Be careful and use 'SM' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c
-         call csortc ( 'SM', .true., np, bounds, ritz )
-c
-      end if
-c
-      call arscnd (t1)
-      tcgets = tcgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
-         call cvout (logfil, kev+np, ritz, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix ')
-         call cvout (logfil, kev+np, bounds, ndigit,
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c
-      return
-c
-c     %---------------%
-c     | End of cngets |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/csortc.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/csortc.f
deleted file mode 100644
index a02bd3ffad..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/csortc.f
+++ /dev/null
@@ -1,322 +0,0 @@
-c\BeginDoc
-c
-c\Name: csortc
-c
-c\Description:
-c  Sorts the Complex array in X into the order
-c  specified by WHICH and optionally applies the permutation to the
-c  Real  array Y.
-c
-c\Usage:
-c  call csortc
-c     ( WHICH, APPLY, N, X, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort X into increasing order of magnitude.
-c          'SM' -> sort X into decreasing order of magnitude.
-c          'LR' -> sort X with real(X) in increasing algebraic order
-c          'SR' -> sort X with real(X) in decreasing algebraic order
-c          'LI' -> sort X with imag(X) in increasing algebraic order
-c          'SI' -> sort X with imag(X) in decreasing algebraic order
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X       Complex array of length N.  (INPUT/OUTPUT)
-c          This is the array to be sorted.
-c
-c  Y       Complex array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c     Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine csortc (which, apply, n, x, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex
-     &           x(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Complex
-     &           temp
-      Real
-     &           temp1, temp2
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2
-c
-c     %--------------------%
-c     | Intrinsic Functions |
-c     %--------------------%
-       Intrinsic
-     &           real, aimag
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'LM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into increasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = slapy2(real(x(j)),aimag(x(j)))
-            temp2 = slapy2(real(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.gt.temp2) then
-                temp = x(j)
-                x(j) = x(j+igap)
-                x(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into decreasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = slapy2(real(x(j)),aimag(x(j)))
-            temp2 = slapy2(real(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.lt.temp2) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (real(x(j)).gt.real(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (real(x(j)).lt.real(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c
-      else if (which .eq. 'LI') then
-c
-c        %--------------------------------------------%
-c        | Sort XIMAG into increasing algebraic order |
-c        %--------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (aimag(x(j)).gt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c
-      else if (which .eq. 'SI') then
-c
-c        %---------------------------------------------%
-c        | Sort XIMAG into decreasing algebraic order  |
-c        %---------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (aimag(x(j)).lt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of csortc |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cstatn.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cstatn.f
deleted file mode 100644
index 02f75e0b26..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/cstatn.f
+++ /dev/null
@@ -1,51 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for complex nonsymmetric Arnoldi code.      |
-c     %---------------------------------------------%
-
-      subroutine cstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-
-      tcaupd = 0.0E+0
-      tcaup2 = 0.0E+0
-      tcaitr = 0.0E+0
-      tceigh = 0.0E+0
-      tcgets = 0.0E+0
-      tcapps = 0.0E+0
-      tcconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
-
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
-
-      return
-c
-c     %---------------%
-c     | End of cstatn |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/debug.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/debug.h
deleted file mode 100644
index 81a6efafb9..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/debug.h
+++ /dev/null
@@ -1,16 +0,0 @@
-
-c\SCCS Information: @(#) 
-c FILE: debug.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-c     %---------------------------------%
-c     | See debug.doc for documentation |
-c     %---------------------------------%
-c      integer  logfil, ndigit, mgetv0,
-c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
-c      common /debug/
-c     &         logfil, ndigit, mgetv0,
-c     &         msaupd, msaup2, msaitr, mseigt, msapps, msgets, mseupd,
-c     &         mnaupd, mnaup2, mnaitr, mneigh, mnapps, mngets, mneupd,
-c     &         mcaupd, mcaup2, mcaitr, mceigh, mcapps, mcgets, mceupd
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dgetv0.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dgetv0.f
deleted file mode 100644
index 1d6dc01bdb..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dgetv0.f
+++ /dev/null
@@ -1,421 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dgetv0
-c
-c\Description:
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.
-c
-c\Usage:
-c  call dgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM,
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that dgetv0 is called.
-c          It should be set to 1 on the initial call to dgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Double precision N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Double precision scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Double precision work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine for vector output.
-c     dlarnv  LAPACK routine for generating a random vector.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.7   DATE OF SID: 04/07/99   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dgetv0
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm,
-     &     ipntr, workd, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Double precision
-     &           rnorm0
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dlarnv, dvout, dcopy, dgemv, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2
-      external   ddot, dnrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call dlarnv (idist, iseed, n, resid)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (itry .eq. 1) then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call dcopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         else if (itry .gt. 1 .and. bmat .eq. 'G') then
-            call dcopy (n, resid, 1, workd(n + 1), 1)
-         end if
-      end if
-c
-c     %-----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %-----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing OP*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-      end if
-c
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (itry .eq. 1) call dcopy (n, workd(n + 1), 1, resid, 1)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call dcopy (n, resid, 1, workd, 1)
-      end if
-c
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          rnorm0 = ddot (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(abs(rnorm0))
-      else if (bmat .eq. 'I') then
-           rnorm0 = dnrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call dgemv ('T', n, j-1, one, v, ldv, workd, 1,
-     &            zero, workd(n+1), 1)
-      call dgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1,
-     &            one, resid, 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call dcopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call dcopy (n, resid, 1, workd, 1)
-      end if
-c
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      if (bmat .eq. 'G') then
-         rnorm = ddot (n, resid, 1, workd, 1)
-         rnorm = sqrt(abs(rnorm))
-      else if (bmat .eq. 'I') then
-         rnorm = dnrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call dvout (logfil, 1, [rnorm0], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, [rnorm], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c
-      iter = iter + 1
-      if (iter .le. 5) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = zero
-         ierr = -1
-      end if
-c
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, 1, [rnorm], ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 3) then
-         call dvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dgetv0 |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaitr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaitr.f
deleted file mode 100644
index c02cd39092..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaitr.f
+++ /dev/null
@@ -1,840 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnaitr
-c
-c\Description:
-c  Reverse communication interface for applying NP additional steps to
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in dnaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call dnaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recompute in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See dnaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.
-c          Only work for NB = 1 right now.  The goal is to have a
-c          program that implement both the block and non-block method.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Double precision N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     dgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k};
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in dnaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh,
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Double precision
-     &           betaj, ovfl, temp1, rnorm1, smlnum, tst1, ulp, unfl,
-     &           wnorm
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments |
-c     %-----------------------%
-c
-      Double precision
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dgemv, dgetv0, dlabad,
-     &           dvout, dmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlanhs, dlamch
-      external   ddot, dnrm2, dlanhs, dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine dlahqr     |
-c        %-----------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = one / unfl
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mnaitr
-c
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         dgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [j], ndigit,
-     &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, [rnorm], ndigit,
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determining whether |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [j], ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            betaj  = zero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call dgetv0 (ido, bmat, itry, .false., n, j, v, ldv,
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tnaitr = tnaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call dcopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. unfl) then
-             temp1 = one / rnorm
-             call dscal (n, temp1, v(1,j), 1)
-             call dscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call dlascl ('General', i, i, rnorm, one, n, 1,
-     &                    v(1,j), n, infol)
-             call dlascl ('General', i, i, rnorm, one, n, 1,
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call dcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c
-         go to 9000
-   50    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call dcopy (n, workd(irj), 1, resid, 1)
-c
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             wnorm = ddot (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. |
-c        %--------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = betaj
-c
-         call arscnd (t4)
-c
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then
-            rnorm = ddot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         iter  = 0
-         nrorth = nrorth + 1
-c
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call dvout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: re-orthonalization; wnorm and rnorm are')
-            call dvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, workd(irj), 1,
-     &               one, resid, 1)
-         call daxpy (j, one, workd(irj), 1, h(1,j), 1)
-c
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             rnorm1 = ddot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = dnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, [j], ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call dvout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c
-         rstart = .false.
-         orth2  = .false.
-c
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tnaitr = tnaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine dlahqr        |
-c              %--------------------------------------------%
-c
-               tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-               if( tst1.eq.zero )
-     &              tst1 = dlanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) )
-     &              h(i+1,i) = zero
- 110        continue
-c
-            if (msglvl .gt. 2) then
-               call dmout (logfil, k+np, k+np, h, ldh, ndigit,
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dnaitr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnapps.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnapps.f
deleted file mode 100644
index 1cf3725696..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnapps.f
+++ /dev/null
@@ -1,649 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call dnapps
-c     ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ,
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.  KEV is only
-c          updated on output when fewer than NP shifts are applied in
-c          order to keep the conjugate pair together.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFTR, Double precision array of length NP.  (INPUT)
-c  SHIFTI  Real and imaginary part of the shifts to be applied.
-c          Upon, entry to dnapps, the shifts must be sorted so that the
-c          conjugate pairs are in consecutive locations.
-c
-c  V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper
-c          Hessenber matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k}
-c          in the first KEV locations.
-c
-c  Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Double precision work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlabad  LAPACK routine that computes machine constants.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlanhs  LAPACK routine that computes various norms of a matrix.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlarf   LAPACK routine that applies Householder reflection to
-c             a matrix.
-c     dlarfg  LAPACK Householder reflection construction routine.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlaset  LAPACK matrix initialization routine.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.4   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine dlahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     The subdiagonals of H are enforced to be non-negative.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnapps
-     &   ( n, kev, np, shiftr, shifti, v, ldv, h, ldh, resid, q, ldq,
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h(ldh,kev+np), resid(n), shifti(np), shiftr(np),
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, ir, istart, j, jj, kplusp, msglvl, nr
-      logical    cconj, first
-      Double precision
-     &           c, f, g, h11, h12, h21, h22, h32, ovfl, r, s, sigmai,
-     &           sigmar, smlnum, ulp, unfl, u(3), t, tau, tst1
-      save       first, ovfl, smlnum, ulp, unfl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dlacpy, dlarfg, dlarf,
-     &           dlaset, dlabad, arscnd, dlartg
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch, dlanhs, dlapy2
-      external   dlamch, dlanhs, dlapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, max, min
-c
-c     %----------------%
-c     | Data statements |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine dlahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = one / unfl
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mnapps
-      kplusp = kev + np
-c
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call dlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      cconj = .false.
-      do 110 jj = 1, np
-         sigmar = shiftr(jj)
-         sigmai = shifti(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, [jj], ndigit,
-     &               '_napps: shift number.')
-            call dvout (logfil, 1, [sigmar], ndigit,
-     &               '_napps: The real part of the shift ')
-            call dvout (logfil, 1, [sigmai], ndigit,
-     &               '_napps: The imaginary part of the shift ')
-         end if
-c
-c        %-------------------------------------------------%
-c        | The following set of conditionals is necessary  |
-c        | in order that complex conjugate pairs of shifts |
-c        | are applied together or not at all.             |
-c        %-------------------------------------------------%
-c
-         if ( cconj ) then
-c
-c           %-----------------------------------------%
-c           | cconj = .true. means the previous shift |
-c           | had non-zero imaginary part.            |
-c           %-----------------------------------------%
-c
-            cconj = .false.
-            go to 110
-         else if ( jj .lt. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %------------------------------------%
-c           | Start of a complex conjugate pair. |
-c           %------------------------------------%
-c
-            cconj = .true.
-         else if ( jj .eq. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %----------------------------------------------%
-c           | The last shift has a nonzero imaginary part. |
-c           | Don't apply it; thus the order of the        |
-c           | compressed H is order KEV+1 since only np-1  |
-c           | were applied.                                |
-c           %----------------------------------------------%
-c
-            kev = kev + 1
-            go to 110
-         end if
-         istart = 1
-   20    continue
-c
-c        %--------------------------------------------------%
-c        | if sigmai = 0 then                               |
-c        |    Apply the jj-th shift ...                     |
-c        | else                                             |
-c        |    Apply the jj-th and (jj+1)-th together ...    |
-c        |    (Note that jj < np at this point in the code) |
-c        | end                                              |
-c        | to the current block of H. The next do loop      |
-c        | determines the current block ;                   |
-c        %--------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine dlahqr    |
-c           %----------------------------------------%
-c
-            tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-            if( tst1.eq.zero )
-     &         tst1 = dlanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, [i], ndigit,
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, [jj], ndigit,
-     &                 '_napps: matrix splitting with shift number.')
-                  call dvout (logfil, 1, h(i+1,i), ndigit,
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, [istart], ndigit,
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, [iend], ndigit,
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend ) go to 100
-c
-c        %------------------------------------------------------%
-c        | If istart + 1 = iend then no reason to apply a       |
-c        | complex conjugate pair of shifts on a 2 by 2 matrix. |
-c        %------------------------------------------------------%
-c
-         if ( istart + 1 .eq. iend .and. abs( sigmai ) .gt. zero )
-     &      go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         if ( abs( sigmai ) .le. zero ) then
-c
-c           %---------------------------------------------%
-c           | Real-valued shift ==> apply single shift QR |
-c           %---------------------------------------------%
-c
-            f = h11 - sigmar
-            g = h21
-c
-            do 80 i = istart, iend-1
-c
-c              %-----------------------------------------------------%
-c              | Construct the plane rotation G to zero out the bulge |
-c              %-----------------------------------------------------%
-c
-               call dlartg (f, g, c, s, r)
-               if (i .gt. istart) then
-c
-c                 %-------------------------------------------%
-c                 | The following ensures that h(1:iend-1,1), |
-c                 | the first iend-2 off diagonal of elements |
-c                 | H, remain non negative.                   |
-c                 %-------------------------------------------%
-c
-                  if (r .lt. zero) then
-                     r = -r
-                     c = -c
-                     s = -s
-                  end if
-                  h(i,i-1) = r
-                  h(i+1,i-1) = zero
-               end if
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the left of H;  H <- G'*H |
-c              %---------------------------------------------%
-c
-               do 50 j = i, kplusp
-                  t        =  c*h(i,j) + s*h(i+1,j)
-                  h(i+1,j) = -s*h(i,j) + c*h(i+1,j)
-                  h(i,j)   = t
-   50          continue
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the right of H;  H <- H*G |
-c              %---------------------------------------------%
-c
-               do 60 j = 1, min(i+2,iend)
-                  t        =  c*h(j,i) + s*h(j,i+1)
-                  h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-                  h(j,i)   = t
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c              %----------------------------------------------------%
-c
-               do 70 j = 1, min( i+jj, kplusp )
-                  t        =   c*q(j,i) + s*q(j,i+1)
-                  q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                  q(j,i)   = t
-   70          continue
-c
-c              %---------------------------%
-c              | Prepare for next rotation |
-c              %---------------------------%
-c
-               if (i .lt. iend-1) then
-                  f = h(i+1,i)
-                  g = h(i+2,i)
-               end if
-   80       continue
-c
-c           %-----------------------------------%
-c           | Finished applying the real shift. |
-c           %-----------------------------------%
-c
-         else
-c
-c           %----------------------------------------------------%
-c           | Complex conjugate shifts ==> apply double shift QR |
-c           %----------------------------------------------------%
-c
-            h12 = h(istart,istart+1)
-            h22 = h(istart+1,istart+1)
-            h32 = h(istart+2,istart+1)
-c
-c           %---------------------------------------------------------%
-c           | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |
-c           %---------------------------------------------------------%
-c
-            s    = 2.0*sigmar
-            t = dlapy2 ( sigmar, sigmai )
-            u(1) = ( h11 * (h11 - s) + t * t ) / h21 + h12
-            u(2) = h11 + h22 - s
-            u(3) = h32
-c
-            do 90 i = istart, iend-1
-c
-               nr = min ( 3, iend-i+1 )
-c
-c              %-----------------------------------------------------%
-c              | Construct Householder reflector G to zero out u(1). |
-c              | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |
-c              %-----------------------------------------------------%
-c
-               call dlarfg ( nr, u(1), u(2), 1, tau )
-c
-               if (i .gt. istart) then
-                  h(i,i-1)   = u(1)
-                  h(i+1,i-1) = zero
-                  if (i .lt. iend-1) h(i+2,i-1) = zero
-               end if
-               u(1) = one
-c
-c              %--------------------------------------%
-c              | Apply the reflector to the left of H |
-c              %--------------------------------------%
-c
-               call dlarf ('Left', nr, kplusp-i+1, u, 1, tau,
-     &                     h(i,i), ldh, workl)
-c
-c              %---------------------------------------%
-c              | Apply the reflector to the right of H |
-c              %---------------------------------------%
-c
-               ir = min ( i+3, iend )
-               call dlarf ('Right', ir, nr, u, 1, tau,
-     &                     h(1,i), ldh, workl)
-c
-c              %-----------------------------------------------------%
-c              | Accumulate the reflector in the matrix Q;  Q <- Q*G |
-c              %-----------------------------------------------------%
-c
-               call dlarf ('Right', kplusp, nr, u, 1, tau,
-     &                     q(1,i), ldq, workl)
-c
-c              %----------------------------%
-c              | Prepare for next reflector |
-c              %----------------------------%
-c
-               if (i .lt. iend-1) then
-                  u(1) = h(i+1,i)
-                  u(2) = h(i+2,i)
-                  if (i .lt. iend-2) u(3) = h(i+3,i)
-               end if
-c
-   90       continue
-c
-c           %--------------------------------------------%
-c           | Finished applying a complex pair of shifts |
-c           | to the current block                       |
-c           %--------------------------------------------%
-c
-         end if
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %--------------------------------------------------%
-c     | Perform a similarity transformation that makes   |
-c     | sure that H will have non negative sub diagonals |
-c     %--------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( h(j+1,j) .lt. zero ) then
-              call dscal( kplusp-j+1, -one, h(j+1,j), ldh )
-              call dscal( min(j+2, kplusp), -one, h(1,j+1), 1 )
-              call dscal( min(j+np+1,kplusp), -one, q(1,j+1), 1 )
-         end if
- 120  continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine dlahqr        |
-c        %--------------------------------------------%
-c
-         tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-         if( tst1.eq.zero )
-     &       tst1 = dlanhs( '1', kev, h, ldh, workl )
-         if( h( i+1,i ) .le. max( ulp*tst1, smlnum ) )
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &    call dgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero,
-     &                workd(n+1), 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call dgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call dcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      do 150 i = 1, kev
-         call dcopy(n, v(1,kplusp-kev+i), 1, v(1,i), 1)
-  150 continue
-c
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &   call dcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kplusp}'*Q)*e_{kev} |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call dscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,kev) .gt. zero)
-     &   call daxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call dvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, [kev], ndigit,
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call dmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tnapps = tnapps + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of dnapps |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaup2.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaup2.f
deleted file mode 100644
index 86375a6469..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaup2.f
+++ /dev/null
@@ -1,846 +0,0 @@
-c\BeginDoc
-c
-c\Name: dnaup2
-c
-c\Description:
-c  Intermediate level interface called by dnaupd .
-c
-c\Usage:
-c  call dnaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dnaupd .
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in dnaupd .
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse communication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV for two reasons. The first, is
-c          to keep complex conjugate pairs of "wanted" Ritz values
-c          together. The second, is that a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Double precision  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Double precision  arrays of length NEV+NP.  (OUTPUT)
-c  RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.
-c          imaginary) part of the computed Ritz values of OP.
-c
-c  BOUNDS  Double precision  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Double precision  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c          On exit, the last 3*(NEV+NP) locations of WORKL contain
-c          the Ritz values (real,imaginary) and associated Ritz
-c          estimates of the current Hessenberg matrix.  They are
-c          listed in the same order as returned from dneigh .
-c
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in DNAUPD.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     dgetv0   ARPACK initial vector generation routine.
-c     dnaitr   ARPACK Arnoldi factorization routine.
-c     dnapps   ARPACK application of implicit shifts routine.
-c     dnconv   ARPACK convergence of Ritz values routine.
-c     dneigh   ARPACK compute Ritz values and error bounds routine.
-c     dngets   ARPACK reorder Ritz values and error bounds routine.
-c     dsortc   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout    ARPACK utility routine that prints matrices
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     ddot     Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dswap    Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.8   DATE OF SID: 10/17/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritzr, ritzi, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Double precision
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), resid(n),
-     &           ritzi(nev+np), ritzr(nev+np), v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm , getv0, initv, update, ushift
-      integer    ierr  , iter , j    , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0  , nptemp, numcnv
-      Double precision
-     &           rnorm , temp , eps23
-      save       cnorm , getv0, initv, update, ushift,
-     &           rnorm , iter , eps23, kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0  , numcnv
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(4)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dgetv0 , dnaitr , dnconv , dneigh ,
-     &           dngets , dnapps , dvout  , ivout , arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot , dnrm2 , dlapy2 , dlamch
-      external   ddot , dnrm2 , dlapy2 , dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min, max, abs, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mnaup2
-c
-c        %-------------------------------------%
-c        | Get the machine dependent constant. |
-c        %-------------------------------------%
-c
-         eps23 = dlamch ('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call dgetv0  (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call dnaitr  (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [iter], ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine dnapps .                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [nev], ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, [np], ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call dnaitr  (ido  , bmat, n  , nev, np , mode , resid,
-     &                rnorm, v   , ldv, h  , ldh, ipntr, workd,
-     &                info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, [rnorm], ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call dneigh  (rnorm, kplusp, h, ldh, ritzr, ritzi, bounds,
-     &                q, ldq, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from dneigh .                       |
-c        %----------------------------------------------------%
-c
-         call dcopy (kplusp, ritzr, 1, workl(kplusp**2+1), 1)
-         call dcopy (kplusp, ritzi, 1, workl(kplusp**2+kplusp+1), 1)
-         call dcopy (kplusp, bounds, 1, workl(kplusp**2+2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZR,   |
-c        | RITZI and BOUNDS respectively. The variables NEV  |
-c        | and NP may be updated if the NEV-th wanted Ritz   |
-c        | value has a non zero imaginary part. In this case |
-c        | NEV is increased by one and NP decreased by one.  |
-c        | NOTE: The last two arguments of dngets  are no     |
-c        | longer used as of version 2.1.                    |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         numcnv = nev
-         call dngets  (ishift, which, nev, np, ritzr, ritzi,
-     &                bounds, workl, workl(np+1))
-         if (nev .eq. nev0+1) numcnv = nev0+1
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call dcopy  (nev, bounds(np+1), 1, workl(2*np+1), 1)
-         call dnconv  (nev, ritzr(np+1), ritzi(np+1), workl(2*np+1),
-     &        tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = numcnv
-            kp(4) = nconv
-            call ivout (logfil, 4, kp, ndigit,
-     &                  '_naup2: NEV, NP, NUMCNV, NCONV are')
-            call dvout  (logfil, kplusp, ritzr, ndigit,
-     &           '_naup2: Real part of the eigenvalues of H')
-            call dvout  (logfil, kplusp, ritzi, ndigit,
-     &           '_naup2: Imaginary part of the eigenvalues of H')
-            call dvout  (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. numcnv) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call dvout (logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Real part of the eig computed by _neigh:')
-               call dvout (logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Imag part of the eig computed by _neigh:')
-               call dvout (logfil, kplusp, workl(kplusp**2+kplusp*2+1),
-     &                     ndigit,
-     &             '_naup2: Ritz eistmates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to _neupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = rnorm
-c
-c           %----------------------------------------------%
-c           | To be consistent with dngets , we first do a  |
-c           | pre-processing sort in order to keep complex |
-c           | conjugate pairs together.  This is similar   |
-c           | to the pre-processing sort used in dngets     |
-c           | except that the sort is done in the opposite |
-c           | order.                                       |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SR'
-            if (which .eq. 'SM') wprime = 'LR'
-            if (which .eq. 'LR') wprime = 'SM'
-            if (which .eq. 'SR') wprime = 'LM'
-            if (which .eq. 'LI') wprime = 'SM'
-            if (which .eq. 'SI') wprime = 'LM'
-c
-            call dsortc  (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %----------------------------------------------%
-c           | Now sort Ritz values so that converged Ritz  |
-c           | values appear within the first NEV locations |
-c           | of ritzr, ritzi and bounds, and the most     |
-c           | desired one appears at the front.            |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call dsortc (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, numcnv
-                temp = max(eps23,dlapy2 (ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | estimates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LR'
-            call dsortc (wprime, .true., numcnv, bounds, ritzr, ritzi)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, numcnv
-                temp = max(eps23, dlapy2 (ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %------------------------------------------------%
-c           | Sort the converged Ritz values again so that   |
-c           | the "threshold" value appears at the front of  |
-c           | ritzr, ritzi and bound.                        |
-c           %------------------------------------------------%
-c
-            call dsortc (which, .true., nconv, ritzr, ritzi, bounds)
-c
-            if (msglvl .gt. 1) then
-               call dvout  (logfil, kplusp, ritzr, ndigit,
-     &            '_naup2: Sorted real part of the eigenvalues')
-               call dvout  (logfil, kplusp, ritzi, ndigit,
-     &            '_naup2: Sorted imaginary part of the eigenvalues')
-               call dvout  (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. numcnv) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. numcnv) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. numcnv) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-c           %---- Scipy fix ------------------------------------------------
-c           | We must keep nev below this value, as otherwise we can get
-c           | np == 0 (note that dngets below can bump nev by 1). If np == 0,
-c           | the next call to `dnaitr` will write out-of-bounds.
-c           |
-            if (nev .gt. kplusp - 2) then
-               nev = kplusp - 2
-            end if
-c           |
-c           %---- Scipy fix end --------------------------------------------
-c
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call dngets  (ishift, which, nev, np, ritzr, ritzi,
-     &              bounds, workl, workl(np+1))
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [nconv], ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call dvout  (logfil, nev, ritzr(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- real part')
-               call dvout  (logfil, nev, ritzi(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- imag part')
-               call dvout  (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: reverse communication to       |
-c           | compute the shifts. They are returned in the first    |
-c           | 2*NP locations of WORKL.                              |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:2*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-         if ( ishift .eq. 0 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZR, RITZI to free up WORKL    |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call dcopy  (np, workl,       1, ritzr, 1)
-             call dcopy  (np, workl(np+1), 1, ritzi, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [np], ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call dvout  (logfil, np, ritzr, ndigit,
-     &                  '_naup2: Real part of the shifts')
-            call dvout  (logfil, np, ritzi, ndigit,
-     &                  '_naup2: Imaginary part of the shifts')
-            if ( ishift .eq. 1 )
-     &          call dvout  (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call dnapps  (n, nev, np, ritzr, ritzi, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to dnaitr .  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy  (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy  (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = ddot  (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2 (n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, [rnorm], ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call dmout  (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = numcnv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tnaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of dnaup2  |
-c     %---------------%
-c
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaupd.f
deleted file mode 100644
index 0b4cbb0d84..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnaupd.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c\BeginDoc
-c
-c\Name: dnaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This subroutine computes approximations to a few eigenpairs
-c  of a linear operator "OP" with respect to a semi-inner product defined by
-c  a symmetric positive semi-definite real matrix B. B may be the identity
-c  matrix. NOTE: If the linear operator "OP" is real and symmetric
-c  with respect to the real positive semi-definite symmetric matrix B,
-c  i.e. B*OP = (OP`)*B, then subroutine dsaupd  should be used instead.
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  dnaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].
-c           Note: If sigma is real, i.e. imaginary part of sigma is zero;
-c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M
-c                 amu == 1/(lambda-sigma).
-c
-c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].
-c
-c  Both mode 3 and 4 give the same enhancement to eigenvalues close to
-c  the (complex) shift sigma.  However, as lambda goes to infinity,
-c  the operator OP in mode 4 dampens the eigenvalues more strongly than
-c  does OP defined in mode 3.
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call dnaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dnaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          dnaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3 and 4, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) real and imaginary parts
-c                    of the shifts where INPTR(14) is the pointer
-c                    into WORKL for placing the shifts. See Remark
-c                    5 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Double precision  scalar.  (INPUT/OUTPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = DLAMCH ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine DLAMCH ).
-c
-c  RESID   Double precision  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 2 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x.
-c          NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz
-c          values are kept together. (See remark 4 below)
-c
-c  V       Double precision  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The real and imaginary
-c                      parts of the NCV eigenvalues of the Hessenberg
-c                      matrix H are returned in the part of the WORKL
-c                      array corresponding to RITZR and RITZI. See remark
-c                      5 below.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of approximate Schur
-c                      vectors associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4; See under \Description of dnaupd  for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), dnaupd  returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          5 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix
-c                    H in WORKL.
-c          IPNTR(6): pointer to the real part of the ritz value array
-c                    RITZR in WORKL.
-c          IPNTR(7): pointer to the imaginary part of the ritz value array
-c                    RITZI in WORKL.
-c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZR and RITZI in WORKL.
-c
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by dneupd . See Remark 2 below.
-c
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     dneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace
-c          associated with the converged Ritz values is desired, see remark
-c          2 below, subroutine dneupd  uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 6*NCV.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when
-c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the
-c     original problem may be obtained with the ARPACK subroutine dneupd .
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call dneupd  immediately following
-c     completion of dnaupd . This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 2.
-c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) real and imaginary parts of the shifts in locations
-c         real part                  imaginary part
-c         -----------------------    --------------
-c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)
-c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)
-c                        .                          .
-c                        .                          .
-c                        .                          .
-c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).
-c
-c     Only complex conjugate pairs of shifts may be applied and the pairs
-c     must be placed in consecutive locations. The real part of the
-c     eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part
-c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered
-c     according to the order defined by WHICH. The complex conjugate
-c     pairs are kept together and the associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Double precision  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Double precision   resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     dnaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version '1.1'
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Double precision
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritzi, ritzr, j
-      save       bounds, ih, iq, ishift, iupd, iw, ldh, ldq,
-     &           levec, mode, msglvl, mxiter, nb, nev0, next,
-     &           np, ritzi, ritzr
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dnaup2 , dvout , ivout, arscnd, dstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call dstatn
-         call arscnd (t0)
-         msglvl = mnaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 4) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. zero)			tol = dlamch ('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 6*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |
-c        |                                   parts of ritz values      |
-c        | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |
-c        | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |
-c        | The final workspace is needed by subroutine dneigh  called   |
-c        | by dnaup2 . Subroutine dneigh  calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritzr  = ih     + ldh*ncv
-         ritzi  = ritzr  + ncv
-         bounds = ritzi  + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritzr
-         ipntr(7) = ritzi
-         ipntr(8) = bounds
-         ipntr(14) = iw
-c
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call dnaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritzr),
-     &     workl(ritzi), workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within dnaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [mxiter], ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, [np], ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call dvout  (logfil, np, workl(ritzr), ndigit,
-     &               '_naupd: Real part of the final Ritz values')
-         call dvout  (logfil, np, workl(ritzi), ndigit,
-     &               '_naupd: Imaginary part of the final Ritz values')
-         call dvout  (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tnaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tnaupd, tnaup2, tnaitr, titref,
-     &                  tgetv0, tneigh, tngets, tnapps, tnconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Nonsymmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number: ', ' 2.4' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dnaupd  |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnconv.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnconv.f
deleted file mode 100644
index 4d531f8651..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dnconv.f
+++ /dev/null
@@ -1,146 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dnconv
-c
-c\Description:
-c  Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call dnconv
-c     ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZR,  Double precision arrays of length N.  (INPUT)
-c  RITZI   Real and imaginary parts of the Ritz values to be checked
-c          for convergence.
-
-c  BOUNDS  Double precision array of length N.  (INPUT)
-c          Ritz estimates for the Ritz values in RITZR and RITZI.
-c
-c  TOL     Double precision scalar.  (INPUT)
-c          Desired backward error for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dnconv (n, ritzr, ritzi, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-
-      Double precision
-     &           ritzr(n), ritzi(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Double precision
-     &           temp, eps23
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2, dlamch
-      external   dlapy2, dlamch
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------------------------------------%
-c     | Convergence test: unlike in the symmetric code, I am not    |
-c     | using things like refined error bounds and gap condition    |
-c     | because I don't know the exact equivalent concept.          |
-c     |                                                             |
-c     | Instead the i-th Ritz value is considered "converged" when: |
-c     |                                                             |
-c     |     bounds(i) .le. ( TOL * | ritz | )                       |
-c     |                                                             |
-c     | for some appropriate choice of norm.                        |
-c     %-------------------------------------------------------------%
-c
-      call arscnd (t0)
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-      nconv  = 0
-      do 20 i = 1, n
-         temp = max( eps23, dlapy2( ritzr(i), ritzi(i) ) )
-         if (bounds(i) .le. tol*temp)   nconv = nconv + 1
-   20 continue
-c
-      call arscnd (t1)
-      tnconv = tnconv + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of dnconv |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneigh.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneigh.f
deleted file mode 100644
index 3c49e32bf0..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneigh.f
+++ /dev/null
@@ -1,318 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call dneigh
-c     ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Double precision N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Double precision arrays of length N.  (OUTPUT)
-c  RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real
-c          (respectively imaginary) parts of the eigenvalues of H.
-c
-c  BOUNDS  Double precision array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues RITZR and RITZI.  This is equal to RNORM
-c          times the last components of the eigenvectors corresponding
-c          to the eigenvalues in RITZR and RITZI.
-c
-c  Q       Double precision N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from dlahqr or dtrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dlahqr  LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix and last row of the Schur vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     dmout   ARPACK utility routine that prints matrices
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dtrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dneigh (rnorm, n, h, ldh, ritzr, ritzi, bounds,
-     &                   q, ldq, workl, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(n), h(ldh,n), q(ldq,n), ritzi(n), ritzr(n),
-     &           workl(n*(n+3))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    i, iconj, msglvl
-      Double precision
-     &           temp, vl(1)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dlacpy, dlahqr, dtrevc, dvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2, dnrm2
-      external   dlapy2, dnrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mneigh
-c
-      if (msglvl .gt. 2) then
-          call dmout (logfil, n, n, h, ldh, ndigit,
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the    |
-c     |    corresponding Schur vectors and the full Schur form T  |
-c     |    of the current upper Hessenberg matrix H.              |
-c     | dlahqr returns the full Schur form of H in WORKL(1:N**2)  |
-c     | and the last components of the Schur vectors in BOUNDS.   |
-c     %-----------------------------------------------------------%
-c
-      call dlacpy ('All', n, n, h, ldh, workl, n)
-      do 5 j = 1, n-1
-          bounds(j) = zero
-   5  continue
-      bounds(n) = 1
-      call dlahqr(.true., .true., n, 1, n, workl, n, ritzr, ritzi, 1, 1,
-     &            bounds, 1, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and  |
-c     |    apply the last components of the Schur vectors to get  |
-c     |    the last components of the corresponding eigenvectors. |
-c     | Remember that if the i-th and (i+1)-st eigenvalues are    |
-c     | complex conjugate pairs, then the real & imaginary part   |
-c     | of the eigenvector components are split across adjacent   |
-c     | columns of Q.                                             |
-c     %-----------------------------------------------------------%
-c
-      call dtrevc ('R', 'A', select, n, workl, n, vl, n, q, ldq,
-     &             n, n, workl(n*n+1), ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | euclidean norms are all one. LAPACK subroutine |
-c     | dtrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      iconj = 0
-      do 10 i=1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c
-            temp = dnrm2( n, q(1,i), 1 )
-            call dscal ( n, one / temp, q(1,i), 1 )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we further normalize by the      |
-c           | square root of two.                       |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               temp = dlapy2( dnrm2( n, q(1,i), 1 ),
-     &                        dnrm2( n, q(1,i+1), 1 ) )
-               call dscal ( n, one / temp, q(1,i), 1 )
-               call dscal ( n, one / temp, q(1,i+1), 1 )
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   10 continue
-c
-      call dgemv ('T', n, n, one, q, ldq, bounds, 1, zero, workl, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      iconj = 0
-      do 20 i = 1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c
-            bounds(i) = rnorm * abs( workl(i) )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we need to take the magnitude    |
-c           | of the last components of the two vectors |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               bounds(i) = rnorm * dlapy2( workl(i), workl(i+1) )
-               bounds(i+1) = bounds(i)
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   20 continue
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, n, ritzr, ndigit,
-     &              '_neigh: Real part of the eigenvalues of H')
-         call dvout (logfil, n, ritzi, ndigit,
-     &              '_neigh: Imaginary part of the eigenvalues of H')
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd (t1)
-      tneigh = tneigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dneigh |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneupd.f
deleted file mode 100644
index 860ceb856c..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dneupd.f
+++ /dev/null
@@ -1,1071 +0,0 @@
-c\BeginDoc
-c
-c\Name: dneupd
-c
-c\Description:
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to DNAUPD .  DNAUPD  must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.  The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  See documentation in the header of the subroutine DNAUPD  for
-c  definition of OP as well as other terms and the relation of computed
-c  Ritz values and Ritz vectors of OP with respect to the given problem
-c  A*z = lambda*B*z.  For a brief description, see definitions of
-c  IPARAM(7), MODE and WHICH in the documentation of DNAUPD .
-c
-c\Usage:
-c  call dneupd
-c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT,
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL,
-c       LWORKL, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE..
-c          If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.
-c
-c  DR      Double precision  array of dimension NEV+1.  (OUTPUT)
-c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains
-c          the real part of the Ritz  approximations to the eigenvalues of
-c          A*z = lambda*B*z.
-c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:
-c          DR contains the real part of the Ritz values of OP computed by
-c          DNAUPD . A further computation must be performed by the user
-c          to transform the Ritz values computed for OP by DNAUPD  to those
-c          of the original system A*z = lambda*B*z. See remark 3 below.
-c
-c  DI      Double precision  array of dimension NEV+1.  (OUTPUT)
-c          On exit, DI contains the imaginary part of the Ritz value
-c          approximations to the eigenvalues of A*z = lambda*B*z associated
-c          with DR.
-c
-c          NOTE: When Ritz values are complex, they will come in complex
-c                conjugate pairs.  If eigenvectors are requested, the
-c                corresponding Ritz vectors will also come in conjugate
-c                pairs and the real and imaginary parts of these are
-c                represented in two consecutive columns of the array Z
-c                (see below).
-c
-c  Z       Double precision  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of
-c          Z represent approximate eigenvectors (Ritz vectors) corresponding
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          The complex Ritz vector associated with the Ritz value
-c          with positive imaginary part is stored in two consecutive
-c          columns.  The first column holds the real part of the Ritz
-c          vector and the second column holds the imaginary part.  The
-c          Ritz vector associated with the Ritz value with negative
-c          imaginary part is simply the complex conjugate of the Ritz vector
-c          associated with the positive imaginary part.
-c
-c          If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by DNAUPD .  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.
-c
-c  SIGMAR  Double precision   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the real part of the shift.
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  SIGMAI  Double precision   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift.
-c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.
-c
-c  WORKEV  Double precision  work array of dimension 3*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to DNAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to DNEUPD  following the last call
-c         to DNAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to DNAUPD  and the call to DNEUPD .
-c
-c  Three of these parameters (V, WORKL, INFO) are also output parameters:
-c
-c  V       Double precision  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by DNAUPD  .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.  See Remark 2 below.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in
-c          dnaupd .  They are not changed by dneupd .
-c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the
-c          real and imaginary part of the untransformed Ritz values,
-c          the upper quasi-triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by dneupd .
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     dneupd  if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine dlahqr
-c                could not be reordered by LAPACK routine dtrsen .
-c                Re-enter subroutine dneupd  with IPARAM(5)=NCV and
-c                increase the size of the arrays DR and DI to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine dlahqr .
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine dtrevc .
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: DNAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: DNEUPD got a different count of the number of converged
-c                 Ritz values than DNAUPD got.  This indicates the user
-c                 probably made an error in passing data from DNAUPD to
-c                 DNEUPD or that the data was modified before entering
-c                 DNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     dmout    ARPACK utility routine that prints matrices
-c     dvout    ARPACK utility routine that prints vectors.
-c     dgeqr2   LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     dlacpy   LAPACK matrix copy routine.
-c     dlahqr   LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlaset   LAPACK matrix initialization routine.
-c     dorm2r   LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     dtrevc   LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form.
-c     dtrsen   LAPACK routine that re-orders the Schur form.
-c     dtrmm    Level 3 BLAS matrix times an upper triangular matrix.
-c     dger     Level 2 BLAS rank one update to a matrix.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     ddot     Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dscal    Level 1 BLAS that scales a vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c     Let trans(X) denote the transpose of X.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .TRUE. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately
-c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the
-c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,
-c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
-c     each 2-by-2 diagonal block has its diagonal elements equal and its
-c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
-c     diagonal block is a complex conjugate pair of Ritz values. The real
-c     Ritz values are stored on the diagonal of T.
-c
-c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must
-c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz
-c     values computed by DNAUPD  for OP to those of A*z = lambda*B*z.
-c     Set RVEC = .true. and HOWMNY = 'A', and
-c     compute
-c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.
-c     If DI(I) is not equal to zero and DI(I+1) = - D(I),
-c     then the desired real and imaginary parts of the Ritz value are
-c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),
-c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I),
-c     respectively.
-c     Another possibility is to set RVEC = .true. and HOWMNY = 'P' and
-c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper
-c     quasi-triangular matrix of order IPARAM(5) is computed. See remark
-c     2 above.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine dneupd (rvec , howmny, select, dr    , di,
-     &                   z    , ldz   , sigmar, sigmai, workev,
-     &                   bmat , n     , which , nev   , tol,
-     &                   resid, ncv   , v     , ldv   , iparam,
-     &                   ipntr, workd , workl , lworkl, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           sigmar, sigmai, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Double precision
-     &           dr(nev+1)    , di(nev+1), resid(n)  ,
-     &           v(ldv,ncv)   , z(ldz,*) , workd(3*n),
-     &           workl(lworkl), workev(3*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds   ,
-     &           iheigr, iheigi, iconj , nconv   ,
-     &           invsub, iuptri, iwev  , iwork(1),
-     &           j     , k     , ldh   , ldq     ,
-     &           mode  , msglvl, outncv, ritzr   ,
-     &           ritzi , wri   , wrr   , irr     ,
-     &           iri   , ibd   , ishift, numcnv  ,
-     &           np    , jj    , nconv2
-      logical    reord
-      Double precision
-     &           conds  , rnorm, sep  , temp,
-     &           vl(1,1), temp1, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dger   , dgeqr2 , dlacpy ,
-     &           dlahqr , dlaset , dmout  , dorm2r ,
-     &           dtrevc , dtrmm  , dtrsen , dscal  ,
-     &           dvout  , ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2 , dnrm2 , dlamch , ddot
-      external   dlapy2 , dnrm2 , dlamch , ddot
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, min, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mneupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 .and. sigmai .eq. zero) then
-         type = 'SHIFTI'
-      else if (mode .eq. 3 ) then
-         type = 'REALPT'
-      else if (mode .eq. 4 ) then
-         type = 'IMAGPT'
-      else
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |
-c     |                                   parts of ritz values |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by DNEUPD .                  |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                             real part of the Ritz values. |
-c     | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |
-c     |                        imaginary part of the Ritz values. |
-c     | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |
-c     |                           error bounds of the Ritz values |
-c     | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |
-c     |                             quasi-triangular matrix for H |
-c     | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |
-c     |       associated matrix representation of the invariant   |
-c     |       subspace for H.                                     |
-c     | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |
-c     %-----------------------------------------------------------%
-c
-      ih     = ipntr(5)
-      ritzr  = ipntr(6)
-      ritzi  = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheigr = bounds + ldh
-      iheigi = iheigr + ldh
-      ihbds  = iheigi + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheigr
-      ipntr(10) = iheigi
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wrr = 1
-      wri = ncv + 1
-      iwev = wri + ncv
-c
-c     %-----------------------------------------%
-c     | irr points to the REAL part of the Ritz |
-c     |     values computed by _neigh before    |
-c     |     exiting _naup2.                     |
-c     | iri points to the IMAGINARY part of the |
-c     |     Ritz values computed by _neigh      |
-c     |     before exiting _naup2.              |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irr = ipntr(14)+ncv*ncv
-      iri = irr+ncv
-      ibd = iri+ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, ncv, workl(irr), ndigit,
-     &   '_neupd: Real part of Ritz values passed in from _NAUPD.')
-         call dvout (logfil, ncv, workl(iri), ndigit,
-     &   '_neupd: Imag part of Ritz values passed in from _NAUPD.')
-         call dvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call dngets (ishift       , which     , nev       ,
-     &                np           , workl(irr), workl(iri),
-     &                workl(bounds), workl     , workl(np+1))
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, ncv, workl(irr), ndigit,
-     &      '_neupd: Real part of Ritz values after calling _NGETS.')
-            call dvout (logfil, ncv, workl(iri), ndigit,
-     &      '_neupd: Imag part of Ritz values after calling _NGETS.')
-            call dvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23,
-     &                 dlapy2 ( workl(irr+ncv-j), workl(iri+ncv-j) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nconv) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, [numcnv], ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, [nconv], ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine dlahqr  to compute the real Schur form |
-c        | of the upper Hessenberg matrix returned by DNAUPD .        |
-c        | Make a copy of the upper Hessenberg matrix.               |
-c        | Initialize the Schur vector matrix Q to the identity.     |
-c        %-----------------------------------------------------------%
-c
-         call dcopy (ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call dlaset ('All', ncv, ncv,
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call dlahqr (.true., .true.       , ncv,
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheigr), workl(iheigi),
-     &                1     , ncv          , workl(invsub),
-     &                ldq   , ierr)
-         call dcopy (ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call dvout (logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H')
-            call dvout (logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imaginary part of the Eigenvalues of H')
-            call dvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call dmout (logfil       , ncv, ncv   ,
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper quasi-triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------------%
-c           | Reorder the computed upper quasi-triangular matrix. |
-c           %-----------------------------------------------------%
-c
-            call dtrsen ('None'       , 'V'          ,
-     &                   select       , ncv          ,
-     &                   workl(iuptri), ldh          ,
-     &                   workl(invsub), ldq          ,
-     &                   workl(iheigr), workl(iheigi),
-     &                   nconv2       , conds        ,
-     &                   sep          , workl(ihbds) ,
-     &                   ncv          , iwork        ,
-     &                   1            , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-
-            if (msglvl .gt. 2) then
-                call dvout (logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H--reordered')
-                call dvout (logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imag part of the eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call dmout (logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &             '_neupd: Quasi-triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------%
-c        | Copy the last row of the Schur vector |
-c        | into workl(ihbds).  This will be used |
-c        | to compute the Ritz estimates of      |
-c        | converged Ritz values.                |
-c        %---------------------------------------%
-c
-         call dcopy (ncv, workl(invsub+ncv-1), ldq, workl(ihbds), 1)
-c
-c        %----------------------------------------------------%
-c        | Place the computed eigenvalues of H into DR and DI |
-c        | if a spectral transformation was not used.         |
-c        %----------------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call dgeqr2 (ncv, nconv , workl(invsub),
-     &               ldq, workev, workev(ncv+1),
-     &               ierr)
-c
-c        %---------------------------------------------------------%
-c        | * Postmultiply V by Q using dorm2r .                     |
-c        | * Copy the first NCONV columns of VQ into Z.            |
-c        | * Postmultiply Z by R.                                  |
-c        | The N by NCONV matrix Z is now a matrix representation  |
-c        | of the approximate invariant subspace associated with   |
-c        | the Ritz values in workl(iheigr) and workl(iheigi)      |
-c        | The first NCONV columns of V are now approximate Schur  |
-c        | vectors associated with the real upper quasi-triangular |
-c        | matrix of order NCONV in workl(iuptri)                  |
-c        %---------------------------------------------------------%
-c
-         call dorm2r ('Right', 'Notranspose', n            ,
-     &                ncv   , nconv        , workl(invsub),
-     &                ldq   , workev       , v            ,
-     &                ldv   , workd(n+1)   , ierr)
-         call dlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | quasi-triangular form of workl(iuptri,ldq)        |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones           |
-c           %---------------------------------------------------%
-c
-            if (workl(invsub+(j-1)*ldq+j-1) .lt. zero) then
-               call dscal (nconv, -one, workl(iuptri+j-1), ldq)
-               call dscal (nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call dtrevc ('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | dtrevc  returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1;                                   |
-c           %------------------------------------------------%
-c
-            iconj = 0
-            do 40 j=1, nconv
-c
-               if ( workl(iheigi+j-1) .eq. zero ) then
-c
-c                 %----------------------%
-c                 | real eigenvalue case |
-c                 %----------------------%
-c
-                  temp = dnrm2 ( ncv, workl(invsub+(j-1)*ldq), 1 )
-                  call dscal ( ncv, one / temp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-               else
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 | columns, we further normalize by the      |
-c                 | square root of two.                       |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     temp = dlapy2 (dnrm2 (ncv,
-     &                                   workl(invsub+(j-1)*ldq),
-     &                                   1),
-     &                             dnrm2 (ncv,
-     &                                   workl(invsub+j*ldq),
-     &                                   1))
-                     call dscal (ncv, one/temp,
-     &                           workl(invsub+(j-1)*ldq), 1 )
-                     call dscal (ncv, one/temp,
-     &                           workl(invsub+j*ldq), 1 )
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-c
-               end if
-c
- 40         continue
-c
-            call dgemv ('T', ncv, nconv, one, workl(invsub),
-     &                 ldq, workl(ihbds), 1, zero,  workev, 1)
-c
-            iconj = 0
-            do 45 j=1, nconv
-               if (workl(iheigi+j-1) .ne. zero) then
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     workev(j) = dlapy2 (workev(j), workev(j+1))
-                     workev(j+1) = workev(j)
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-               end if
- 45         continue
-c
-            if (msglvl .gt. 2) then
-               call dcopy (ncv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call dvout (logfil, ncv, workl(ihbds), ndigit,
-     &              '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call dmout (logfil, ncv, ncv, workl(invsub), ldq,
-     &                 ndigit, '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call dcopy (nconv, workev, 1, workl(ihbds), 1)
-c
-c           %---------------------------------------------------------%
-c           | Compute the QR factorization of the eigenvector matrix  |
-c           | associated with leading portion of T in the first NCONV |
-c           | columns of workl(invsub,ldq).                           |
-c           %---------------------------------------------------------%
-c
-            call dgeqr2 (ncv, nconv , workl(invsub),
-     &                   ldq, workev, workev(ncv+1),
-     &                   ierr)
-c
-c           %----------------------------------------------%
-c           | * Postmultiply Z by Q.                       |
-c           | * Postmultiply Z by R.                       |
-c           | The N by NCONV matrix Z is now contains the  |
-c           | Ritz vectors associated with the Ritz values |
-c           | in workl(iheigr) and workl(iheigi).          |
-c           %----------------------------------------------%
-c
-            call dorm2r ('Right', 'Notranspose', n            ,
-     &                   ncv  , nconv        , workl(invsub),
-     &                   ldq  , workev       , z            ,
-     &                   ldz  , workd(n+1)   , ierr)
-c
-            call dtrmm ('Right'   , 'Upper'       , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-c
-         end if
-c
-      else
-c
-c        %------------------------------------------------------%
-c        | An approximate invariant subspace is not needed.     |
-c        | Place the Ritz values computed DNAUPD  into DR and DI |
-c        %------------------------------------------------------%
-c
-         call dcopy (nconv, workl(ritzr), 1, dr, 1)
-         call dcopy (nconv, workl(ritzi), 1, di, 1)
-         call dcopy (nconv, workl(ritzr), 1, workl(iheigr), 1)
-         call dcopy (nconv, workl(ritzi), 1, workl(iheigi), 1)
-         call dcopy (nconv, workl(bounds), 1, workl(ihbds), 1)
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec)
-     &      call dscal (ncv, rnorm, workl(ihbds), 1)
-c
-      else
-c
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (type .eq. 'SHIFTI') then
-c
-            if (rvec)
-     &         call dscal (ncv, rnorm, workl(ihbds), 1)
-c
-            do 50 k=1, ncv
-               temp = dlapy2 ( workl(iheigr+k-1),
-     &                        workl(iheigi+k-1) )
-               workl(ihbds+k-1) = abs( workl(ihbds+k-1) )
-     &                          / temp / temp
- 50         continue
-c
-         else if (type .eq. 'REALPT') then
-c
-            do 60 k=1, ncv
- 60         continue
-c
-         else if (type .eq. 'IMAGPT') then
-c
-            do 70 k=1, ncv
- 70         continue
-c
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | *  Transform the Ritz values back to the original system. |
-c        |    For TYPE = 'SHIFTI' the transformation is              |
-c        |             lambda = 1/theta + sigma                      |
-c        |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |
-c        |    Rayleigh quotients or a projection. See remark 3 above.|
-c        | NOTES:                                                    |
-c        | *The Ritz vectors are not affected by the transformation. |
-c        %-----------------------------------------------------------%
-c
-         if (type .eq. 'SHIFTI') then
-c
-            do 80 k=1, ncv
-               temp = dlapy2 ( workl(iheigr+k-1),
-     &                        workl(iheigi+k-1) )
-               workl(iheigr+k-1) = workl(iheigr+k-1)/temp/temp
-     &                           + sigmar
-               workl(iheigi+k-1) = -workl(iheigi+k-1)/temp/temp
-     &                           + sigmai
- 80         continue
-c
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-c
-         else if (type .eq. 'REALPT' .or. type .eq. 'IMAGPT') then
-c
-            call dcopy (nconv, workl(iheigr), 1, dr, 1)
-            call dcopy (nconv, workl(iheigi), 1, di, 1)
-c
-         end if
-c
-      end if
-c
-      if (type .eq. 'SHIFTI' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, dr, ndigit,
-     &   '_neupd: Untransformed real part of the Ritz values.')
-         call dvout  (logfil, nconv, di, ndigit,
-     &   '_neupd: Untransformed imag part of the Ritz values.')
-         call dvout (logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Ritz estimates of untransformed Ritz values.')
-      else if (type .eq. 'REGULR' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, dr, ndigit,
-     &   '_neupd: Real parts of converged Ritz values.')
-         call dvout  (logfil, nconv, di, ndigit,
-     &   '_neupd: Imag parts of converged Ritz values.')
-         call dvout (logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 2.                                   |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta. Remember that when theta  |
-c        | has nonzero imaginary part, the corresponding  |
-c        | Ritz vector is stored across two columns of Z. |
-c        %------------------------------------------------%
-c
-         iconj = 0
-         do 110 j=1, nconv
-            if ((workl(iheigi+j-1) .eq. zero) .and.
-     &           (workl(iheigr+j-1) .ne. zero)) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheigr+j-1)
-            else if (iconj .eq. 0) then
-               temp = dlapy2 ( workl(iheigr+j-1), workl(iheigi+j-1) )
-               if (temp .ne. zero) then
-                  workev(j) = ( workl(invsub+(j-1)*ldq+ncv-1) *
-     &                          workl(iheigr+j-1) +
-     &                          workl(invsub+j*ldq+ncv-1) *
-     &                          workl(iheigi+j-1) ) / temp / temp
-                  workev(j+1) = ( workl(invsub+j*ldq+ncv-1) *
-     &                            workl(iheigr+j-1) -
-     &                            workl(invsub+(j-1)*ldq+ncv-1) *
-     &                            workl(iheigi+j-1) ) / temp / temp
-               end if
-               iconj = 1
-            else
-               iconj = 0
-            end if
- 110     continue
-c
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call dger (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of DNEUPD  |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dngets.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dngets.f
deleted file mode 100644
index 47d3ac2ce0..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dngets.f
+++ /dev/null
@@ -1,231 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dngets
-c
-c\Description:
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call dngets
-c     ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest real part.
-c          'SR' -> want the KEV eigenvalues of smallest real part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV      Integer.  (INPUT/OUTPUT)
-c           INPUT: KEV+NP is the size of the matrix H.
-c           OUTPUT: Possibly increases KEV by one to keep complex conjugate
-c           pairs together.
-c
-c  NP       Integer.  (INPUT/OUTPUT)
-c           Number of implicit shifts to be computed.
-c           OUTPUT: Possibly decreases NP by one to keep complex conjugate
-c           pairs together.
-c
-c  RITZR,  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c  RITZI   On INPUT, RITZR and RITZI contain the real and imaginary
-c          parts of the eigenvalues of H.
-c          On OUTPUT, RITZR and RITZI are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are
-c          selected, the unwanted part corresponds to the shifts to
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***
-c
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dsortc  ARPACK sorting routine.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dngets ( ishift, which, kev, np, ritzr, ritzi, bounds,
-     &                    shiftr, shifti )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(kev+np), ritzr(kev+np), ritzi(kev+np),
-     &           shiftr(1), shifti(1)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0, zero = 0.0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dsortc, arscnd
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mngets
-c
-c     %----------------------------------------------------%
-c     | LM, SM, LR, SR, LI, SI case.                       |
-c     | Sort the eigenvalues of H into the desired order   |
-c     | and apply the resulting order to BOUNDS.           |
-c     | The eigenvalues are sorted so that the wanted part |
-c     | are always in the last KEV locations.              |
-c     | We first do a pre-processing sort in order to keep |
-c     | complex conjugate pairs together                   |
-c     %----------------------------------------------------%
-c
-      if (which .eq. 'LM') then
-         call dsortc ('LR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SM') then
-         call dsortc ('SR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LR') then
-         call dsortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SR') then
-         call dsortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LI') then
-         call dsortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SI') then
-         call dsortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      end if
-c
-      call dsortc (which, .true., kev+np, ritzr, ritzi, bounds)
-c
-c     %-------------------------------------------------------%
-c     | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |
-c     | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |
-c     | Accordingly decrease NP by one. In other words keep   |
-c     | complex conjugate pairs together.                     |
-c     %-------------------------------------------------------%
-c
-      if (       ( ritzr(np+1) - ritzr(np) ) .eq. zero
-     &     .and. ( ritzi(np+1) + ritzi(np) ) .eq. zero ) then
-         np = np - 1
-         kev = kev + 1
-      end if
-c
-      if ( ishift .eq. 1 ) then
-c
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when they shifts |
-c        | are applied in subroutine dnapps.                     |
-c        | Be careful and use 'SR' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c
-         call dsortc ( 'SR', .true., np, bounds, ritzr, ritzi )
-      end if
-c
-      call arscnd (t1)
-      tngets = tngets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
-         call dvout (logfil, kev+np, ritzr, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- real part')
-         call dvout (logfil, kev+np, ritzi, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- imag part')
-         call dvout (logfil, kev+np, bounds, ndigit,
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c
-      return
-c
-c     %---------------%
-c     | End of dngets |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaitr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaitr.f
deleted file mode 100644
index 3460d990c9..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaitr.f
+++ /dev/null
@@ -1,853 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaitr
-c
-c\Description:
-c  Reverse communication interface for applying NP additional steps to
-c  a K step symmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in dsaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call dsaitr
-c     ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and does not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of matrix B that defines the
-c          semi-inner product for the operator OP.  See dsaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current order of H and the number of columns of V.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  MODE    Integer.  (INPUT)
-c          Signifies which form for "OP". If MODE=2 then
-c          a reduction in the number of B matrix vector multiplies
-c          is possible since the B-norm of OP*x is equivalent to
-c          the inv(B)-norm of A*x.
-c
-c  RESID   Double precision array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          On INPUT the B-norm of r_{k}.
-c          On OUTPUT the B-norm of the updated residual r_{k+p}.
-c
-c  V       Double precision N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (K+NP) by 2 array.  (INPUT/OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          with the subdiagonal in the first column starting at H(2,1)
-c          and the main diagonal in the second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On INPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K step Arnoldi factorization. Used to save some
-c          computation at the first step.
-c          On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K+NP step Arnoldi factorization.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of an invariant subspace of OP is found that is
-c               less than K + NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     dmout   ARPACK utility routine that prints matrices.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dcopy   Level 1 BLAS that copies one vector to another .
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k};
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in dsaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        alphaj <- j-th component of w_{j}
-c        rnorm = || r_{j} ||
-c        betaj+1 = rnorm
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaitr
-     &   (ido, bmat, n, k, np, mode, resid, rnorm, v, ldv, h, ldh,
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, mode, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           h(ldh,2), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           infol, jj
-      Double precision
-     &           rnorm1, wnorm, safmin, temp1
-      save       orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           rnorm1, safmin, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments |
-c     %-----------------------%
-c
-      Double precision
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dgemv, dgetv0, dvout, dmout,
-     &           dlascl, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlamch
-      external   ddot, dnrm2, dlamch
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         first = .false.
-c
-c        %--------------------------------%
-c        | safmin = safe minimum is such  |
-c        | that 1/sfmin does not overflow |
-c        %--------------------------------%
-c
-         safmin = dlamch('safmin')
-      end if
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaitr
-c
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-c
-c        %--------------------------------%
-c        | Pointer to the current step of |
-c        | the factorization to build     |
-c        %--------------------------------%
-c
-         j      = k + 1
-c
-c        %------------------------------------------%
-c        | Pointers used for reverse communication  |
-c        | when using WORKD.                        |
-c        %------------------------------------------%
-c
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true.                                  |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         dgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %------------------------------%
-c     | Else this is the first step. |
-c     %------------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [j], ndigit,
-     &                  '_saitr: generating Arnoldi vector no.')
-            call dvout (logfil, 1, [rnorm], ndigit,
-     &                  '_saitr: B-norm of the current residual =')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Check for exact zero. Equivalent to determining whether |
-c        | a j-step Arnoldi factorization is present.              |
-c        %---------------------------------------------------------%
-c
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [j], ndigit,
-     &                     '_saitr: ****** restart at step ******')
-            end if
-c
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call dgetv0 (ido, bmat, itry, .false., n, j, v, ldv,
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tsaitr = tsaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call dcopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. safmin) then
-             temp1 = one / rnorm
-             call dscal (n, temp1, v(1,j), 1)
-             call dscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call dlascl ('General', i, i, rnorm, one, n, 1,
-     &                    v(1,j), n, infol)
-             call dlascl ('General', i, i, rnorm, one, n, 1,
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call dcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c
-         go to 9000
-   50    continue
-c
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |
-c        %-----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-c
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call dcopy (n, workd(irj), 1, resid, 1)
-c
-c        %-------------------------------------------%
-c        | STEP 4:  Finish extending the symmetric   |
-c        |          Arnoldi to length j. If MODE = 2 |
-c        |          then B*OP = B*inv(B)*A = A and   |
-c        |          we don't need to compute B*OP.   |
-c        | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |
-c        | assumed to have A*v_{j}.                  |
-c        %-------------------------------------------%
-c
-         if (mode .eq. 2) go to 65
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-              call dcopy(n, resid, 1 , workd(ipj), 1)
-         end if
-   60    continue
-c
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |
-c        %-----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-   65    continue
-         if (mode .eq. 2) then
-c
-c           %----------------------------------%
-c           | Note that the B-norm of OP*v_{j} |
-c           | is the inv(B)-norm of A*v_{j}.   |
-c           %----------------------------------%
-c
-            wnorm = ddot (n, resid, 1, workd(ivj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'G') then
-            wnorm = ddot (n, resid, 1, workd(ipj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         if (mode .ne. 2 ) then
-            call dgemv('T', n, j, one, v, ldv, workd(ipj), 1, zero,
-     &                  workd(irj), 1)
-         else if (mode .eq. 2) then
-            call dgemv('T', n, j, one, v, ldv, workd(ivj), 1, zero,
-     &                  workd(irj), 1)
-         end if
-c
-c        %--------------------------------------%
-c        | Orthgonalize r_{j} against V_{j}.    |
-c        | RESID contains OP*v_{j}. See STEP 3. |
-c        %--------------------------------------%
-c
-         call dgemv('N', n, j, -one, v, ldv, workd(irj), 1, one,
-     &               resid, 1)
-c
-c        %--------------------------------------%
-c        | Extend H to have j rows and columns. |
-c        %--------------------------------------%
-c
-         h(j,2) = workd(irj + j - 1)
-         if (j .eq. 1  .or.  rstart) then
-            h(j,1) = zero
-         else
-            h(j,1) = rnorm
-         end if
-         call arscnd (t4)
-c
-         orth1 = .true.
-         iter  = 0
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then
-            rnorm = ddot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         nrorth = nrorth + 1
-c
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call dvout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: re-orthonalization ; wnorm and rnorm are')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call dgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, workd(irj), 1)
-c
-c        %----------------------------------------------%
-c        | Compute the correction to the residual:      |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J) + |
-c        | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |
-c        | H(j,j) is updated.                           |
-c        %----------------------------------------------%
-c
-         call dgemv ('N', n, j, -one, v, ldv, workd(irj), 1,
-     &               one, resid, 1)
-c
-         if (j .eq. 1  .or.  rstart) h(j,1) = zero
-         h(j,2) = h(j,2) + workd(irj + j - 1)
-c
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             rnorm1 = ddot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = dnrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, [j], ndigit,
-     &           '_saitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call dvout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %--------------------------------%
-c           | No need for further refinement |
-c           %--------------------------------%
-c
-            rnorm = rnorm1
-c
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c
-         rstart = .false.
-         orth2  = .false.
-c
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c
-c        %----------------------------------------------------------%
-c        | Make sure the last off-diagonal element is non negative  |
-c        | If not perform a similarity transformation on H(1:j,1:j) |
-c        | and scale v(:,j) by -1.                                  |
-c        %----------------------------------------------------------%
-c
-         if (h(j,1) .lt. zero) then
-            h(j,1) = -h(j,1)
-            if ( j .lt. k+np) then
-               call dscal(n, -one, v(1,j+1), 1)
-            else
-               call dscal(n, -one, resid, 1)
-            end if
-         end if
-c
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tsaitr = tsaitr + (t1 - t0)
-            ido = 99
-c
-            if (msglvl .gt. 1) then
-               call dvout (logfil, k+np, h(1,2), ndigit,
-     &         '_saitr: main diagonal of matrix H of step K+NP.')
-               if (k+np .gt. 1) then
-               call dvout (logfil, k+np-1, h(2,1), ndigit,
-     &         '_saitr: sub diagonal of matrix H of step K+NP.')
-               end if
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsaitr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsapps.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsapps.f
deleted file mode 100644
index f84ef83897..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsapps.f
+++ /dev/null
@@ -1,518 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP shifts implicitly resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix of order KEV+NP. Q is the product of
-c  rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi
-c  factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call dsapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. dimension of matrix A.
-c
-c  KEV     Integer.  (INPUT)
-c          INPUT: KEV+NP is the size of the input matrix H.
-c          OUTPUT: KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Double precision array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Double precision N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          INPUT: V contains the current KEV+NP Arnoldi vectors.
-c          OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors
-c          are in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (KEV+NP) by 2 array.  (INPUT/OUTPUT)
-c          INPUT: H contains the symmetric tridiagonal matrix of the
-c          Arnoldi factorization with the subdiagonal in the 1st column
-c          starting at H(2,1) and the main diagonal in the 2nd column.
-c          OUTPUT: H contains the updated tridiagonal matrix in the
-c          KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Double precision array of length (N).  (INPUT/OUTPUT)
-c          INPUT: RESID contains the the residual vector r_{k+p}.
-c          OUTPUT: RESID is the updated residual vector rnew_{k}.
-c
-c  Q       Double precision KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations during the bulge
-c          chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKD   Double precision work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlacpy  LAPACK matrix copy routine.
-c     dlaset  LAPACK matrix initialization routine.
-c     dgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: sapps.F   SID: 2.6   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the subblocks of
-c     the tridiagonal matrix H and not just to the submatrix that it
-c     comes from. This routine assumes that the subdiagonal elements
-c     of H that are stored in h(1:kev+np,1) are nonegative upon input
-c     and enforce this condition upon output. This version incorporates
-c     deflation. See code for documentation.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           h(ldh,2), q(ldq,kev+np), resid(n), shift(np),
-     &           v(ldv,kev+np), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, iend, istart, itop, j, jj, kplusp, msglvl
-      logical    first
-      Double precision
-     &           a1, a2, a3, a4, big, c, epsmch, f, g, r, s
-      save       epsmch, first
-c
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   daxpy, dcopy, dscal, dlacpy, dlartg, dlaset, dvout,
-     &           ivout, arscnd, dgemv
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %----------------%
-c     | Data statements |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         epsmch = dlamch('Epsilon-Machine')
-         first = .false.
-      end if
-      itop = 1
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msapps
-c
-      kplusp = kev + np
-c
-c     %----------------------------------------------%
-c     | Initialize Q to the identity matrix of order |
-c     | kplusp used to accumulate the rotations.     |
-c     %----------------------------------------------%
-c
-      call dlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------------------%
-c     | Apply the np shifts implicitly. Apply each shift to the  |
-c     | whole matrix and not just to the submatrix from which it |
-c     | comes.                                                   |
-c     %----------------------------------------------------------%
-c
-      do 90 jj = 1, np
-c
-         istart = itop
-c
-c        %----------------------------------------------------------%
-c        | Check for splitting and deflation. Currently we consider |
-c        | an off-diagonal element h(i+1,1) negligible if           |
-c        |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |
-c        | for i=1:KEV+NP-1.                                        |
-c        | If above condition tests true then we set h(i+1,1) = 0.  |
-c        | Note that h(1:KEV+NP,1) are assumed to be non negative.  |
-c        %----------------------------------------------------------%
-c
-   20    continue
-c
-c        %------------------------------------------------%
-c        | The following loop exits early if we encounter |
-c        | a negligible off diagonal element.             |
-c        %------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-            big   = abs(h(i,2)) + abs(h(i+1,2))
-            if (h(i+1,1) .le. epsmch*big) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, [i], ndigit,
-     &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, [jj], ndigit,
-     &                 '_sapps: occurred before shift number.')
-                  call dvout (logfil, 1, h(i+1,1), ndigit,
-     &                 '_sapps: the corresponding off diagonal element')
-               end if
-               h(i+1,1) = zero
-               iend = i
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (istart .lt. iend) then
-c
-c           %--------------------------------------------------------%
-c           | Construct the plane rotation G'(istart,istart+1,theta) |
-c           | that attempts to drive h(istart+1,1) to zero.          |
-c           %--------------------------------------------------------%
-c
-             f = h(istart,2) - shift(jj)
-             g = h(istart+1,1)
-             call dlartg (f, g, c, s, r)
-c
-c            %-------------------------------------------------------%
-c            | Apply rotation to the left and right of H;            |
-c            | H <- G' * H * G,  where G = G(istart,istart+1,theta). |
-c            | This will create a "bulge".                           |
-c            %-------------------------------------------------------%
-c
-             a1 = c*h(istart,2)   + s*h(istart+1,1)
-             a2 = c*h(istart+1,1) + s*h(istart+1,2)
-             a4 = c*h(istart+1,2) - s*h(istart+1,1)
-             a3 = c*h(istart+1,1) - s*h(istart,2)
-             h(istart,2)   = c*a1 + s*a2
-             h(istart+1,2) = c*a4 - s*a3
-             h(istart+1,1) = c*a3 + s*a4
-c
-c            %----------------------------------------------------%
-c            | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c            %----------------------------------------------------%
-c
-             do 60 j = 1, min(istart+jj,kplusp)
-                a1            =   c*q(j,istart) + s*q(j,istart+1)
-                q(j,istart+1) = - s*q(j,istart) + c*q(j,istart+1)
-                q(j,istart)   = a1
-   60        continue
-c
-c
-c            %----------------------------------------------%
-c            | The following loop chases the bulge created. |
-c            | Note that the previous rotation may also be  |
-c            | done within the following loop. But it is    |
-c            | kept separate to make the distinction among  |
-c            | the bulge chasing sweeps and the first plane |
-c            | rotation designed to drive h(istart+1,1) to  |
-c            | zero.                                        |
-c            %----------------------------------------------%
-c
-             do 70 i = istart+1, iend-1
-c
-c               %----------------------------------------------%
-c               | Construct the plane rotation G'(i,i+1,theta) |
-c               | that zeros the i-th bulge that was created   |
-c               | by G(i-1,i,theta). g represents the bulge.   |
-c               %----------------------------------------------%
-c
-                f = h(i,1)
-                g = s*h(i+1,1)
-c
-c               %----------------------------------%
-c               | Final update with G(i-1,i,theta) |
-c               %----------------------------------%
-c
-                h(i+1,1) = c*h(i+1,1)
-                call dlartg (f, g, c, s, r)
-c
-c               %-------------------------------------------%
-c               | The following ensures that h(1:iend-1,1), |
-c               | the first iend-2 off diagonal of elements |
-c               | H, remain non negative.                   |
-c               %-------------------------------------------%
-c
-                if (r .lt. zero) then
-                   r = -r
-                   c = -c
-                   s = -s
-                end if
-c
-c               %--------------------------------------------%
-c               | Apply rotation to the left and right of H; |
-c               | H <- G * H * G',  where G = G(i,i+1,theta) |
-c               %--------------------------------------------%
-c
-                h(i,1) = r
-c
-                a1 = c*h(i,2)   + s*h(i+1,1)
-                a2 = c*h(i+1,1) + s*h(i+1,2)
-                a3 = c*h(i+1,1) - s*h(i,2)
-                a4 = c*h(i+1,2) - s*h(i+1,1)
-c
-                h(i,2)   = c*a1 + s*a2
-                h(i+1,2) = c*a4 - s*a3
-                h(i+1,1) = c*a3 + s*a4
-c
-c               %----------------------------------------------------%
-c               | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c               %----------------------------------------------------%
-c
-                do 50 j = 1, min( i+jj, kplusp )
-                   a1       =   c*q(j,i) + s*q(j,i+1)
-                   q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                   q(j,i)   = a1
-   50           continue
-c
-   70        continue
-c
-         end if
-c
-c        %--------------------------%
-c        | Update the block pointer |
-c        %--------------------------%
-c
-         istart = iend + 1
-c
-c        %------------------------------------------%
-c        | Make sure that h(iend,1) is non-negative |
-c        | If not then set h(iend,1) <-- -h(iend,1) |
-c        | and negate the last column of Q.         |
-c        | We have effectively carried out a        |
-c        | similarity on transformation H           |
-c        %------------------------------------------%
-c
-         if (h(iend,1) .lt. zero) then
-             h(iend,1) = -h(iend,1)
-             call dscal(kplusp, -one, q(1,iend), 1)
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any |
-c        %--------------------------------------------------------%
-c
-         if (iend .lt. kplusp) go to 20
-c
-c        %-----------------------------------------------------%
-c        | Check if we can increase the the start of the block |
-c        %-----------------------------------------------------%
-c
-         do 80 i = itop, kplusp-1
-            if (h(i+1,1) .gt. zero) go to 90
-            itop  = itop + 1
-   80    continue
-c
-c        %-----------------------------------%
-c        | Finished applying the jj-th shift |
-c        %-----------------------------------%
-c
-   90 continue
-c
-c     %------------------------------------------%
-c     | All shifts have been applied. Check for  |
-c     | more possible deflation that might occur |
-c     | after the last shift is applied.         |
-c     %------------------------------------------%
-c
-      do 100 i = itop, kplusp-1
-         big   = abs(h(i,2)) + abs(h(i+1,2))
-         if (h(i+1,1) .le. epsmch*big) then
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [i], ndigit,
-     &              '_sapps: deflation at row/column no.')
-               call dvout (logfil, 1, h(i+1,1), ndigit,
-     &              '_sapps: the corresponding off diagonal element')
-            end if
-            h(i+1,1) = zero
-         end if
- 100  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is not necessary if h(kev+1,1) = 0.         |
-c     %-------------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero )
-     &   call dgemv ('N', n, kplusp, one, v, ldv,
-     &                q(1,kev+1), 1, zero, workd(n+1), 1)
-c
-c     %-------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order    |
-c     | taking advantage that Q is an upper triangular matrix |
-c     | with lower bandwidth np.                              |
-c     | Place results in v(:,kplusp-kev:kplusp) temporarily.  |
-c     %-------------------------------------------------------%
-c
-      do 130 i = 1, kev
-         call dgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call dcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  130 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call dcopy (n, v(1,np+i), 1, v(1,i), 1)
-  140 continue
-c
-c     %--------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the |
-c     | appropriate place if h(kev+1,1) .ne. zero. |
-c     %--------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero )
-     &     call dcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call dscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,1) .gt. zero)
-     &   call daxpy (n, h(kev+1,1), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call dvout (logfil, 1, q(kplusp,kev), ndigit,
-     &      '_sapps: sigmak of the updated residual vector')
-         call dvout (logfil, 1, h(kev+1,1), ndigit,
-     &      '_sapps: betak of the updated residual vector')
-         call dvout (logfil, kev, h(1,2), ndigit,
-     &      '_sapps: updated main diagonal of H for next iteration')
-         if (kev .gt. 1) then
-         call dvout (logfil, kev-1, h(2,1), ndigit,
-     &      '_sapps: updated sub diagonal of H for next iteration')
-         end if
-      end if
-c
-      call arscnd (t1)
-      tsapps = tsapps + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsapps |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaup2.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaup2.f
deleted file mode 100644
index fd4143f537..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaup2.f
+++ /dev/null
@@ -1,851 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaup2
-c
-c\Description:
-c  Intermediate level interface called by dsaupd.
-c
-c\Usage:
-c  call dsaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in dsaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in dsaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi/Lanczos iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse communication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Tridiagonal matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Double precision N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Double precision (NEV+NP) by 2 array.  (OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          The subdiagonal is stored in the first column of H starting
-c          at H(2,1).  The main diagonal is stored in the arscnd column
-c          of H starting at H(1,2). If dsaup2 converges store the
-c          B-norm of the final residual vector in H(1,1).
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Double precision array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV) contains the computed Ritz values of OP.
-c
-c  BOUNDS  Double precision array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.
-c
-c  Q       Double precision (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Double precision array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in the computation of the
-c          tridiagonal eigenvalue problem, the calculation and
-c          application of the shifts and convergence checking.
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in one of
-c                    the spectral transformation modes.  X is the current
-c                    operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Lanczos iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in dsaupd.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: All possible eigenvalues of OP has been found.
-c                   NP returns the size of the invariant subspace
-c                   spanning the operator OP.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from trid. eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Lanczos factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Routines called:
-c     dgetv0  ARPACK initial vector generation routine.
-c     dsaitr  ARPACK Lanczos factorization routine.
-c     dsapps  ARPACK application of implicit shifts routine.
-c     dsconv  ARPACK convergence of Ritz values routine.
-c     dseigt  ARPACK compute Ritz values and error bounds routine.
-c     dsgets  ARPACK reorder Ritz values and error bounds routine.
-c     dsortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     ddot    Level 1 BLAS that computes the scalar product of two vectors.
-c     dnrm2   Level 1 BLAS that computes the norm of a vector.
-c     dscal   Level 1 BLAS that scales a vector.
-c     dswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c     xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)
-c
-c\SCCS Information: @(#)
-c FILE: saup2.F   SID: 2.7   DATE OF SID: 5/19/98   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
-     &           n, mode, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Double precision
-     &           bounds(nev+np), h(ldh,2), q(ldq,nev+np), resid(n),
-     &           ritz(nev+np), v(ldv,nev+np), workd(3*n),
-     &           workl(3*(nev+np))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm, getv0, initv, update, ushift
-      integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0,
-     &           np0, nptemp, nevd2, nevm2, kp(3)
-      Double precision
-     &           rnorm, temp, eps23
-      save       cnorm, getv0, initv, update, ushift,
-     &           iter, kplusp, msglvl, nconv, nev0, np0,
-     &           rnorm, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dgetv0, dsaitr, dscal, dsconv, dseigt, dsgets,
-     &           dsapps, dsortr, dvout, ivout, arscnd, dswap
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           ddot, dnrm2, dlamch
-      external   ddot, dnrm2, dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaup2
-c
-c        %---------------------------------%
-c        | Set machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = dlamch('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0/3.0D+0)
-c
-c        %-------------------------------------%
-c        | nev0 and np0 are integer variables  |
-c        | hold the initial values of NEV & NP |
-c        %-------------------------------------%
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev0 + np0
-         nconv  = 0
-         iter   = 0
-c
-c        %--------------------------------------------%
-c        | Set flags for computing the first NEV steps |
-c        | of the Lanczos factorization.              |
-c        %--------------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c        %--------------------------------------------%
-c        | User provides the initial residual vector. |
-c        %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call dgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1200
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %------------------------------------------------------------%
-c     | Back from reverse communication: continue with update step |
-c     %------------------------------------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Lanczos factorization |
-c     %----------------------------------------------------------%
-c
-      call dsaitr (ido, bmat, n, 0, nev0, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-c
-c        %-----------------------------------------------------%
-c        | dsaitr was unable to build an Lanczos factorization |
-c        | of length NEV0. INFO is returned with the size of   |
-c        | the factorization built. Exit main loop.            |
-c        %-----------------------------------------------------%
-c
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Lanczos     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [iter], ndigit,
-     &           '_saup2: **** Start of major iteration number ****')
-         end if
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [nev], ndigit,
-     &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, [np], ndigit,
-     &           '_saup2: Extend the Lanczos factorization by')
-         end if
-c
-c        %------------------------------------------------------------%
-c        | Compute NP additional steps of the Lanczos factorization. |
-c        %------------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call dsaitr (ido, bmat, n, nev, np, mode, resid, rnorm, v,
-     &                ldv, h, ldh, ipntr, workd, info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-c
-c           %-----------------------------------------------------%
-c           | dsaitr was unable to build an Lanczos factorization |
-c           | of length NEV0+NP0. INFO is returned with the size  |
-c           | of the factorization built. Exit main loop.         |
-c           %-----------------------------------------------------%
-c
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout (logfil, 1, [rnorm], ndigit,
-     &           '_saup2: Current B-norm of residual for factorization')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current symmetric tridiagonal matrix.           |
-c        %--------------------------------------------------------%
-c
-         call dseigt (rnorm, kplusp, h, ldh, ritz, bounds, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from _seigt.                       |
-c        %----------------------------------------------------%
-c
-         call dcopy(kplusp, ritz, 1, workl(kplusp+1), 1)
-         call dcopy(kplusp, bounds, 1, workl(2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The selection is based on the requested number of |
-c        | eigenvalues instead of the current NEV and NP to  |
-c        | prevent possible misconvergence.                  |
-c        | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |
-c        | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         call dsgets (ishift, which, nev, np, ritz, bounds, workl)
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call dcopy (nev, bounds(np+1), 1, workl(np+1), 1)
-         call dsconv (nev, ritz(np+1), workl(np+1), tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_saup2: NEV, NP, NCONV are')
-            call dvout (logfil, kplusp, ritz, ndigit,
-     &           '_saup2: The eigenvalues of H')
-            call dvout (logfil, kplusp, bounds, ndigit,
-     &          '_saup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. nev0) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP since we don't want to |
-c           | swap overlapping locations.                    |
-c           %------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %-----------------------------------------------------%
-c              | Both ends of the spectrum are requested.            |
-c              | Sort the eigenvalues into algebraically decreasing  |
-c              | order first then swap low end of the spectrum next  |
-c              | to high end in appropriate locations.               |
-c              | NOTE: when np < floor(nev/2) be careful not to swap |
-c              | overlapping locations.                              |
-c              %-----------------------------------------------------%
-c
-               wprime = 'SA'
-               call dsortr (wprime, .true., kplusp, ritz, bounds)
-               nevd2 = nev0 / 2
-               nevm2 = nev0 - nevd2
-               if ( nev .gt. 1 ) then
-                  np = kplusp - nev0
-                  call dswap ( min(nevd2,np), ritz(nevm2+1), 1,
-     &                 ritz( max(kplusp-nevd2+1,kplusp-np+1) ), 1)
-                  call dswap ( min(nevd2,np), bounds(nevm2+1), 1,
-     &                 bounds( max(kplusp-nevd2+1,kplusp-np+1)), 1)
-               end if
-c
-            else
-c
-c              %--------------------------------------------------%
-c              | LM, SM, LA, SA case.                             |
-c              | Sort the eigenvalues of H into the an order that |
-c              | is opposite to WHICH, and apply the resulting    |
-c              | order to BOUNDS.  The eigenvalues are sorted so  |
-c              | that the wanted part are always within the first |
-c              | NEV locations.                                   |
-c              %--------------------------------------------------%
-c
-               if (which .eq. 'LM') wprime = 'SM'
-               if (which .eq. 'SM') wprime = 'LM'
-               if (which .eq. 'LA') wprime = 'SA'
-               if (which .eq. 'SA') wprime = 'LA'
-c
-               call dsortr (wprime, .true., kplusp, ritz, bounds)
-c
-            end if
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-               temp = max( eps23, abs(ritz(j)) )
-               bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | estimates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LA'
-            call dsortr(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                temp = max( eps23, abs(ritz(j)) )
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %--------------------------------------------------%
-c           | Sort the "converged" Ritz values again so that   |
-c           | the "threshold" values and their associated Ritz |
-c           | estimates appear at the appropriate position in  |
-c           | ritz and bound.                                  |
-c           %--------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %------------------------------------------------%
-c              | Sort the "converged" Ritz values in increasing |
-c              | order.  The "threshold" values are in the      |
-c              | middle.                                        |
-c              %------------------------------------------------%
-c
-               wprime = 'LA'
-               call dsortr(wprime, .true., nconv, ritz, bounds)
-c
-            else
-c
-c              %----------------------------------------------%
-c              | In LM, SM, LA, SA case, sort the "converged" |
-c              | Ritz values according to WHICH so that the   |
-c              | "threshold" value appears at the front of    |
-c              | ritz.                                        |
-c              %----------------------------------------------%
-
-               call dsortr(which, .true., nconv, ritz, bounds)
-c
-            end if
-c
-c           %------------------------------------------%
-c           |  Use h( 1,1 ) as storage to communicate  |
-c           |  rnorm to _seupd if needed               |
-c           %------------------------------------------%
-c
-            h(1,1) = rnorm
-c
-            if (msglvl .gt. 1) then
-               call dvout (logfil, kplusp, ritz, ndigit,
-     &            '_saup2: Sorted Ritz values.')
-               call dvout (logfil, kplusp, bounds, ndigit,
-     &            '_saup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if (nconv .lt. nev .and. ishift .eq. 1) then
-c
-c           %---------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.    |
-c           | To prevent possible stagnation, adjust the number |
-c           | of Ritz values and the shifts.                    |
-c           %---------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min (nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 2) then
-               nev = 2
-            end if
-            np  = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call dsgets (ishift, which, nev, np, ritz, bounds,
-     &              workl)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [nconv], ndigit,
-     &           '_saup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_saup2: NEV and NP are')
-               call dvout (logfil, nev, ritz(np+1), ndigit,
-     &              '_saup2: "wanted" Ritz values.')
-               call dvout (logfil, nev, bounds(np+1), ndigit,
-     &              '_saup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-
-c
-         if (ishift .eq. 0) then
-c
-c           %-----------------------------------------------------%
-c           | User specified shifts: reverse communication to     |
-c           | compute the shifts. They are returned in the first  |
-c           | NP locations of WORKL.                              |
-c           %-----------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-c
-c        %---------------------------------------------------------%
-c        | Move the NP shifts to the first NP locations of RITZ to |
-c        | free up WORKL.  This is for the non-exact shift case;   |
-c        | in the exact shift case, dsgets already handles this.   |
-c        %---------------------------------------------------------%
-c
-         if (ishift .eq. 0) call dcopy (np, workl, 1, ritz, 1)
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [np], ndigit,
-     &                  '_saup2: The number of shifts to apply ')
-            call dvout (logfil, np, workl, ndigit,
-     &                  '_saup2: shifts selected')
-            if (ishift .eq. 1) then
-               call dvout (logfil, np, bounds, ndigit,
-     &                  '_saup2: corresponding Ritz estimates')
-             end if
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP0 implicit shifts by QR bulge chasing.      |
-c        | Each shift is applied to the entire tridiagonal matrix. |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        | After dsapps is done, we have a Lanczos                 |
-c        | factorization of length NEV.                            |
-c        %---------------------------------------------------------%
-c
-         call dsapps (n, nev, np, ritz, v, ldv, h, ldh, resid, q, ldq,
-     &        workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to dsaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call dcopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call dcopy (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = ddot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = dnrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-  130    continue
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, 1, [rnorm], ndigit,
-     &      '_saup2: B-norm of residual for NEV factorization')
-            call dvout (logfil, nev, h(1,2), ndigit,
-     &           '_saup2: main diagonal of compressed H matrix')
-            call dvout (logfil, nev-1, h(2,1), ndigit,
-     &           '_saup2: subdiagonal of compressed H matrix')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tsaup2 = t1 - t0
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsaup2 |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaupd.f
deleted file mode 100644
index 81a0ce52cc..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsaupd.f
+++ /dev/null
@@ -1,690 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsaupd
-c
-c\Description:
-c
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  Iteration.  For symmetric problems this reduces to a variant of the Lanczos
-c  method.  This method has been designed to compute approximations to a
-c  few eigenpairs of a linear operator OP that is real and symmetric
-c  with respect to a real positive semi-definite symmetric matrix B,
-c  i.e.
-c
-c       B*OP = (OP`)*B.
-c
-c  Another way to express this condition is
-c
-c       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
-c
-c  In the standard eigenproblem B is the identity matrix.
-c  ( A` denotes transpose of A)
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  dsaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x, A symmetric
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
-c           ===> OP = (inv[K - sigma*M])*M  and  B = M.
-c           ===> Shift-and-Invert mode
-c
-c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,
-c           KG symmetric indefinite
-c           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
-c           ===> Buckling mode
-c
-c  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
-c           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c           ===> Cayley transformed mode
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call dsaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to dsaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          dsaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          (If Mode = 2 see remark 5 below)
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3,4 and 5, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) shifts where
-c                    IPNTR(11) is the pointer into WORKL for
-c                    placing the shifts. See remark 6 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Specify which of the Ritz values of OP to compute.
-c
-c          'LA' - compute the NEV largest (algebraic) eigenvalues.
-c          'SA' - compute the NEV smallest (algebraic) eigenvalues.
-c          'LM' - compute the NEV largest (in magnitude) eigenvalues.
-c          'SM' - compute the NEV smallest (in magnitude) eigenvalues.
-c          'BE' - compute NEV eigenvalues, half from each end of the
-c                 spectrum.  When NEV is odd, compute one more from the
-c                 high end than from the low end.
-c           (see remark 1 below)
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N.
-c
-c  TOL     Double precision  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
-c          If TOL .LE. 0. is passed a default is set:
-c          DEFAULT = DLAMCH ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine DLAMCH ).
-c
-c  RESID   Double precision  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V (less than or equal to N).
-c          This will indicate how many Lanczos vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Lanczos vectors are generated, the algorithm generates
-c          NCV-NEV Lanczos vectors at each subsequent update iteration.
-c          Most of the cost in generating each Lanczos vector is in the
-c          matrix-vector product OP*x. (See remark 4 below).
-c
-c  V       Double precision  N by NCV array.  (OUTPUT)
-c          The NCV columns of V contain the Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the current tridiagonal matrix T are returned in
-c                      the part of WORKL array corresponding to RITZ.
-c                      See remark 6 below.
-c          ISHIFT = 1: exact shifts with respect to the reduced
-c                      tridiagonal matrix T.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of Ritz vectors
-c                      associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = LEVEC
-c          No longer referenced. See remark 2 below.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4,5; See under \Description of dsaupd  for the
-c          five modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), dsaupd  returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          6 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 11.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
-c          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
-c          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZ in WORKL.
-c          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.
-c
-c          Note: IPNTR(8:10) is only referenced by dseupd . See Remark 2.
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     dseupd  if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  WORKD   Double precision  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
-c          subroutine dseupd  uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least NCV**2 + 8*NCV .
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iterations allowed
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array WORKL is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Informatinal error from LAPACK routine dsteqr .
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -13: NEV and WHICH = 'BE' are incompatible.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization. The user is advised to check that
-c                   enough workspace and array storage has been allocated.
-c
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in ascending
-c     algebraic order.  The computed Ritz values are approximate
-c     eigenvalues of OP.  The selection of WHICH should be made
-c     with this in mind when Mode = 3,4,5.  After convergence,
-c     approximate eigenvalues of the original problem may be obtained
-c     with the ARPACK subroutine dseupd .
-c
-c  2. If the Ritz vectors corresponding to the converged Ritz values
-c     are needed, the user must call dseupd  immediately following completion
-c     of dsaupd . This is new starting with version 2.1 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.   The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c
-c  5. If IPARAM(7) = 2 then in the Reverse communication interface the user
-c     must do the following. When IDO = 1, Y = OP * X is to be computed.
-c     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
-c     must overwrite X with A*X. Y is then the solution to the linear set
-c     of equations B*Y = A*X.
-c
-c  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) shifts in locations:
-c     1   WORKL(IPNTR(11))
-c     2   WORKL(IPNTR(11)+1)
-c                        .
-c                        .
-c                        .
-c     NP  WORKL(IPNTR(11)+NP-1).
-c
-c     The eigenvalues of the current tridiagonal matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
-c     order defined by WHICH. The associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
-c  DECOMPOSE  D1(N), D2(N,NCV)
-c  ALIGN      RESID(I) with D1(I)
-c  ALIGN      V(I,J)   with D2(I,J)
-c  ALIGN      WORKD(I) with D1(I)     range (1:N)
-c  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
-c  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
-c  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c  Cray MPP syntax:
-c  ===============
-c  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
-c  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
-c     Transformations in a k-Step Arnoldi Method". In Preparation.
-c
-c\Routines called:
-c     dsaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     dstats   ARPACK routine that initialize timing and other statistics
-c             variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(11)
-      Double precision
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dsaup2 ,  dvout , ivout, arscnd, dstats
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call dstats
-         call arscnd (t0)
-         msglvl = msaupd
-c
-         ierr   = 0
-         ishift = iparam(1)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         if (n .le. 0) then
-            ierr = -1
-         else if (nev .le. 0) then
-            ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-            ierr = -3
-         end if
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-c
-         if (mxiter .le. 0)                     ierr = -4
-         if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LA' .and.
-     &       which .ne. 'SA' .and.
-     &       which .ne. 'BE')                   ierr = -5
-         if (bmat .ne. 'I' .and. bmat .ne. 'G') ierr = -6
-c
-         if (lworkl .lt. ncv**2 + 8*ncv)        ierr = -7
-         if (mode .lt. 1 .or. mode .gt. 5) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         else if (nev .eq. 1 .and. which .eq. 'BE') then
-                                                ierr = -13
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)                         nb = 1
-         if (tol .le. zero)                     tol = dlamch ('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, ncv**2 + 8*ncv
-            workl(j) = zero
- 10      continue
-c
-c        %-------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c        | etc... and the remaining workspace.                   |
-c        | Also update pointer to be used on output.             |
-c        | Memory is laid out as follows:                        |
-c        | workl(1:2*ncv) := generated tridiagonal matrix        |
-c        | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c        | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |
-c        | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |
-c        | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |
-c        %-------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + 2*ldh
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ncv**2
-         next   = iw     + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = bounds
-         ipntr(11) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Lanczos Iteration. |
-c     %-------------------------------------------------------%
-c
-      call dsaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw), ipntr, workd,
-     &     info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within dsaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [mxiter], ndigit,
-     &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, [np], ndigit,
-     &               '_saupd: number of "converged" Ritz values')
-         call dvout  (logfil, np, workl(Ritz), ndigit,
-     &               '_saupd: final Ritz values')
-         call dvout  (logfil, np, workl(Bounds), ndigit,
-     &               '_saupd: corresponding error bounds')
-      end if
-c
-      call arscnd (t1)
-      tsaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tsaupd, tsaup2, tsaitr, titref,
-     &                  tgetv0, tseigt, tsgets, tsapps, tsconv
- 1000    format (//,
-     &      5x, '==========================================',/
-     &      5x, '= Symmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number:', ' 2.4' , 19x, ' =',/
-     &      5x, '= Version Date:  ', ' 07/31/96' , 14x, ' =',/
-     &      5x, '==========================================',/
-     &      5x, '= Summary of timing statistics           =',/
-     &      5x, '==========================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in saup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in trid eigenvalue subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dsaupd  |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsconv.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsconv.f
deleted file mode 100644
index 82dbb6e611..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsconv.f
+++ /dev/null
@@ -1,138 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsconv
-c
-c\Description:
-c  Convergence testing for the symmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call dsconv
-c     ( N, RITZ, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZ    Double precision array of length N.  (INPUT)
-c          The Ritz values to be checked for convergence.
-c
-c  BOUNDS  Double precision array of length N.  (INPUT)
-c          Ritz estimates associated with the Ritz values in RITZ.
-c
-c  TOL     Double precision scalar.  (INPUT)
-c          Desired relative accuracy for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.4, this routine no longer uses the
-c        Parlett strategy using the gap conditions.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsconv (n, ritz, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           ritz(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Double precision
-     &           temp, eps23
-c
-c     %-------------------%
-c     | External routines |
-c     %-------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      call arscnd (t0)
-c
-      eps23 = dlamch('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-      nconv  = 0
-      do 10 i = 1, n
-c
-c        %-----------------------------------------------------%
-c        | The i-th Ritz value is considered "converged"       |
-c        | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |
-c        %-----------------------------------------------------%
-c
-         temp = max( eps23, abs(ritz(i)) )
-         if ( bounds(i) .le. tol*temp ) then
-            nconv = nconv + 1
-         end if
-c
-   10 continue
-c
-      call arscnd (t1)
-      tsconv = tsconv + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of dsconv |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseigt.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseigt.f
deleted file mode 100644
index 5e20c805bf..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseigt.f
+++ /dev/null
@@ -1,181 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dseigt
-c
-c\Description:
-c  Compute the eigenvalues of the current symmetric tridiagonal matrix
-c  and the corresponding error bounds given the current residual norm.
-c
-c\Usage:
-c  call dseigt
-c     ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          RNORM contains the residual norm corresponding to the current
-c          symmetric tridiagonal matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the symmetric tridiagonal matrix H.
-c
-c  H       Double precision N by 2 array.  (INPUT)
-c          H contains the symmetric tridiagonal matrix with the
-c          subdiagonal in the first column starting at H(2,1) and the
-c          main diagonal in second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  EIG     Double precision array of length N.  (OUTPUT)
-c          On output, EIG contains the N eigenvalues of H possibly
-c          unsorted.  The BOUNDS arrays are returned in the
-c          same sorted order as EIG.
-c
-c  BOUNDS  Double precision array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the error estimates corresponding
-c          to the eigenvalues EIG.  This is equal to RNORM times the
-c          last components of the eigenvectors corresponding to the
-c          eigenvalues in EIG.
-c
-c  WORKL   Double precision work array of length 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from dstqrb.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dstqrb  ARPACK routine that computes the eigenvalues and the
-c             last components of the eigenvectors of a symmetric
-c             and tridiagonal matrix.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dseigt
-     &   ( rnorm, n, h, ldh, eig, bounds, workl, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, ldh, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           eig(n), bounds(n), h(ldh,2), workl(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           zero
-      parameter (zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, k, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy, dstqrb, dvout, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mseigt
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, n, h(1,2), ndigit,
-     &              '_seigt: main diagonal of matrix H')
-         if (n .gt. 1) then
-         call dvout (logfil, n-1, h(2,1), ndigit,
-     &              '_seigt: sub diagonal of matrix H')
-         end if
-      end if
-c
-      call dcopy  (n, h(1,2), 1, eig, 1)
-      call dcopy  (n-1, h(2,1), 1, workl, 1)
-      call dstqrb (n, eig, workl, bounds, workl(n+1), ierr)
-      if (ierr .ne. 0) go to 9000
-      if (msglvl .gt. 1) then
-         call dvout (logfil, n, bounds, ndigit,
-     &              '_seigt: last row of the eigenvector matrix for H')
-      end if
-c
-c     %-----------------------------------------------%
-c     | Finally determine the error bounds associated |
-c     | with the n Ritz values of H.                  |
-c     %-----------------------------------------------%
-c
-      do 30 k = 1, n
-         bounds(k) = rnorm*abs(bounds(k))
-   30 continue
-c
-      call arscnd (t1)
-      tseigt = tseigt + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dseigt |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsesrt.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsesrt.f
deleted file mode 100644
index 833fba4e6c..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsesrt.f
+++ /dev/null
@@ -1,217 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsesrt
-c
-c\Description:
-c  Sort the array X in the order specified by WHICH and optionally
-c  apply the permutation to the columns of the matrix A.
-c
-c\Usage:
-c  call dsesrt
-c     ( WHICH, APPLY, N, X, NA, A, LDA)
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X is sorted into increasing order of magnitude.
-c          'SM' -> X is sorted into decreasing order of magnitude.
-c          'LA' -> X is sorted into increasing order of algebraic.
-c          'SA' -> X is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to A.
-c          APPLY = .FALSE. -> do not apply the sorted order to A.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the array X.
-c
-c  X      Double precision array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  NA      Integer.  (INPUT)
-c          Number of rows of the matrix A.
-c
-c  A      Double precision array of length NA by N.  (INPUT/OUTPUT)
-c
-c  LDA     Integer.  (INPUT)
-c          Leading dimension of A.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines
-c     dswap  Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO and
-c               the ARPACK code dsortr
-c
-c\SCCS Information: @(#)
-c FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsesrt (which, apply, n, x, na, a, lda)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    lda, n, na
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           x(0:n-1), a(lda, 0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dswap
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'SA') then
-c
-c        X is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x(j).lt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x(j)).lt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (x(j).gt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'LM') then
-c
-c        X is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x(j)).gt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call dswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsesrt |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseupd.f
deleted file mode 100644
index ae123a207e..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dseupd.f
+++ /dev/null
@@ -1,867 +0,0 @@
-c\BeginDoc
-c
-c\Name: dseupd
-c
-c\Description:
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) the corresponding approximate eigenvectors,
-c
-c      (2) an orthonormal (Lanczos) basis for the associated approximate
-c          invariant subspace,
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  (Lanczos) basis is always computed.  There is an additional storage cost
-c  of n*nev if both are requested (in this case a separate array Z must be
-c  supplied).
-c
-c  These quantities are obtained from the Lanczos factorization computed
-c  by DSAUPD  for the linear operator OP prescribed by the MODE selection
-c  (see IPARAM(7) in DSAUPD  documentation.)  DSAUPD  must be called before
-c  this routine is called. These approximate eigenvalues and vectors are
-c  commonly called Ritz values and Ritz vectors respectively.  They are
-c  referred to as such in the comments that follow.   The computed orthonormal
-c  basis for the invariant subspace corresponding to these Ritz values is
-c  referred to as a Lanczos basis.
-c
-c  See documentation in the header of the subroutine DSAUPD  for a definition
-c  of OP as well as other terms and the relation of computed Ritz values
-c  and vectors of OP with respect to the given problem  A*z = lambda*B*z.
-c
-c  The approximate eigenvalues of the original problem are returned in
-c  ascending algebraic order.  The user may elect to call this routine
-c  once for each desired Ritz vector and store it peripherally if desired.
-c  There is also the option of computing a selected set of these vectors
-c  with a single call.
-c
-c\Usage:
-c  call dseupd
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,
-c       RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether Ritz vectors corresponding to the Ritz value
-c          approximations to the eigenproblem A*z = lambda*B*z are computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies how many Ritz vectors are wanted and the form of Z
-c          the matrix of Ritz vectors. See remark 1 below.
-c          = 'A': compute NEV Ritz vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE..
-c          If HOWMNY = 'A' , SELECT is used as a workspace for
-c          reordering the Ritz values.
-c
-c  D       Double precision  array of dimension NEV.  (OUTPUT)
-c          On exit, D contains the Ritz value approximations to the
-c          eigenvalues of A*z = lambda*B*z. The values are returned
-c          in ascending order. If IPARAM(7) = 3,4,5 then D represents
-c          the Ritz values of OP computed by dsaupd  transformed to
-c          those of the original eigensystem A*z = lambda*B*z. If
-c          IPARAM(7) = 1,2 then the Ritz values of OP are the same
-c          as the those of A*z = lambda*B*z.
-c
-c  Z       Double precision  N by NEV array if HOWMNY = 'A'.  (OUTPUT)
-c          On exit, Z contains the B-orthonormal Ritz vectors of the
-c          eigensystem A*z = lambda*B*z corresponding to the Ritz
-c          value approximations.
-c          If  RVEC = .FALSE. then Z is not referenced.
-c          NOTE: The array Z may be set equal to first NEV columns of the
-c          Arnoldi/Lanczos basis array V computed by DSAUPD .
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.
-c
-c  SIGMA   Double precision   (INPUT)
-c          If IPARAM(7) = 3,4,5 represents the shift. Not referenced if
-c          IPARAM(7) = 1 or 2.
-c
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to DSAUPD  that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to DSEUPD  following the last call
-c         to DSAUPD .  These arguments MUST NOT BE MODIFIED between
-c         the the last call to DSAUPD  and the call to DSEUPD .
-c
-c  Two of these parameters (WORKL, INFO) are also output parameters:
-c
-c  WORKL   Double precision  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:4*ncv) contains information obtained in
-c          dsaupd .  They are not changed by dseupd .
-c          WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the
-c          untransformed Ritz values, the computed error estimates,
-c          and the associated eigenvector matrix of H.
-c
-c          Note: IPNTR(8:10) contains the pointer into WORKL for addresses
-c          of the above information computed by dseupd .
-c          -------------------------------------------------------------
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     dseupd  if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Information error from LAPACK routine dsteqr .
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: NEV and WHICH = 'BE' are incompatible.
-c          = -14: DSAUPD  did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.
-c          = -16: HOWMNY = 'S' not yet implemented
-c          = -17: DSEUPD  got a different count of the number of converged
-c                 Ritz values than DSAUPD  got.  This indicates the user
-c                 probably made an error in passing data from DSAUPD  to
-c                 DSEUPD  or that the data was modified before entering
-c                 DSEUPD .
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in increasing
-c     (algebraic) order.
-c
-c  2. Currently only HOWMNY = 'A' is implemented. It is included at this
-c     stage for the user who wants to incorporate it.
-c
-c\Routines called:
-c     dsesrt   ARPACK routine that sorts an array X, and applies the
-c             corresponding permutation to a matrix A.
-c     dsortr   dsortr   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dgeqr2   LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     dlacpy   LAPACK matrix copy routine.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dorm2r   LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     dsteqr   LAPACK routine that computes eigenvalues and eigenvectors
-c             of a tridiagonal matrix.
-c     dger     Level 2 BLAS rank one update to a matrix.
-c     dcopy    Level 1 BLAS that copies one vector to another .
-c     dnrm2    Level 1 BLAS that computes the norm of a vector.
-c     dscal    Level 1 BLAS that scales a vector.
-c     dswap    Level 1 BLAS that swaps the contents of two vectors.
-
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: seupd.F   SID: 2.11   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine dseupd (rvec  , howmny, select, d    ,
-     &                   z     , ldz   , sigma , bmat ,
-     &                   n     , which , nev   , tol  ,
-     &                   resid , ncv   , v     , ldv  ,
-     &                   iparam, ipntr , workd , workl,
-     &                   lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           sigma, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(7), ipntr(11)
-      logical    select(ncv)
-      Double precision
-     &           d(nev)     , resid(n)  , v(ldv,ncv),
-     &           z(ldz, nev), workd(2*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0 , zero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds , ierr   , ih    , ihb   , ihd   ,
-     &           iq     , iw     , j     , k     , ldh   ,
-     &           ldq    , mode   , msglvl, nconv , next  ,
-     &           ritz   , irz    , ibd   , np    , ishift,
-     &           leftptr, rghtptr, numcnv, jj
-      Double precision
-     &           bnorm2 , rnorm, temp, temp1, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dcopy  , dger   , dgeqr2 , dlacpy , dorm2r , dscal ,
-     &           dsesrt , dsteqr , dswap  , dvout  , ivout , dsortr
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dnrm2 , dlamch
-      external   dnrm2 , dlamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mseupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      if (nconv .eq. 0) go to 9000
-      ierr = 0
-c
-      if (nconv .le. 0)                        ierr = -14
-      if (n .le. 0)                            ierr = -1
-      if (nev .le. 0)                          ierr = -2
-      if (ncv .le. nev .or.  ncv .gt. n)       ierr = -3
-      if (which .ne. 'LM' .and.
-     &    which .ne. 'SM' .and.
-     &    which .ne. 'LA' .and.
-     &    which .ne. 'SA' .and.
-     &    which .ne. 'BE')                     ierr = -5
-      if (bmat .ne. 'I' .and. bmat .ne. 'G')   ierr = -6
-      if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec )
-     &                                         ierr = -15
-      if (rvec .and. howmny .eq. 'S')           ierr = -16
-c
-      if (rvec .and. lworkl .lt. ncv**2+8*ncv) ierr = -7
-c
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else if (mode .eq. 4 ) then
-         type = 'BUCKLE'
-      else if (mode .eq. 5 ) then
-         type = 'CAYLEY'
-      else
-                                               ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')     ierr = -11
-      if (nev .eq. 1 .and. which .eq. 'BE')    ierr = -12
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c     | etc... and the remaining workspace.                   |
-c     | Also update pointer to be used on output.             |
-c     | Memory is laid out as follows:                        |
-c     | workl(1:2*ncv) := generated tridiagonal matrix H      |
-c     |       The subdiagonal is stored in workl(2:ncv).      |
-c     |       The dead spot is workl(1) but upon exiting      |
-c     |       dsaupd  stores the B-norm of the last residual   |
-c     |       vector in workl(1). We use this !!!             |
-c     | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c     |       The wanted values are in the first NCONV spots. |
-c     | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |
-c     |       The wanted values are in the first NCONV spots. |
-c     | NOTE: workl(1:4*ncv) is set by dsaupd  and is not      |
-c     |       modified by dseupd .                             |
-c     %-------------------------------------------------------%
-c
-c     %-------------------------------------------------------%
-c     | The following is used and set by dseupd .              |
-c     | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the diagonal of H. Upon EXIT contains the NCV   |
-c     |       Ritz values of the original system. The first   |
-c     |       NCONV spots have the wanted values. If MODE =   |
-c     |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |
-c     | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the subdiagonal of H. Upon EXIT contains the    |
-c     |       NCV corresponding Ritz estimates of the         |
-c     |       original system. The first NCONV spots have the |
-c     |       wanted values. If MODE = 1,2 then will equal    |
-c     |       workl(3*ncv+1:4*ncv).                           |
-c     | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |
-c     |       the eigenvector matrix for H as returned by     |
-c     |       dsteqr . Not referenced if RVEC = .False.        |
-c     |       Ordering follows that of workl(4*ncv+1:5*ncv)   |
-c     | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |
-c     |       Workspace. Needed by dsteqr  and by dseupd .      |
-c     | GRAND total of NCV*(NCV+8) locations.                 |
-c     %-------------------------------------------------------%
-c
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      bounds = ipntr(7)
-      ldh    = ncv
-      ldq    = ncv
-      ihd    = bounds + ldh
-      ihb    = ihd    + ldh
-      iq     = ihb    + ldh
-      iw     = iq     + ldh*ncv
-      next   = iw     + 2*ncv
-      ipntr(4)  = next
-      ipntr(8)  = ihd
-      ipntr(9)  = ihb
-      ipntr(10) = iq
-c
-c     %----------------------------------------%
-c     | irz points to the Ritz values computed |
-c     |     by _seigt before exiting _saup2.   |
-c     | ibd points to the Ritz estimates       |
-c     |     computed by _seigt before exiting  |
-c     |     _saup2.                            |
-c     %----------------------------------------%
-c
-      irz = ipntr(11)+ncv
-      ibd = irz+ncv
-c
-c
-c     %---------------------------------%
-c     | Set machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch ('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c     %---------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N).    |
-c     | BNORM2 is the 2 norm of B*RESID(1:N). |
-c     | Upon exit of dsaupd  WORKD(1:N) has    |
-c     | B*RESID(1:N).                         |
-c     %---------------------------------------%
-c
-      rnorm = workl(ih)
-      if (bmat .eq. 'I') then
-         bnorm2 = rnorm
-      else if (bmat .eq. 'G') then
-         bnorm2 = dnrm2 (n, workd, 1)
-      end if
-c
-      if (msglvl .gt. 2) then
-         call dvout (logfil, ncv, workl(irz), ndigit,
-     &   '_seupd: Ritz values passed in from _SAUPD.')
-         call dvout (logfil, ncv, workl(ibd), ndigit,
-     &   '_seupd: Ritz estimates passed in from _SAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call dsgets (ishift, which       , nev          ,
-     &                np    , workl(irz)  , workl(bounds),
-     &                workl)
-c
-         if (msglvl .gt. 2) then
-            call dvout (logfil, ncv, workl(irz), ndigit,
-     &      '_seupd: Ritz values after calling _SGETS.')
-            call dvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_seupd: Ritz value indices after calling _SGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23, abs(workl(irz+ncv-j)) )
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nconv) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by _saupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the _saupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, [numcnv], ndigit,
-     &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, [nconv], ndigit,
-     &            '_seupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -17
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine _steqr to compute the eigenvalues and |
-c        | eigenvectors of the final symmetric tridiagonal matrix H. |
-c        | Initialize the eigenvector matrix Q to the identity.      |
-c        %-----------------------------------------------------------%
-c
-         call dcopy (ncv-1, workl(ih+1), 1, workl(ihb), 1)
-         call dcopy (ncv, workl(ih+ldh), 1, workl(ihd), 1)
-c
-         call dsteqr ('Identity', ncv, workl(ihd), workl(ihb),
-     &                workl(iq) , ldq, workl(iw), ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call dcopy (ncv, workl(iq+ncv-1), ldq, workl(iw), 1)
-            call dvout (logfil, ncv, workl(ihd), ndigit,
-     &          '_seupd: NCV Ritz values of the final H matrix')
-            call dvout (logfil, ncv, workl(iw), ndigit,
-     &           '_seupd: last row of the eigenvector matrix for H')
-         end if
-c
-         if (reord) then
-c
-c           %---------------------------------------------%
-c           | Reordered the eigenvalues and eigenvectors  |
-c           | computed by _steqr so that the "converged"  |
-c           | eigenvalues appear in the first NCONV       |
-c           | positions of workl(ihd), and the associated |
-c           | eigenvectors appear in the first NCONV      |
-c           | columns.                                    |
-c           %---------------------------------------------%
-c
-            leftptr = 1
-            rghtptr = ncv
-c
-            if (ncv .eq. 1) go to 30
-c
- 20         if (select(leftptr)) then
-c
-c              %-------------------------------------------%
-c              | Search, from the left, for the first Ritz |
-c              | value that has not converged.             |
-c              %-------------------------------------------%
-c
-               leftptr = leftptr + 1
-c
-            else if ( .not. select(rghtptr)) then
-c
-c              %----------------------------------------------%
-c              | Search, from the right, the first Ritz value |
-c              | that has converged.                          |
-c              %----------------------------------------------%
-c
-               rghtptr = rghtptr - 1
-c
-            else
-c
-c              %----------------------------------------------%
-c              | Swap the Ritz value on the left that has not |
-c              | converged with the Ritz value on the right   |
-c              | that has converged.  Swap the associated     |
-c              | eigenvector of the tridiagonal matrix H as   |
-c              | well.                                        |
-c              %----------------------------------------------%
-c
-               temp = workl(ihd+leftptr-1)
-               workl(ihd+leftptr-1) = workl(ihd+rghtptr-1)
-               workl(ihd+rghtptr-1) = temp
-               call dcopy (ncv, workl(iq+ncv*(leftptr-1)), 1,
-     &                    workl(iw), 1)
-               call dcopy (ncv, workl(iq+ncv*(rghtptr-1)), 1,
-     &                    workl(iq+ncv*(leftptr-1)), 1)
-               call dcopy (ncv, workl(iw), 1,
-     &                    workl(iq+ncv*(rghtptr-1)), 1)
-               leftptr = leftptr + 1
-               rghtptr = rghtptr - 1
-c
-            end if
-c
-            if (leftptr .lt. rghtptr) go to 20
-c
-          end if
-c
-  30      if (msglvl .gt. 2) then
-             call dvout  (logfil, ncv, workl(ihd), ndigit,
-     &       '_seupd: The eigenvalues of H--reordered')
-         end if
-c
-c        %----------------------------------------%
-c        | Load the converged Ritz values into D. |
-c        %----------------------------------------%
-c
-         call dcopy (nconv, workl(ihd), 1, d, 1)
-c
-      else
-c
-c        %-----------------------------------------------------%
-c        | Ritz vectors not required. Load Ritz values into D. |
-c        %-----------------------------------------------------%
-c
-         call dcopy (nconv, workl(ritz), 1, d, 1)
-         call dcopy (ncv, workl(ritz), 1, workl(ihd), 1)
-c
-      end if
-c
-c     %------------------------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors and corresponding |
-c     | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |
-c     | (and corresponding data) are returned in ascending order.        |
-c     %------------------------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-c        %---------------------------------------------------------%
-c        | Ascending sort of wanted Ritz values, vectors and error |
-c        | bounds. Not necessary if only Ritz values are desired.  |
-c        %---------------------------------------------------------%
-c
-         if (rvec) then
-            call dsesrt ('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call dcopy (ncv, workl(bounds), 1, workl(ihb), 1)
-         end if
-c
-      else
-c
-c        %-------------------------------------------------------------%
-c        | *  Make a copy of all the Ritz values.                      |
-c        | *  Transform the Ritz values back to the original system.   |
-c        |    For TYPE = 'SHIFTI' the transformation is                |
-c        |             lambda = 1/theta + sigma                        |
-c        |    For TYPE = 'BUCKLE' the transformation is                |
-c        |             lambda = sigma * theta / ( theta - 1 )          |
-c        |    For TYPE = 'CAYLEY' the transformation is                |
-c        |             lambda = sigma * (theta + 1) / (theta - 1 )     |
-c        |    where the theta are the Ritz values returned by dsaupd .  |
-c        | NOTES:                                                      |
-c        | *The Ritz vectors are not affected by the transformation.   |
-c        |  They are only reordered.                                   |
-c        %-------------------------------------------------------------%
-c
-         call dcopy  (ncv, workl(ihd), 1, workl(iw), 1)
-         if (type .eq. 'SHIFTI') then
-            do 40 k=1, ncv
-               workl(ihd+k-1) = one / workl(ihd+k-1) + sigma
-  40        continue
-         else if (type .eq. 'BUCKLE') then
-            do 50 k=1, ncv
-               workl(ihd+k-1) = sigma * workl(ihd+k-1) /
-     &                          (workl(ihd+k-1) - one)
-  50        continue
-         else if (type .eq. 'CAYLEY') then
-            do 60 k=1, ncv
-               workl(ihd+k-1) = sigma * (workl(ihd+k-1) + one) /
-     &                          (workl(ihd+k-1) - one)
-  60        continue
-         end if
-c
-c        %-------------------------------------------------------------%
-c        | *  Store the wanted NCONV lambda values into D.             |
-c        | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |
-c        |    into ascending order and apply sort to the NCONV theta   |
-c        |    values in the transformed system. We will need this to   |
-c        |    compute Ritz estimates in the original system.           |
-c        | *  Finally sort the lambda`s into ascending order and apply |
-c        |    to Ritz vectors if wanted. Else just sort lambda`s into  |
-c        |    ascending order.                                         |
-c        | NOTES:                                                      |
-c        | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |
-c        |  match the ordering of the lambda. We`ll use them again for |
-c        |  Ritz vector purification.                                  |
-c        %-------------------------------------------------------------%
-c
-         call dcopy (nconv, workl(ihd), 1, d, 1)
-         call dsortr ('LA', .true., nconv, workl(ihd), workl(iw))
-         if (rvec) then
-            call dsesrt ('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call dcopy (ncv, workl(bounds), 1, workl(ihb), 1)
-            call dscal (ncv, bnorm2/rnorm, workl(ihb), 1)
-            call dsortr ('LA', .true., nconv, d, workl(ihb))
-         end if
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Compute the Ritz vectors. Transform the wanted |
-c     | eigenvectors of the symmetric tridiagonal H by |
-c     | the Lanczos basis matrix V.                    |
-c     %------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A') then
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(iq,ldq).                                |
-c        %----------------------------------------------------------%
-c
-         call dgeqr2 (ncv, nconv        , workl(iq) ,
-     &                ldq, workl(iw+ncv), workl(ihb),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q.                                 |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(ihd).                         |
-c        %--------------------------------------------------------%
-c
-         call dorm2r ('Right', 'Notranspose', n        ,
-     &                ncv    , nconv        , workl(iq),
-     &                ldq    , workl(iw+ncv), v        ,
-     &                ldv    , workd(n+1)   , ierr)
-         call dlacpy ('All', n, nconv, v, ldv, z, ldz)
-c
-c        %-----------------------------------------------------%
-c        | In order to compute the Ritz estimates for the Ritz |
-c        | values in both systems, need the last row of the    |
-c        | eigenvector matrix. Remember, it`s in factored form |
-c        %-----------------------------------------------------%
-c
-         do 65 j = 1, ncv-1
-            workl(ihb+j-1) = zero
-  65     continue
-         workl(ihb+ncv-1) = one
-         call dorm2r ('Left', 'Transpose'  , ncv       ,
-     &                1     , nconv        , workl(iq) ,
-     &                ldq   , workl(iw+ncv), workl(ihb),
-     &                ncv   , temp         , ierr)
-c
-c        %-----------------------------------------------------%
-c        | Make a copy of the last row into                    |
-c        | workl(iw+ncv:iw+2*ncv), as it is needed again in    |
-c        | the Ritz vector purification step below             |
-c        %-----------------------------------------------------%
-c
-         do 67 j = 1, nconv
-            workl(iw+ncv+j-1) = workl(ihb+j-1)
- 67      continue
-
-      else if (rvec .and. howmny .eq. 'S') then
-c
-c     Not yet implemented. See remark 2 above.
-c
-      end if
-c
-      if (type .eq. 'REGULR' .and. rvec) then
-c
-            do 70 j=1, ncv
-               workl(ihb+j-1) = rnorm * abs( workl(ihb+j-1) )
- 70         continue
-c
-      else if (type .ne. 'REGULR' .and. rvec) then
-c
-c        %-------------------------------------------------%
-c        | *  Determine Ritz estimates of the theta.       |
-c        |    If RVEC = .true. then compute Ritz estimates |
-c        |               of the theta.                     |
-c        |    If RVEC = .false. then copy Ritz estimates   |
-c        |              as computed by dsaupd .             |
-c        | *  Determine Ritz estimates of the lambda.      |
-c        %-------------------------------------------------%
-c
-         call dscal  (ncv, bnorm2, workl(ihb), 1)
-         if (type .eq. 'SHIFTI') then
-c
-            do 80 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1) )
-     &                        / workl(iw+k-1)**2
- 80         continue
-c
-         else if (type .eq. 'BUCKLE') then
-c
-            do 90 k=1, ncv
-               workl(ihb+k-1) = sigma * abs( workl(ihb+k-1) )
-     &                        / (workl(iw+k-1)-one )**2
- 90         continue
-c
-         else if (type .eq. 'CAYLEY') then
-c
-            do 100 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1)
-     &                        / workl(iw+k-1)*(workl(iw+k-1)-one) )
- 100        continue
-c
-         end if
-c
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call dvout (logfil, nconv, d, ndigit,
-     &          '_seupd: Untransformed converged Ritz values')
-         call dvout (logfil, nconv, workl(ihb), ndigit,
-     &     '_seupd: Ritz estimates of the untransformed Ritz values')
-      else if (msglvl .gt. 1) then
-         call dvout (logfil, nconv, d, ndigit,
-     &          '_seupd: Converged Ritz values')
-         call dvout (logfil, nconv, workl(ihb), ndigit,
-     &     '_seupd: Associated Ritz estimates')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Ritz vector purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3,4,5. See reference 7               |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. (type .eq. 'SHIFTI' .or. type .eq. 'CAYLEY')) then
-c
-         do 110 k=0, nconv-1
-            workl(iw+k) = workl(iw+ncv+k)
-     &                  / workl(iw+k)
- 110     continue
-c
-      else if (rvec .and. type .eq. 'BUCKLE') then
-c
-         do 120 k=0, nconv-1
-            workl(iw+k) = workl(iw+ncv+k)
-     &                  / (workl(iw+k)-one)
- 120     continue
-c
-      end if
-c
-      if (rvec .and. type .ne. 'REGULR')
-     &   call dger  (n, nconv, one, resid, 1, workl(iw), 1, z, ldz)
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of dseupd |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsgets.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsgets.f
deleted file mode 100644
index 436a4fe848..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsgets.f
+++ /dev/null
@@ -1,219 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsgets
-c
-c\Description:
-c  Given the eigenvalues of the symmetric tridiagonal matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: This is called even in the case of user specified shifts in
-c  order to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call dsgets
-c     ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> KEV eigenvalues of largest magnitude are retained.
-c          'SM' -> KEV eigenvalues of smallest magnitude are retained.
-c          'LA' -> KEV eigenvalues of largest value are retained.
-c          'SA' -> KEV eigenvalues of smallest value are retained.
-c          'BE' -> KEV eigenvalues, half from each end of the spectrum.
-c                  If KEV is odd, compute one more from the high end.
-c
-c  KEV      Integer.  (INPUT)
-c          KEV+NP is the size of the matrix H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be computed.
-c
-c  RITZ    Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted eigenvalues
-c          are in the first NP locations and the wanted part is in
-c          the last KEV locations.  When exact shifts are selected, the
-c          unwanted part corresponds to the shifts to be applied.
-c
-c  BOUNDS  Double precision array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTS  Double precision array of length NP.  (INPUT/OUTPUT)
-c          On INPUT:  contains the user specified shifts if ISHIFT = 0.
-c          On OUTPUT: contains the shifts sorted into decreasing order
-c          of magnitude with respect to the Ritz estimates contained in
-c          BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     dsortr  ARPACK utility sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     dvout   ARPACK utility routine that prints vectors.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dswap   Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsgets ( ishift, which, kev, np, ritz, bounds, shifts )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           bounds(kev+np), ritz(kev+np), shifts(np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Double precision
-     &           one, zero
-      parameter (one = 1.0D+0, zero = 0.0D+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    kevd2, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   dswap, dcopy, dsortr, arscnd
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    max, min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msgets
-c
-      if (which .eq. 'BE') then
-c
-c        %-----------------------------------------------------%
-c        | Both ends of the spectrum are requested.            |
-c        | Sort the eigenvalues into algebraically increasing  |
-c        | order first then swap high end of the spectrum next |
-c        | to low end in appropriate locations.                |
-c        | NOTE: when np < floor(kev/2) be careful not to swap |
-c        | overlapping locations.                              |
-c        %-----------------------------------------------------%
-c
-         call dsortr ('LA', .true., kev+np, ritz, bounds)
-         kevd2 = kev / 2
-         if ( kev .gt. 1 ) then
-            call dswap ( min(kevd2,np), ritz, 1,
-     &                   ritz( max(kevd2,np)+1 ), 1)
-            call dswap ( min(kevd2,np), bounds, 1,
-     &                   bounds( max(kevd2,np)+1 ), 1)
-         end if
-c
-      else
-c
-c        %----------------------------------------------------%
-c        | LM, SM, LA, SA case.                               |
-c        | Sort the eigenvalues of H into the desired order   |
-c        | and apply the resulting order to BOUNDS.           |
-c        | The eigenvalues are sorted so that the wanted part |
-c        | are always in the last KEV locations.               |
-c        %----------------------------------------------------%
-c
-         call dsortr (which, .true., kev+np, ritz, bounds)
-      end if
-c
-      if (ishift .eq. 1 .and. np .gt. 0) then
-c
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first.       |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine dsapps.                     |
-c        %-------------------------------------------------------%
-c
-         call dsortr ('SM', .true., np, bounds, ritz)
-         call dcopy (np, ritz, 1, shifts, 1)
-      end if
-c
-      call arscnd (t1)
-      tsgets = tsgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [kev], ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, [np], ndigit, '_sgets: NP is')
-         call dvout (logfil, kev+np, ritz, ndigit,
-     &        '_sgets: Eigenvalues of current H matrix')
-         call dvout (logfil, kev+np, bounds, ndigit,
-     &        '_sgets: Associated Ritz estimates')
-      end if
-c
-      return
-c
-c     %---------------%
-c     | End of dsgets |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortc.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortc.f
deleted file mode 100644
index 42baae2ba4..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortc.f
+++ /dev/null
@@ -1,344 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsortc
-c
-c\Description:
-c  Sorts the complex array in XREAL and XIMAG into the order
-c  specified by WHICH and optionally applies the permutation to the
-c  real array Y. It is assumed that if an element of XIMAG is
-c  nonzero, then its negative is also an element. In other words,
-c  both members of a complex conjugate pair are to be sorted and the
-c  pairs are kept adjacent to each other.
-c
-c\Usage:
-c  call dsortc
-c     ( WHICH, APPLY, N, XREAL, XIMAG, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort XREAL,XIMAG into increasing order of magnitude.
-c          'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.
-c          'LR' -> sort XREAL into increasing order of algebraic.
-c          'SR' -> sort XREAL into decreasing order of algebraic.
-c          'LI' -> sort XIMAG into increasing order of magnitude.
-c          'SI' -> sort XIMAG into decreasing order of magnitude.
-c          NOTE: If an element of XIMAG is non-zero, then its negative
-c                is also an element.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  XREAL,  Double precision array of length N.  (INPUT/OUTPUT)
-c  XIMAG   Real and imaginary part of the array to be sorted.
-c
-c  Y       Double precision array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsortc (which, apply, n, xreal, ximag, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           xreal(0:n-1), ximag(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp, temp1, temp2
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2
-      external   dlapy2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'LM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = dlapy2(xreal(j),ximag(j))
-            temp2 = dlapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.gt.temp2) then
-                temp = xreal(j)
-                xreal(j) = xreal(j+igap)
-                xreal(j+igap) = temp
-c
-                temp = ximag(j)
-                ximag(j) = ximag(j+igap)
-                ximag(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = dlapy2(xreal(j),ximag(j))
-            temp2 = dlapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.lt.temp2) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (xreal(j).gt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (xreal(j).lt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c
-      else if (which .eq. 'LI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (abs(ximag(j)).gt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c
-      else if (which .eq. 'SI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (abs(ximag(j)).lt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsortc |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortr.f
deleted file mode 100644
index b44f916cf2..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dsortr.f
+++ /dev/null
@@ -1,218 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dsortr
-c
-c\Description:
-c  Sort the array X1 in the order specified by WHICH and optionally
-c  applies the permutation to the array X2.
-c
-c\Usage:
-c  call dsortr
-c     ( WHICH, APPLY, N, X1, X2 )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X1 is sorted into increasing order of magnitude.
-c          'SM' -> X1 is sorted into decreasing order of magnitude.
-c          'LA' -> X1 is sorted into increasing order of algebraic.
-c          'SA' -> X1 is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to X2.
-c          APPLY = .FALSE. -> do not apply the sorted order to X2.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X1      Double precision array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  X2      Double precision array of length N.  (INPUT/OUTPUT)
-c          Only referenced if APPLY = .TRUE.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dsortr (which, apply, n, x1, x2)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           x1(0:n-1), x2(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Double precision
-     &           temp
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'SA') then
-c
-c        X1 is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x1(j).lt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X1 is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x1(j)).lt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X1 is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (x1(j).gt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'LM') then
-c
-c        X1 is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x1(j)).gt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of dsortr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstatn.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstatn.f
deleted file mode 100644
index d09d8a3713..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstatn.f
+++ /dev/null
@@ -1,61 +0,0 @@
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for nonsymmetric Arnoldi code.              |
-c     %---------------------------------------------%
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.4   DATE OF SID: 4/20/96   RELEASE: 2
-c
-      subroutine dstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-c
-      tnaupd = 0.0D+0
-      tnaup2 = 0.0D+0
-      tnaitr = 0.0D+0
-      tneigh = 0.0D+0
-      tngets = 0.0D+0
-      tnapps = 0.0D+0
-      tnconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
-c
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-c
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
-c
-      return
-c
-c
-c     %---------------%
-c     | End of dstatn |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstats.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstats.f
deleted file mode 100644
index cb1b3f38dd..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstats.f
+++ /dev/null
@@ -1,47 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for symmetric Arnoldi code.                 |
-c     %---------------------------------------------%
-
-      subroutine dstats
-
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-      include   'stat.h'
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-
-      tsaupd = 0.0D+0
-      tsaup2 = 0.0D+0
-      tsaitr = 0.0D+0
-      tseigt = 0.0D+0
-      tsgets = 0.0D+0
-      tsapps = 0.0D+0
-      tsconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
-
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
-
-      return
-c
-c     End of dstats
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstqrb.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstqrb.f
deleted file mode 100644
index d55a59a2d3..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/dstqrb.f
+++ /dev/null
@@ -1,594 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: dstqrb
-c
-c\Description:
-c  Computes all eigenvalues and the last component of the eigenvectors
-c  of a symmetric tridiagonal matrix using the implicit QL or QR method.
-c
-c  This is mostly a modification of the LAPACK routine dsteqr.
-c  See Remarks.
-c
-c\Usage:
-c  call dstqrb
-c     ( N, D, E, Z, WORK, INFO )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          The number of rows and columns in the matrix.  N >= 0.
-c
-c  D       Double precision array, dimension (N).  (INPUT/OUTPUT)
-c          On entry, D contains the diagonal elements of the
-c          tridiagonal matrix.
-c          On exit, D contains the eigenvalues, in ascending order.
-c          If an error exit is made, the eigenvalues are correct
-c          for indices 1,2,...,INFO-1, but they are unordered and
-c          may not be the smallest eigenvalues of the matrix.
-c
-c  E       Double precision array, dimension (N-1).  (INPUT/OUTPUT)
-c          On entry, E contains the subdiagonal elements of the
-c          tridiagonal matrix in positions 1 through N-1.
-c          On exit, E has been destroyed.
-c
-c  Z       Double precision array, dimension (N).  (OUTPUT)
-c          On exit, Z contains the last row of the orthonormal
-c          eigenvector matrix of the symmetric tridiagonal matrix.
-c          If an error exit is made, Z contains the last row of the
-c          eigenvector matrix associated with the stored eigenvalues.
-c
-c  WORK    Double precision array, dimension (max(1,2*N-2)).  (WORKSPACE)
-c          Workspace used in accumulating the transformation for
-c          computing the last components of the eigenvectors.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0:  normal return.
-c          < 0:  if INFO = -i, the i-th argument had an illegal value.
-c          > 0:  if INFO = +i, the i-th eigenvalue has not converged
-c                              after a total of  30*N  iterations.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     daxpy   Level 1 BLAS that computes a vector triad.
-c     dcopy   Level 1 BLAS that copies one vector to another.
-c     dswap   Level 1 BLAS that swaps the contents of two vectors.
-c     lsame   LAPACK character comparison routine.
-c     dlae2   LAPACK routine that computes the eigenvalues of a 2-by-2
-c             symmetric matrix.
-c     dlaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric
-c             matrix.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlanst  LAPACK routine that computes the norm of a matrix.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     dlartg  LAPACK Givens rotation construction routine.
-c     dlascl  LAPACK routine for careful scaling of a matrix.
-c     dlaset  LAPACK matrix initialization routine.
-c     dlasr   LAPACK routine that applies an orthogonal transformation to
-c             a matrix.
-c     dlasrt  LAPACK sorting routine.
-c     dsteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a symmetric tridiagonal matrix.
-c     xerbla  LAPACK error handler routine.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.5, this routine is a modified version
-c        of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,
-c        only commented out and new lines inserted.
-c        All lines commented out have "c$$$" at the beginning.
-c        Note that the LAPACK version 1.0 subroutine SSTEQR contained
-c        bugs.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine dstqrb ( n, d, e, z, work, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    info, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Double precision
-     &           d( n ), e( n-1 ), z( n ), work( 2*n-2 )
-c
-c     .. parameters ..
-      Double precision
-     &                   zero, one, two, three
-      parameter          ( zero = 0.0D+0, one = 1.0D+0,
-     &                     two = 2.0D+0, three = 3.0D+0 )
-      integer            maxit
-      parameter          ( maxit = 30 )
-c     ..
-c     .. local scalars ..
-      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
-     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
-     &                   nm1, nmaxit
-      Double precision
-     &                   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
-     &                   s, safmax, safmin, ssfmax, ssfmin, tst
-c     ..
-c     .. external functions ..
-      logical            lsame
-      Double precision
-     &                   dlamch, dlanst, dlapy2
-      external           lsame, dlamch, dlanst, dlapy2
-c     ..
-c     .. external subroutines ..
-      external           dlae2, dlaev2, dlartg, dlascl, dlaset, dlasr,
-     &                   dlasrt, dswap, xerbla
-c     ..
-c     .. intrinsic functions ..
-      intrinsic          abs, max, sign, sqrt
-c     ..
-c     .. executable statements ..
-c
-c     test the input parameters.
-c
-      info = 0
-c
-c$$$      IF( LSAME( COMPZ, 'N' ) ) THEN
-c$$$         ICOMPZ = 0
-c$$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
-c$$$         ICOMPZ = 1
-c$$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
-c$$$         ICOMPZ = 2
-c$$$      ELSE
-c$$$         ICOMPZ = -1
-c$$$      END IF
-c$$$      IF( ICOMPZ.LT.0 ) THEN
-c$$$         INFO = -1
-c$$$      ELSE IF( N.LT.0 ) THEN
-c$$$         INFO = -2
-c$$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
-c$$$     $         N ) ) ) THEN
-c$$$         INFO = -6
-c$$$      END IF
-c$$$      IF( INFO.NE.0 ) THEN
-c$$$         CALL XERBLA( 'SSTEQR', -INFO )
-c$$$         RETURN
-c$$$      END IF
-c
-c    *** New starting with version 2.5 ***
-c
-      icompz = 2
-c    *************************************
-c
-c     quick return if possible
-c
-      if( n.eq.0 )
-     $   return
-c
-      if( n.eq.1 ) then
-         if( icompz.eq.2 )  z( 1 ) = one
-         return
-      end if
-c
-c     determine the unit roundoff and over/underflow thresholds.
-c
-      eps = dlamch( 'e' )
-      eps2 = eps**2
-      safmin = dlamch( 's' )
-      safmax = one / safmin
-      ssfmax = sqrt( safmax ) / three
-      ssfmin = sqrt( safmin ) / eps2
-c
-c     compute the eigenvalues and eigenvectors of the tridiagonal
-c     matrix.
-c
-c$$      if( icompz.eq.2 )
-c$$$     $   call dlaset( 'full', n, n, zero, one, z, ldz )
-c
-c     *** New starting with version 2.5 ***
-c
-      if ( icompz .eq. 2 ) then
-         do 5 j = 1, n-1
-            z(j) = zero
-  5      continue
-         z( n ) = one
-      end if
-c     *************************************
-c
-      nmaxit = n*maxit
-      jtot = 0
-c
-c     determine where the matrix splits and choose ql or qr iteration
-c     for each block, according to whether top or bottom diagonal
-c     element is smaller.
-c
-      l1 = 1
-      nm1 = n - 1
-c
-   10 continue
-      if( l1.gt.n )
-     $   go to 160
-      if( l1.gt.1 )
-     $   e( l1-1 ) = zero
-      if( l1.le.nm1 ) then
-         do 20 m = l1, nm1
-            tst = abs( e( m ) )
-            if( tst.eq.zero )
-     $         go to 30
-            if( tst.le.( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+
-     $          1 ) ) ) )*eps ) then
-               e( m ) = zero
-               go to 30
-            end if
-   20    continue
-      end if
-      m = n
-c
-   30 continue
-      l = l1
-      lsv = l
-      lend = m
-      lendsv = lend
-      l1 = m + 1
-      if( lend.eq.l )
-     $   go to 10
-c
-c     scale submatrix in rows and columns l to lend
-c
-      anorm = dlanst( 'i', lend-l+1, d( l ), e( l ) )
-      iscale = 0
-      if( anorm.eq.zero )
-     $   go to 10
-      if( anorm.gt.ssfmax ) then
-         iscale = 1
-         call dlascl( 'g', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,
-     $                info )
-         call dlascl( 'g', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,
-     $                info )
-      else if( anorm.lt.ssfmin ) then
-         iscale = 2
-         call dlascl( 'g', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,
-     $                info )
-         call dlascl( 'g', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,
-     $                info )
-      end if
-c
-c     choose between ql and qr iteration
-c
-      if( abs( d( lend ) ).lt.abs( d( l ) ) ) then
-         lend = lsv
-         l = lendsv
-      end if
-c
-      if( lend.gt.l ) then
-c
-c        ql iteration
-c
-c        look for small subdiagonal element.
-c
-   40    continue
-         if( l.ne.lend ) then
-            lendm1 = lend - 1
-            do 50 m = l, lendm1
-               tst = abs( e( m ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+
-     $             safmin )go to 60
-   50       continue
-         end if
-c
-         m = lend
-c
-   60    continue
-         if( m.lt.lend )
-     $      e( m ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 80
-c
-c        if remaining matrix is 2-by-2, use dlae2 or dlaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l+1 ) then
-            if( icompz.gt.0 ) then
-               call dlaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
-               work( l ) = c
-               work( n-1+l ) = s
-c$$$               call dlasr( 'r', 'v', 'b', n, 2, work( l ),
-c$$$     $                     work( n-1+l ), z( 1, l ), ldz )
-c
-c              *** New starting with version 2.5 ***
-c
-               tst      = z(l+1)
-               z(l+1) = c*tst - s*z(l)
-               z(l)   = s*tst + c*z(l)
-c              *************************************
-            else
-               call dlae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
-            end if
-            d( l ) = rt1
-            d( l+1 ) = rt2
-            e( l ) = zero
-            l = l + 2
-            if( l.le.lend )
-     $         go to 40
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l+1 )-p ) / ( two*e( l ) )
-         r = dlapy2( g, one )
-         g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         mm1 = m - 1
-         do 70 i = mm1, l, -1
-            f = s*e( i )
-            b = c*e( i )
-            call dlartg( g, f, c, s, r )
-            if( i.ne.m-1 )
-     $         e( i+1 ) = r
-            g = d( i+1 ) - p
-            r = ( d( i )-g )*s + two*c*b
-            p = s*r
-            d( i+1 ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = -s
-            end if
-c
-   70    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = m - l + 1
-c$$$            call dlasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),
-c$$$     $                  z( 1, l ), ldz )
-c
-c             *** New starting with version 2.5 ***
-c
-              call dlasr( 'r', 'v', 'b', 1, mm, work( l ),
-     &                    work( n-1+l ), z( l ), 1 )
-c             *************************************
-         end if
-c
-         d( l ) = d( l ) - p
-         e( l ) = g
-         go to 40
-c
-c        eigenvalue found.
-c
-   80    continue
-         d( l ) = p
-c
-         l = l + 1
-         if( l.le.lend )
-     $      go to 40
-         go to 140
-c
-      else
-c
-c        qr iteration
-c
-c        look for small superdiagonal element.
-c
-   90    continue
-         if( l.ne.lend ) then
-            lendp1 = lend + 1
-            do 100 m = l, lendp1, -1
-               tst = abs( e( m-1 ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+
-     $             safmin )go to 110
-  100       continue
-         end if
-c
-         m = lend
-c
-  110    continue
-         if( m.gt.lend )
-     $      e( m-1 ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 130
-c
-c        if remaining matrix is 2-by-2, use dlae2 or dlaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l-1 ) then
-            if( icompz.gt.0 ) then
-               call dlaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
-c$$$               work( m ) = c
-c$$$               work( n-1+m ) = s
-c$$$               call dlasr( 'r', 'v', 'f', n, 2, work( m ),
-c$$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )
-c
-c               *** New starting with version 2.5 ***
-c
-                tst      = z(l)
-                z(l)   = c*tst - s*z(l-1)
-                z(l-1) = s*tst + c*z(l-1)
-c               *************************************
-            else
-               call dlae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
-            end if
-            d( l-1 ) = rt1
-            d( l ) = rt2
-            e( l-1 ) = zero
-            l = l - 2
-            if( l.ge.lend )
-     $         go to 90
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
-         r = dlapy2( g, one )
-         g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         lm1 = l - 1
-         do 120 i = m, lm1
-            f = s*e( i )
-            b = c*e( i )
-            call dlartg( g, f, c, s, r )
-            if( i.ne.m )
-     $         e( i-1 ) = r
-            g = d( i ) - p
-            r = ( d( i+1 )-g )*s + two*c*b
-            p = s*r
-            d( i ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = s
-            end if
-c
-  120    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = l - m + 1
-c$$$            call dlasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),
-c$$$     $                  z( 1, m ), ldz )
-c
-c           *** New starting with version 2.5 ***
-c
-            call dlasr( 'r', 'v', 'f', 1, mm, work( m ), work( n-1+m ),
-     &                  z( m ), 1 )
-c           *************************************
-         end if
-c
-         d( l ) = d( l ) - p
-         e( lm1 ) = g
-         go to 90
-c
-c        eigenvalue found.
-c
-  130    continue
-         d( l ) = p
-c
-         l = l - 1
-         if( l.ge.lend )
-     $      go to 90
-         go to 140
-c
-      end if
-c
-c     undo scaling if necessary
-c
-  140 continue
-      if( iscale.eq.1 ) then
-         call dlascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call dlascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      else if( iscale.eq.2 ) then
-         call dlascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call dlascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      end if
-c
-c     check for no convergence to an eigenvalue after a total
-c     of n*maxit iterations.
-c
-      if( jtot.lt.nmaxit )
-     $   go to 10
-      do 150 i = 1, n - 1
-         if( e( i ).ne.zero )
-     $      info = info + 1
-  150 continue
-      go to 190
-c
-c     order eigenvalues and eigenvectors.
-c
-  160 continue
-      if( icompz.eq.0 ) then
-c
-c        use quick sort
-c
-         call dlasrt( 'i', n, d, info )
-c
-      else
-c
-c        use selection sort to minimize swaps of eigenvectors
-c
-         do 180 ii = 2, n
-            i = ii - 1
-            k = i
-            p = d( i )
-            do 170 j = ii, n
-               if( d( j ).lt.p ) then
-                  k = j
-                  p = d( j )
-               end if
-  170       continue
-            if( k.ne.i ) then
-               d( k ) = d( i )
-               d( i ) = p
-c$$$               call dswap( n, z( 1, i ), 1, z( 1, k ), 1 )
-c           *** New starting with version 2.5 ***
-c
-               p    = z(k)
-               z(k) = z(i)
-               z(i) = p
-c           *************************************
-            end if
-  180    continue
-      end if
-c
-  190 continue
-      return
-c
-c     %---------------%
-c     | End of dstqrb |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sgetv0.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sgetv0.f
deleted file mode 100644
index d861b2d6d7..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sgetv0.f
+++ /dev/null
@@ -1,421 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sgetv0
-c
-c\Description:
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.
-c
-c\Usage:
-c  call sgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM,
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to sgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that sgetv0 is called.
-c          It should be set to 1 on the initial call to sgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Real N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Real scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Real work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine for vector output.
-c     slarnv  LAPACK routine for generating a random vector.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.7   DATE OF SID: 04/07/99   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sgetv0
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm,
-     &     ipntr, workd, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Real
-     &           rnorm0
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   slarnv, svout, scopy, sgemv, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2
-      external   sdot, snrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call slarnv (idist, iseed, n, resid)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (itry .eq. 1) then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call scopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         else if (itry .gt. 1 .and. bmat .eq. 'G') then
-            call scopy (n, resid, 1, workd(n + 1), 1)
-         end if
-      end if
-c
-c     %-----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %-----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing OP*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-      end if
-c
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (itry .eq. 1) call scopy (n, workd(n + 1), 1, resid, 1)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call scopy (n, resid, 1, workd, 1)
-      end if
-c
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          rnorm0 = sdot (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(abs(rnorm0))
-      else if (bmat .eq. 'I') then
-           rnorm0 = snrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call sgemv ('T', n, j-1, one, v, ldv, workd, 1,
-     &            zero, workd(n+1), 1)
-      call sgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1,
-     &            one, resid, 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call scopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call scopy (n, resid, 1, workd, 1)
-      end if
-c
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      if (bmat .eq. 'G') then
-         rnorm = sdot (n, resid, 1, workd, 1)
-         rnorm = sqrt(abs(rnorm))
-      else if (bmat .eq. 'I') then
-         rnorm = snrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call svout (logfil, 1, [rnorm0], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call svout (logfil, 1, [rnorm], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c
-      iter = iter + 1
-      if (iter .le. 5) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = zero
-         ierr = -1
-      end if
-c
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, 1, [rnorm], ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 3) then
-         call svout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sgetv0 |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaitr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaitr.f
deleted file mode 100644
index 8a5d795be3..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaitr.f
+++ /dev/null
@@ -1,840 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snaitr
-c
-c\Description:
-c  Reverse communication interface for applying NP additional steps to
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in snaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call snaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recompute in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See snaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.
-c          Only work for NB = 1 right now.  The goal is to have a
-c          program that implement both the block and non-block method.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Real N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     sgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slabad  LAPACK routine that computes machine constants.
-c     slamch  LAPACK routine that determines machine constants.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     sscal   Level 1 BLAS that scales a vector.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k};
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in snaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh,
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Real
-     &           betaj, ovfl, temp1, rnorm1, smlnum, tst1, ulp, unfl,
-     &           wnorm
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments |
-c     %-----------------------%
-c
-      Real
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, sgemv, sgetv0, slabad,
-     &           svout, smout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slanhs, slamch
-      external   sdot, snrm2, slanhs, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine slahqr     |
-c        %-----------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = one / unfl
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mnaitr
-c
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         sgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [j], ndigit,
-     &                  '_naitr: generating Arnoldi vector number')
-            call svout (logfil, 1, [rnorm], ndigit,
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determining whether |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [j], ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            betaj  = zero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call sgetv0 (ido, bmat, itry, .false., n, j, v, ldv,
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tnaitr = tnaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call scopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. unfl) then
-             temp1 = one / rnorm
-             call sscal (n, temp1, v(1,j), 1)
-             call sscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call slascl ('General', i, i, rnorm, one, n, 1,
-     &                    v(1,j), n, infol)
-             call slascl ('General', i, i, rnorm, one, n, 1,
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call scopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c
-         go to 9000
-   50    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call scopy (n, workd(irj), 1, resid, 1)
-c
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             wnorm = sdot (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. |
-c        %--------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = betaj
-c
-         call arscnd (t4)
-c
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then
-            rnorm = sdot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         iter  = 0
-         nrorth = nrorth + 1
-c
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call svout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: re-orthonalization; wnorm and rnorm are')
-            call svout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, workd(irj), 1,
-     &               one, resid, 1)
-         call saxpy (j, one, workd(irj), 1, h(1,j), 1)
-c
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             rnorm1 = sdot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = snrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, [j], ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call svout (logfil, 2, xtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c
-         rstart = .false.
-         orth2  = .false.
-c
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tnaitr = tnaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine slahqr        |
-c              %--------------------------------------------%
-c
-               tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-               if( tst1.eq.zero )
-     &              tst1 = slanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) )
-     &              h(i+1,i) = zero
- 110        continue
-c
-            if (msglvl .gt. 2) then
-               call smout (logfil, k+np, k+np, h, ldh, ndigit,
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of snaitr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snapps.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snapps.f
deleted file mode 100644
index 33b0361084..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snapps.f
+++ /dev/null
@@ -1,647 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call snapps
-c     ( N, KEV, NP, SHIFTR, SHIFTI, V, LDV, H, LDH, RESID, Q, LDQ,
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.  KEV is only
-c          updated on output when fewer than NP shifts are applied in
-c          order to keep the conjugate pair together.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFTR, Real array of length NP.  (INPUT)
-c  SHIFTI  Real and imaginary part of the shifts to be applied.
-c          Upon, entry to snapps, the shifts must be sorted so that the
-c          conjugate pairs are in consecutive locations.
-c
-c  V       Real N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper
-c          Hessenber matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k}
-c          in the first KEV locations.
-c
-c  Q       Real KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Real work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices.
-c     svout   ARPACK utility routine that prints vectors.
-c     slabad  LAPACK routine that computes machine constants.
-c     slacpy  LAPACK matrix copy routine.
-c     slamch  LAPACK routine that determines machine constants.
-c     slanhs  LAPACK routine that computes various norms of a matrix.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slarf   LAPACK routine that applies Householder reflection to
-c             a matrix.
-c     slarfg  LAPACK Householder reflection construction routine.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slaset  LAPACK matrix initialization routine.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.4   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine slahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     The subdiagonals of H are enforced to be non-negative.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snapps
-     &   ( n, kev, np, shiftr, shifti, v, ldv, h, ldh, resid, q, ldq,
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h(ldh,kev+np), resid(n), shifti(np), shiftr(np),
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, ir, istart, j, jj, kplusp, msglvl, nr
-      logical    cconj, first
-      Real
-     &           c, f, g, h11, h12, h21, h22, h32, ovfl, r, s, sigmai,
-     &           sigmar, smlnum, ulp, unfl, u(3), t, tau, tst1
-      save       first, ovfl, smlnum, ulp, unfl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, slacpy, slarfg, slarf,
-     &           slaset, slabad, arscnd, slartg
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch, slanhs, slapy2
-      external   slamch, slanhs, slapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, max, min
-c
-c     %----------------%
-c     | Data statements |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine slahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = slamch( 'safe minimum' )
-         ovfl = one / unfl
-         call slabad( unfl, ovfl )
-         ulp = slamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mnapps
-      kplusp = kev + np
-c
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call slaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      cconj = .false.
-      do 110 jj = 1, np
-         sigmar = shiftr(jj)
-         sigmai = shifti(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, [jj], ndigit,
-     &               '_napps: shift number.')
-            call svout (logfil, 1, [sigmar], ndigit,
-     &               '_napps: The real part of the shift ')
-            call svout (logfil, 1, [sigmai], ndigit,
-     &               '_napps: The imaginary part of the shift ')
-         end if
-c
-c        %-------------------------------------------------%
-c        | The following set of conditionals is necessary  |
-c        | in order that complex conjugate pairs of shifts |
-c        | are applied together or not at all.             |
-c        %-------------------------------------------------%
-c
-         if ( cconj ) then
-c
-c           %-----------------------------------------%
-c           | cconj = .true. means the previous shift |
-c           | had non-zero imaginary part.            |
-c           %-----------------------------------------%
-c
-            cconj = .false.
-            go to 110
-         else if ( jj .lt. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %------------------------------------%
-c           | Start of a complex conjugate pair. |
-c           %------------------------------------%
-c
-            cconj = .true.
-         else if ( jj .eq. np .and. abs( sigmai ) .gt. zero ) then
-c
-c           %----------------------------------------------%
-c           | The last shift has a nonzero imaginary part. |
-c           | Don't apply it; thus the order of the        |
-c           | compressed H is order KEV+1 since only np-1  |
-c           | were applied.                                |
-c           %----------------------------------------------%
-c
-            kev = kev + 1
-            go to 110
-         end if
-         istart = 1
-   20    continue
-c
-c        %--------------------------------------------------%
-c        | if sigmai = 0 then                               |
-c        |    Apply the jj-th shift ...                     |
-c        | else                                             |
-c        |    Apply the jj-th and (jj+1)-th together ...    |
-c        |    (Note that jj < np at this point in the code) |
-c        | end                                              |
-c        | to the current block of H. The next do loop      |
-c        | determines the current block ;                   |
-c        %--------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine slahqr    |
-c           %----------------------------------------%
-c
-            tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-            if( tst1.eq.zero )
-     &         tst1 = slanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if( abs( h( i+1,i ) ).le.max( ulp*tst1, smlnum ) ) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, [i], ndigit,
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, [jj], ndigit,
-     &                 '_napps: matrix splitting with shift number.')
-                  call svout (logfil, 1, h(i+1,i), ndigit,
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, [istart], ndigit,
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, [iend], ndigit,
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend ) go to 100
-c
-c        %------------------------------------------------------%
-c        | If istart + 1 = iend then no reason to apply a       |
-c        | complex conjugate pair of shifts on a 2 by 2 matrix. |
-c        %------------------------------------------------------%
-c
-         if ( istart + 1 .eq. iend .and. abs( sigmai ) .gt. zero )
-     &      go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         if ( abs( sigmai ) .le. zero ) then
-c
-c           %---------------------------------------------%
-c           | Real-valued shift ==> apply single shift QR |
-c           %---------------------------------------------%
-c
-            f = h11 - sigmar
-            g = h21
-c
-            do 80 i = istart, iend-1
-c
-c              %-----------------------------------------------------%
-c              | Construct the plane rotation G to zero out the bulge |
-c              %-----------------------------------------------------%
-c
-               call slartg (f, g, c, s, r)
-               if (i .gt. istart) then
-c
-c                 %-------------------------------------------%
-c                 | The following ensures that h(1:iend-1,1), |
-c                 | the first iend-2 off diagonal of elements |
-c                 | H, remain non negative.                   |
-c                 %-------------------------------------------%
-c
-                  if (r .lt. zero) then
-                     r = -r
-                     c = -c
-                     s = -s
-                  end if
-                  h(i,i-1) = r
-                  h(i+1,i-1) = zero
-               end if
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the left of H;  H <- G'*H |
-c              %---------------------------------------------%
-c
-               do 50 j = i, kplusp
-                  t        =  c*h(i,j) + s*h(i+1,j)
-                  h(i+1,j) = -s*h(i,j) + c*h(i+1,j)
-                  h(i,j)   = t
-   50          continue
-c
-c              %---------------------------------------------%
-c              | Apply rotation to the right of H;  H <- H*G |
-c              %---------------------------------------------%
-c
-               do 60 j = 1, min(i+2,iend)
-                  t        =  c*h(j,i) + s*h(j,i+1)
-                  h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-                  h(j,i)   = t
-   60          continue
-c
-c              %----------------------------------------------------%
-c              | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c              %----------------------------------------------------%
-c
-               do 70 j = 1, min( i+jj, kplusp )
-                  t        =   c*q(j,i) + s*q(j,i+1)
-                  q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                  q(j,i)   = t
-   70          continue
-c
-c              %---------------------------%
-c              | Prepare for next rotation |
-c              %---------------------------%
-c
-               if (i .lt. iend-1) then
-                  f = h(i+1,i)
-                  g = h(i+2,i)
-               end if
-   80       continue
-c
-c           %-----------------------------------%
-c           | Finished applying the real shift. |
-c           %-----------------------------------%
-c
-         else
-c
-c           %----------------------------------------------------%
-c           | Complex conjugate shifts ==> apply double shift QR |
-c           %----------------------------------------------------%
-c
-            h12 = h(istart,istart+1)
-            h22 = h(istart+1,istart+1)
-            h32 = h(istart+2,istart+1)
-c
-c           %---------------------------------------------------------%
-c           | Compute 1st column of (H - shift*I)*(H - conj(shift)*I) |
-c           %---------------------------------------------------------%
-c
-            s    = 2.0*sigmar
-            t = slapy2 ( sigmar, sigmai )
-            u(1) = ( h11 * (h11 - s) + t * t ) / h21 + h12
-            u(2) = h11 + h22 - s
-            u(3) = h32
-c
-            do 90 i = istart, iend-1
-c
-               nr = min ( 3, iend-i+1 )
-c
-c              %-----------------------------------------------------%
-c              | Construct Householder reflector G to zero out u(1). |
-c              | G is of the form I - tau*( 1 u )' * ( 1 u' ).       |
-c              %-----------------------------------------------------%
-c
-               call slarfg ( nr, u(1), u(2), 1, tau )
-c
-               if (i .gt. istart) then
-                  h(i,i-1)   = u(1)
-                  h(i+1,i-1) = zero
-                  if (i .lt. iend-1) h(i+2,i-1) = zero
-               end if
-               u(1) = one
-c
-c              %--------------------------------------%
-c              | Apply the reflector to the left of H |
-c              %--------------------------------------%
-c
-               call slarf ('Left', nr, kplusp-i+1, u, 1, tau,
-     &                     h(i,i), ldh, workl)
-c
-c              %---------------------------------------%
-c              | Apply the reflector to the right of H |
-c              %---------------------------------------%
-c
-               ir = min ( i+3, iend )
-               call slarf ('Right', ir, nr, u, 1, tau,
-     &                     h(1,i), ldh, workl)
-c
-c              %-----------------------------------------------------%
-c              | Accumulate the reflector in the matrix Q;  Q <- Q*G |
-c              %-----------------------------------------------------%
-c
-               call slarf ('Right', kplusp, nr, u, 1, tau,
-     &                     q(1,i), ldq, workl)
-c
-c              %----------------------------%
-c              | Prepare for next reflector |
-c              %----------------------------%
-c
-               if (i .lt. iend-1) then
-                  u(1) = h(i+1,i)
-                  u(2) = h(i+2,i)
-                  if (i .lt. iend-2) u(3) = h(i+3,i)
-               end if
-c
-   90       continue
-c
-c           %--------------------------------------------%
-c           | Finished applying a complex pair of shifts |
-c           | to the current block                       |
-c           %--------------------------------------------%
-c
-         end if
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %--------------------------------------------------%
-c     | Perform a similarity transformation that makes   |
-c     | sure that H will have non negative sub diagonals |
-c     %--------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( h(j+1,j) .lt. zero ) then
-              call sscal( kplusp-j+1, -one, h(j+1,j), ldh )
-              call sscal( min(j+2, kplusp), -one, h(1,j+1), 1 )
-              call sscal( min(j+np+1,kplusp), -one, q(1,j+1), 1 )
-         end if
- 120  continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine slahqr        |
-c        %--------------------------------------------%
-c
-         tst1 = abs( h( i, i ) ) + abs( h( i+1, i+1 ) )
-         if( tst1.eq.zero )
-     &       tst1 = slanhs( '1', kev, h, ldh, workl )
-         if( h( i+1,i ) .le. max( ulp*tst1, smlnum ) )
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &    call sgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero,
-     &                workd(n+1), 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call sgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call scopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call slacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if (h(kev+1,kev) .gt. zero)
-     &   call scopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kplusp}'*Q)*e_{kev} |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call sscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,kev) .gt. zero)
-     &   call saxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call svout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, [kev], ndigit,
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call smout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tnapps = tnapps + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of snapps |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaup2.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaup2.f
deleted file mode 100644
index e3be754eac..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaup2.f
+++ /dev/null
@@ -1,847 +0,0 @@
-c\BeginDoc
-c
-c\Name: snaup2
-c
-c\Description:
-c  Intermediate level interface called by snaupd.
-c
-c\Usage:
-c  call snaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZR, RITZI, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in snaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in snaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse communication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV for two reasons. The first, is
-c          to keep complex conjugate pairs of "wanted" Ritz values
-c          together. The second, is that a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Real  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Real  arrays of length NEV+NP.  (OUTPUT)
-c  RITZI   RITZR(1:NEV) (resp. RITZI(1:NEV)) contains the real (resp.
-c          imaginary) part of the computed Ritz values of OP.
-c
-c  BOUNDS  Real  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Real  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c          On exit, the last 3*(NEV+NP) locations of WORKL contain
-c          the Ritz values (real,imaginary) and associated Ritz
-c          estimates of the current Hessenberg matrix.  They are
-c          listed in the same order as returned from sneigh.
-c
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first 2*NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in DNAUPD.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     sgetv0  ARPACK initial vector generation routine.
-c     snaitr  ARPACK Arnoldi factorization routine.
-c     snapps  ARPACK application of implicit shifts routine.
-c     snconv  ARPACK convergence of Ritz values routine.
-c     sneigh  ARPACK compute Ritz values and error bounds routine.
-c     sngets  ARPACK reorder Ritz values and error bounds routine.
-c     ssortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.8   DATE OF SID: 10/17/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritzr, ritzi, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Real
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np), resid(n),
-     &           ritzi(nev+np), ritzr(nev+np), v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm , getv0, initv, update, ushift
-      integer    ierr  , iter , j    , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0  , nptemp, numcnv
-      Real
-     &           rnorm , temp , eps23
-      save       cnorm , getv0, initv, update, ushift,
-     &           rnorm , iter , eps23, kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0  , numcnv
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(4)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sgetv0, snaitr, snconv, sneigh,
-     &           sngets, snapps, svout , ivout , arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slapy2, slamch
-      external   sdot, snrm2, slapy2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min, max, abs, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mnaup2
-c
-c        %-------------------------------------%
-c        | Get the machine dependent constant. |
-c        %-------------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call sgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call snaitr (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [iter], ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine snapps.                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [nev], ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, [np], ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call snaitr (ido  , bmat, n  , nev, np , mode , resid,
-     &                rnorm, v   , ldv, h  , ldh, ipntr, workd,
-     &                info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, [rnorm], ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call sneigh (rnorm, kplusp, h, ldh, ritzr, ritzi, bounds,
-     &                q, ldq, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from sneigh.                       |
-c        %----------------------------------------------------%
-c
-         call scopy(kplusp, ritzr, 1, workl(kplusp**2+1), 1)
-         call scopy(kplusp, ritzi, 1, workl(kplusp**2+kplusp+1), 1)
-         call scopy(kplusp, bounds, 1, workl(kplusp**2+2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZR,   |
-c        | RITZI and BOUNDS respectively. The variables NEV  |
-c        | and NP may be updated if the NEV-th wanted Ritz   |
-c        | value has a non zero imaginary part. In this case |
-c        | NEV is increased by one and NP decreased by one.  |
-c        | NOTE: The last two arguments of sngets are no     |
-c        | longer used as of version 2.1.                    |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         numcnv = nev
-         call sngets (ishift, which, nev, np, ritzr, ritzi,
-     &                bounds, workl, workl(np+1))
-         if (nev .eq. nev0+1) numcnv = nev0+1
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call scopy (nev, bounds(np+1), 1, workl(2*np+1), 1)
-         call snconv (nev, ritzr(np+1), ritzi(np+1), workl(2*np+1),
-     &        tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = numcnv
-            kp(4) = nconv
-            call ivout (logfil, 4, kp, ndigit,
-     &                  '_naup2: NEV, NP, NUMCNV, NCONV are')
-            call svout (logfil, kplusp, ritzr, ndigit,
-     &           '_naup2: Real part of the eigenvalues of H')
-            call svout (logfil, kplusp, ritzi, ndigit,
-     &           '_naup2: Imaginary part of the eigenvalues of H')
-            call svout (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. numcnv) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call svout(logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Real part of the eig computed by _neigh:')
-               call svout(logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Imag part of the eig computed by _neigh:')
-               call svout(logfil, kplusp, workl(kplusp**2+kplusp*2+1),
-     &                     ndigit,
-     &             '_naup2: Ritz eistmates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to _neupd if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = rnorm
-c
-c           %----------------------------------------------%
-c           | To be consistent with sngets, we first do a  |
-c           | pre-processing sort in order to keep complex |
-c           | conjugate pairs together.  This is similar   |
-c           | to the pre-processing sort used in sngets    |
-c           | except that the sort is done in the opposite |
-c           | order.                                       |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SR'
-            if (which .eq. 'SM') wprime = 'LR'
-            if (which .eq. 'LR') wprime = 'SM'
-            if (which .eq. 'SR') wprime = 'LM'
-            if (which .eq. 'LI') wprime = 'SM'
-            if (which .eq. 'SI') wprime = 'LM'
-c
-            call ssortc (wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %----------------------------------------------%
-c           | Now sort Ritz values so that converged Ritz  |
-c           | values appear within the first NEV locations |
-c           | of ritzr, ritzi and bounds, and the most     |
-c           | desired one appears at the front.            |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call ssortc(wprime, .true., kplusp, ritzr, ritzi, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, numcnv
-                temp = max(eps23,slapy2(ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | estimates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LR'
-            call ssortc(wprime, .true., numcnv, bounds, ritzr, ritzi)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, numcnv
-                temp = max(eps23, slapy2(ritzr(j),
-     &                                   ritzi(j)))
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %------------------------------------------------%
-c           | Sort the converged Ritz values again so that   |
-c           | the "threshold" value appears at the front of  |
-c           | ritzr, ritzi and bound.                        |
-c           %------------------------------------------------%
-c
-            call ssortc(which, .true., nconv, ritzr, ritzi, bounds)
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, kplusp, ritzr, ndigit,
-     &            '_naup2: Sorted real part of the eigenvalues')
-               call svout (logfil, kplusp, ritzi, ndigit,
-     &            '_naup2: Sorted imaginary part of the eigenvalues')
-               call svout (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. numcnv) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. numcnv) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. numcnv) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-c           %---- Scipy fix ------------------------------------------------
-c           | We must keep nev below this value, as otherwise we can get
-c           | np == 0 (note that sngets below can bump nev by 1). If np == 0,
-c           | the next call to `snaitr` will write out-of-bounds.
-c           |
-            if (nev .gt. kplusp - 2) then
-               nev = kplusp - 2
-            end if
-c           |
-c           %---- Scipy fix end --------------------------------------------
-
-c
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call sngets (ishift, which, nev, np, ritzr, ritzi,
-     &              bounds, workl, workl(np+1))
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [nconv], ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call svout (logfil, nev, ritzr(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- real part')
-               call svout (logfil, nev, ritzi(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values -- imag part')
-               call svout (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: reverse communication to       |
-c           | compute the shifts. They are returned in the first    |
-c           | 2*NP locations of WORKL.                              |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:2*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-         if ( ishift .eq. 0 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZR, RITZI to free up WORKL    |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call scopy (np, workl,       1, ritzr, 1)
-             call scopy (np, workl(np+1), 1, ritzi, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [np], ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call svout (logfil, np, ritzr, ndigit,
-     &                  '_naup2: Real part of the shifts')
-            call svout (logfil, np, ritzi, ndigit,
-     &                  '_naup2: Imaginary part of the shifts')
-            if ( ishift .eq. 1 )
-     &          call svout (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call snapps (n, nev, np, ritzr, ritzi, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to snaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = sdot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, [rnorm], ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call smout (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = numcnv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tnaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of snaup2 |
-c     %---------------%
-c
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaupd.f
deleted file mode 100644
index d6fad33863..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snaupd.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c\BeginDoc
-c
-c\Name: snaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This subroutine computes approximations to a few eigenpairs
-c  of a linear operator "OP" with respect to a semi-inner product defined by
-c  a symmetric positive semi-definite real matrix B. B may be the identity
-c  matrix. NOTE: If the linear operator "OP" is real and symmetric
-c  with respect to the real positive semi-definite symmetric matrix B,
-c  i.e. B*OP = (OP`)*B, then subroutine ssaupd should be used instead.
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  snaupd is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Real_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2 * [ 1/(lambda-sigma) + 1/(lambda-conjg(sigma)) ].
-c           Note: If sigma is real, i.e. imaginary part of sigma is zero;
-c                 Real_Part{ inv[A - sigma*M]*M } == inv[A - sigma*M]*M
-c                 amu == 1/(lambda-sigma).
-c
-c  Mode 4:  A*x = lambda*M*x, M symmetric semi-definite
-c           ===> OP = Imaginary_Part{ inv[A - sigma*M]*M }  and  B = M.
-c           ===> shift-and-invert mode (in real arithmetic)
-c           If OP*x = amu*x, then
-c           amu = 1/2i * [ 1/(lambda-sigma) - 1/(lambda-conjg(sigma)) ].
-c
-c  Both mode 3 and 4 give the same enhancement to eigenvalues close to
-c  the (complex) shift sigma.  However, as lambda goes to infinity,
-c  the operator OP in mode 4 dampens the eigenvalues more strongly than
-c  does OP defined in mode 3.
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call snaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to snaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          snaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3 and 4, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) real and imaginary parts
-c                    of the shifts where INPTR(14) is the pointer
-c                    into WORKL for placing the shifts. See Remark
-c                    5 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Real  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = SLAMCH('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine SLAMCH).
-c
-c  RESID   Real  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 2 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x.
-c          NOTE: 2 <= NCV-NEV in order that complex conjugate pairs of Ritz
-c          values are kept together. (See remark 4 below)
-c
-c  V       Real  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The real and imaginary
-c                      parts of the NCV eigenvalues of the Hessenberg
-c                      matrix H are returned in the part of the WORKL
-c                      array corresponding to RITZR and RITZI. See remark
-c                      5 below.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of approximate Schur
-c                      vectors associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4; See under \Description of snaupd for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), snaupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          5 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg matrix
-c                    H in WORKL.
-c          IPNTR(6): pointer to the real part of the ritz value array
-c                    RITZR in WORKL.
-c          IPNTR(7): pointer to the imaginary part of the ritz value array
-c                    RITZI in WORKL.
-c          IPNTR(8): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZR and RITZI in WORKL.
-c
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by sneupd. See Remark 2 below.
-c
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     sneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If an invariant subspace
-c          associated with the converged Ritz values is desired, see remark
-c          2 below, subroutine sneupd uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 6*NCV.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when
-c     Mode = 3 and 4.  After convergence, approximate eigenvalues of the
-c     original problem may be obtained with the ARPACK subroutine sneupd.
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call sneupd immediately following
-c     completion of snaupd. This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 2.
-c     However, it is recommended that NCV .ge. 2*NEV+1.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) real and imaginary parts of the shifts in locations
-c         real part                  imaginary part
-c         -----------------------    --------------
-c     1   WORKL(IPNTR(14))           WORKL(IPNTR(14)+NP)
-c     2   WORKL(IPNTR(14)+1)         WORKL(IPNTR(14)+NP+1)
-c                        .                          .
-c                        .                          .
-c                        .                          .
-c     NP  WORKL(IPNTR(14)+NP-1)      WORKL(IPNTR(14)+2*NP-1).
-c
-c     Only complex conjugate pairs of shifts may be applied and the pairs
-c     must be placed in consecutive locations. The real part of the
-c     eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1) and the imaginary part
-c     in WORKL(IPNTR(7)) through WORKL(IPNTR(7)+NCV-1). They are ordered
-c     according to the order defined by WHICH. The complex conjugate
-c     pairs are kept together and the associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Real  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Real   resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     snaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version '1.1'
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Real
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritzi, ritzr, j
-      save       bounds, ih, iq, ishift, iupd, iw, ldh, ldq,
-     &           levec, mode, msglvl, mxiter, nb, nev0, next,
-     &           np, ritzi, ritzr
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   snaup2, svout, ivout, arscnd, sstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call sstatn
-         call arscnd (t0)
-         msglvl = mnaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 4) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. zero)			tol = slamch('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 6*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary        |
-c        |                                   parts of ritz values      |
-c        | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds        |
-c        | workl(ncv*ncv+3*ncv+1:2*ncv*ncv+3*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) := workspace       |
-c        | The final workspace is needed by subroutine sneigh called   |
-c        | by snaup2. Subroutine sneigh calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritzr  = ih     + ldh*ncv
-         ritzi  = ritzr  + ncv
-         bounds = ritzi  + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritzr
-         ipntr(7) = ritzi
-         ipntr(8) = bounds
-         ipntr(14) = iw
-c
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call snaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritzr),
-     &     workl(ritzi), workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within snaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [mxiter], ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, [np], ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call svout (logfil, np, workl(ritzr), ndigit,
-     &               '_naupd: Real part of the final Ritz values')
-         call svout (logfil, np, workl(ritzi), ndigit,
-     &               '_naupd: Imaginary part of the final Ritz values')
-         call svout (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tnaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tnaupd, tnaup2, tnaitr, titref,
-     &                  tgetv0, tneigh, tngets, tnapps, tnconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Nonsymmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number: ', ' 2.4' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of snaupd |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snconv.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snconv.f
deleted file mode 100644
index af94700a93..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/snconv.f
+++ /dev/null
@@ -1,146 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: snconv
-c
-c\Description:
-c  Convergence testing for the nonsymmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call snconv
-c     ( N, RITZR, RITZI, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZR,  Real arrays of length N.  (INPUT)
-c  RITZI   Real and imaginary parts of the Ritz values to be checked
-c          for convergence.
-
-c  BOUNDS  Real array of length N.  (INPUT)
-c          Ritz estimates for the Ritz values in RITZR and RITZI.
-c
-c  TOL     Real scalar.  (INPUT)
-c          Desired backward error for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: nconv.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine snconv (n, ritzr, ritzi, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-
-      Real
-     &           ritzr(n), ritzi(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Real
-     &           temp, eps23
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, slamch
-      external   slapy2, slamch
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------------------------------------%
-c     | Convergence test: unlike in the symmetric code, I am not    |
-c     | using things like refined error bounds and gap condition    |
-c     | because I don't know the exact equivalent concept.          |
-c     |                                                             |
-c     | Instead the i-th Ritz value is considered "converged" when: |
-c     |                                                             |
-c     |     bounds(i) .le. ( TOL * | ritz | )                       |
-c     |                                                             |
-c     | for some appropriate choice of norm.                        |
-c     %-------------------------------------------------------------%
-c
-      call arscnd (t0)
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-      nconv  = 0
-      do 20 i = 1, n
-         temp = max( eps23, slapy2( ritzr(i), ritzi(i) ) )
-         if (bounds(i) .le. tol*temp)   nconv = nconv + 1
-   20 continue
-c
-      call arscnd (t1)
-      tnconv = tnconv + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of snconv |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneigh.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneigh.f
deleted file mode 100644
index 7ffb48658e..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneigh.f
+++ /dev/null
@@ -1,318 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call sneigh
-c     ( RNORM, N, H, LDH, RITZR, RITZI, BOUNDS, Q, LDQ, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Real N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZR,  Real arrays of length N.  (OUTPUT)
-c  RITZI   On output, RITZR(1:N) (resp. RITZI(1:N)) contains the real
-c          (respectively imaginary) parts of the eigenvalues of H.
-c
-c  BOUNDS  Real array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues RITZR and RITZI.  This is equal to RNORM
-c          times the last components of the eigenvectors corresponding
-c          to the eigenvalues in RITZR and RITZI.
-c
-c  Q       Real N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from slahqr or strevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     slahqr  LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix and last row of the Schur vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     slacpy  LAPACK matrix copy routine.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     strevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sneigh (rnorm, n, h, ldh, ritzr, ritzi, bounds,
-     &                   q, ldq, workl, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(n), h(ldh,n), q(ldq,n), ritzi(n), ritzr(n),
-     &           workl(n*(n+3))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    i, iconj, msglvl
-      Real
-     &           temp, vl(1)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, slacpy, slahqr, strevc, svout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, snrm2
-      external   slapy2, snrm2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mneigh
-c
-      if (msglvl .gt. 2) then
-          call smout (logfil, n, n, h, ldh, ndigit,
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the    |
-c     |    corresponding Schur vectors and the full Schur form T  |
-c     |    of the current upper Hessenberg matrix H.              |
-c     | slahqr returns the full Schur form of H in WORKL(1:N**2)  |
-c     | and the last components of the Schur vectors in BOUNDS.   |
-c     %-----------------------------------------------------------%
-c
-      call slacpy ('All', n, n, h, ldh, workl, n)
-      do 5 j = 1, n-1
-          bounds(j) = zero
-   5  continue
-      bounds(n) = one
-      call slahqr(.true., .true., n, 1, n, workl, n, ritzr, ritzi, 1, 1,
-     &            bounds, 1, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and  |
-c     |    apply the last components of the Schur vectors to get  |
-c     |    the last components of the corresponding eigenvectors. |
-c     | Remember that if the i-th and (i+1)-st eigenvalues are    |
-c     | complex conjugate pairs, then the real & imaginary part   |
-c     | of the eigenvector components are split across adjacent   |
-c     | columns of Q.                                             |
-c     %-----------------------------------------------------------%
-c
-      call strevc ('R', 'A', select, n, workl, n, vl, n, q, ldq,
-     &             n, n, workl(n*n+1), ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | euclidean norms are all one. LAPACK subroutine |
-c     | strevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      iconj = 0
-      do 10 i=1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c
-            temp = snrm2( n, q(1,i), 1 )
-            call sscal ( n, one / temp, q(1,i), 1 )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we further normalize by the      |
-c           | square root of two.                       |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               temp = slapy2( snrm2( n, q(1,i), 1 ),
-     &                        snrm2( n, q(1,i+1), 1 ) )
-               call sscal ( n, one / temp, q(1,i), 1 )
-               call sscal ( n, one / temp, q(1,i+1), 1 )
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   10 continue
-c
-      call sgemv ('T', n, n, one, q, ldq, bounds, 1, zero, workl, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      iconj = 0
-      do 20 i = 1, n
-         if ( abs( ritzi(i) ) .le. zero ) then
-c
-c           %----------------------%
-c           | Real eigenvalue case |
-c           %----------------------%
-c
-            bounds(i) = rnorm * abs( workl(i) )
-         else
-c
-c           %-------------------------------------------%
-c           | Complex conjugate pair case. Note that    |
-c           | since the real and imaginary part of      |
-c           | the eigenvector are stored in consecutive |
-c           | columns, we need to take the magnitude    |
-c           | of the last components of the two vectors |
-c           %-------------------------------------------%
-c
-            if (iconj .eq. 0) then
-               bounds(i) = rnorm * slapy2( workl(i), workl(i+1) )
-               bounds(i+1) = bounds(i)
-               iconj = 1
-            else
-               iconj = 0
-            end if
-         end if
-   20 continue
-c
-      if (msglvl .gt. 2) then
-         call svout (logfil, n, ritzr, ndigit,
-     &              '_neigh: Real part of the eigenvalues of H')
-         call svout (logfil, n, ritzi, ndigit,
-     &              '_neigh: Imaginary part of the eigenvalues of H')
-         call svout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd (t1)
-      tneigh = tneigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sneigh |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneupd.f
deleted file mode 100644
index 1c2c7ce16c..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sneupd.f
+++ /dev/null
@@ -1,1070 +0,0 @@
-c\BeginDoc
-c
-c\Name: sneupd
-c
-c\Description:
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to SNAUPD.  SNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.  The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  See documentation in the header of the subroutine SNAUPD for
-c  definition of OP as well as other terms and the relation of computed
-c  Ritz values and Ritz vectors of OP with respect to the given problem
-c  A*z = lambda*B*z.  For a brief description, see definitions of
-c  IPARAM(7), MODE and WHICH in the documentation of SNAUPD.
-c
-c\Usage:
-c  call sneupd
-c     ( RVEC, HOWMNY, SELECT, DR, DI, Z, LDZ, SIGMAR, SIGMAI, WORKEV, BMAT,
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL,
-c       LWORKL, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute the Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value (DR(j), DI(j)), SELECT(j) must be set to .TRUE..
-c          If HOWMNY = 'A' or 'P', SELECT is used as internal workspace.
-c
-c  DR      Real  array of dimension NEV+1.  (OUTPUT)
-c          If IPARAM(7) = 1,2 or 3 and SIGMAI=0.0  then on exit: DR contains
-c          the real part of the Ritz  approximations to the eigenvalues of
-c          A*z = lambda*B*z.
-c          If IPARAM(7) = 3, 4 and SIGMAI is not equal to zero, then on exit:
-c          DR contains the real part of the Ritz values of OP computed by
-c          SNAUPD. A further computation must be performed by the user
-c          to transform the Ritz values computed for OP by SNAUPD to those
-c          of the original system A*z = lambda*B*z. See remark 3 below.
-c
-c  DI      Real  array of dimension NEV+1.  (OUTPUT)
-c          On exit, DI contains the imaginary part of the Ritz value
-c          approximations to the eigenvalues of A*z = lambda*B*z associated
-c          with DR.
-c
-c          NOTE: When Ritz values are complex, they will come in complex
-c                conjugate pairs.  If eigenvectors are requested, the
-c                corresponding Ritz vectors will also come in conjugate
-c                pairs and the real and imaginary parts of these are
-c                represented in two consecutive columns of the array Z
-c                (see below).
-c
-c  Z       Real  N by NEV+1 array if RVEC = .TRUE. and HOWMNY = 'A'. (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of
-c          Z represent approximate eigenvectors (Ritz vectors) corresponding
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          The complex Ritz vector associated with the Ritz value
-c          with positive imaginary part is stored in two consecutive
-c          columns.  The first column holds the real part of the Ritz
-c          vector and the second column holds the imaginary part.  The
-c          Ritz vector associated with the Ritz value with negative
-c          imaginary part is simply the complex conjugate of the Ritz vector
-c          associated with the positive imaginary part.
-c
-c          If  RVEC = .FALSE. or HOWMNY = 'P', then Z is not referenced.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by SNAUPD.  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ >= max( 1, N ).  In any case,  LDZ >= 1.
-c
-c  SIGMAR  Real   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the real part of the shift.
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  SIGMAI  Real   (INPUT)
-c          If IPARAM(7) = 3 or 4, represents the imaginary part of the shift.
-c          Not referenced if IPARAM(7) = 1 or 2. See remark 3 below.
-c
-c  WORKEV  Real  work array of dimension 3*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to SNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to SNEUPD following the last call
-c         to SNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to SNAUPD and the call to SNEUPD.
-c
-c  Three of these parameters (V, WORKL, INFO) are also output parameters:
-c
-c  V       Real  N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by SNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.  See Remark 2 below.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+3*ncv) contains information obtained in
-c          snaupd.  They are not changed by sneupd.
-c          WORKL(ncv*ncv+3*ncv+1:3*ncv*ncv+6*ncv) holds the
-c          real and imaginary part of the untransformed Ritz values,
-c          the upper quasi-triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by sneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the real part of the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): pointer to the imaginary part of the NCV RITZ values of
-c                     the original system.
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper quasi-triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     sneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine slahqr
-c                could not be reordered by LAPACK routine strsen.
-c                Re-enter subroutine sneupd with IPARAM(5)=NCV and
-c                increase the size of the arrays DR and DI to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from calculation of a real Schur form.
-c                Informational error from LAPACK routine slahqr.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine strevc.
-c          = -10: IPARAM(7) must be 1,2,3,4.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: SNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: DNEUPD got a different count of the number of converged
-c                 Ritz values than DNAUPD got.  This indicates the user
-c                 probably made an error in passing data from DNAUPD to
-c                 DNEUPD or that the data was modified before entering
-c                 DNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "Complex Shift and Invert Strategies for
-c     Real Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     smout   ARPACK utility routine that prints matrices
-c     svout   ARPACK utility routine that prints vectors.
-c     sgeqr2  LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     slacpy  LAPACK matrix copy routine.
-c     slahqr  LAPACK routine to compute the real Schur form of an
-c             upper Hessenberg matrix.
-c     slamch  LAPACK routine that determines machine constants.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slaset  LAPACK matrix initialization routine.
-c     sorm2r  LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     strevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper quasi-triangular form.
-c     strsen  LAPACK routine that re-orders the Schur form.
-c     strmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     sger    Level 2 BLAS rank one update to a matrix.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c     Let trans(X) denote the transpose of X.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .TRUE. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c     trans(V(:,1:IPARAM(5))) * V(:,1:IPARAM(5)) = I are approximately
-c     satisfied. Here T is the leading submatrix of order IPARAM(5) of the
-c     real upper quasi-triangular matrix stored workl(ipntr(12)). That is,
-c     T is block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
-c     each 2-by-2 diagonal block has its diagonal elements equal and its
-c     off-diagonal elements of opposite sign.  Corresponding to each 2-by-2
-c     diagonal block is a complex conjugate pair of Ritz values. The real
-c     Ritz values are stored on the diagonal of T.
-c
-c  3. If IPARAM(7) = 3 or 4 and SIGMAI is not equal zero, then the user must
-c     form the IPARAM(5) Rayleigh quotients in order to transform the Ritz
-c     values computed by SNAUPD for OP to those of A*z = lambda*B*z.
-c     Set RVEC = .true. and HOWMNY = 'A', and
-c     compute
-c           trans(Z(:,I)) * A * Z(:,I) if DI(I) = 0.
-c     If DI(I) is not equal to zero and DI(I+1) = - D(I),
-c     then the desired real and imaginary parts of the Ritz value are
-c           trans(Z(:,I)) * A * Z(:,I) +  trans(Z(:,I+1)) * A * Z(:,I+1),
-c           trans(Z(:,I)) * A * Z(:,I+1) -  trans(Z(:,I+1)) * A * Z(:,I),
-c     respectively.
-c     Another possibility is to set RVEC = .true. and HOWMNY = 'P' and
-c     compute trans(V(:,1:IPARAM(5))) * A * V(:,1:IPARAM(5)) and then an upper
-c     quasi-triangular matrix of order IPARAM(5) is computed. See remark
-c     2 above.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.7   DATE OF SID: 09/20/00   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine sneupd(rvec , howmny, select, dr    , di,
-     &                   z    , ldz   , sigmar, sigmai, workev,
-     &                   bmat , n     , which , nev   , tol,
-     &                   resid, ncv   , v     , ldv   , iparam,
-     &                   ipntr, workd , workl , lworkl, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Real
-     &           sigmar, sigmai, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Real
-     &           dr(nev+1)    , di(nev+1), resid(n)  ,
-     &           v(ldv,ncv)   , z(ldz,*) , workd(3*n),
-     &           workl(lworkl), workev(3*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds   ,
-     &           iheigr, iheigi, iconj , nconv   ,
-     &           invsub, iuptri, iwev  , iwork(1),
-     &           j     , k     , ldh   , ldq     ,
-     &           mode  , msglvl, outncv, ritzr   ,
-     &           ritzi , wri   , wrr   , irr     ,
-     &           iri   , ibd   , ishift, numcnv  ,
-     &           np    , jj    , nconv2
-      logical    reord
-      Real
-     &           conds  , rnorm, sep  , temp,
-     &           vl(1,1), temp1, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sger  , sgeqr2, slacpy,
-     &           slahqr, slaset, smout , sorm2r,
-     &           strevc, strmm , strsen, sscal ,
-     &           svout , ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2, snrm2, slamch, sdot
-      external   slapy2, snrm2, slamch, sdot
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs, min, sqrt
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mneupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 6*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 .and. sigmai .eq. zero) then
-         type = 'SHIFTI'
-      else if (mode .eq. 3 ) then
-         type = 'REALPT'
-      else if (mode .eq. 4 ) then
-         type = 'IMAGPT'
-      else
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary   |
-c     |                                   parts of ritz values |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds   |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by SNEUPD.                  |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                             real part of the Ritz values. |
-c     | workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed |
-c     |                        imaginary part of the Ritz values. |
-c     | workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed |
-c     |                           error bounds of the Ritz values |
-c     | workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper |
-c     |                             quasi-triangular matrix for H |
-c     | workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the    |
-c     |       associated matrix representation of the invariant   |
-c     |       subspace for H.                                     |
-c     | GRAND total of NCV * ( 3 * NCV + 6 ) locations.           |
-c     %-----------------------------------------------------------%
-c
-      ih     = ipntr(5)
-      ritzr  = ipntr(6)
-      ritzi  = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheigr = bounds + ldh
-      iheigi = iheigr + ldh
-      ihbds  = iheigi + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheigr
-      ipntr(10) = iheigi
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wrr = 1
-      wri = ncv + 1
-      iwev = wri + ncv
-c
-c     %-----------------------------------------%
-c     | irr points to the REAL part of the Ritz |
-c     |     values computed by _neigh before    |
-c     |     exiting _naup2.                     |
-c     | iri points to the IMAGINARY part of the |
-c     |     Ritz values computed by _neigh      |
-c     |     before exiting _naup2.              |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irr = ipntr(14)+ncv*ncv
-      iri = irr+ncv
-      ibd = iri+ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call svout(logfil, ncv, workl(irr), ndigit,
-     &   '_neupd: Real part of Ritz values passed in from _NAUPD.')
-         call svout(logfil, ncv, workl(iri), ndigit,
-     &   '_neupd: Imag part of Ritz values passed in from _NAUPD.')
-         call svout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call sngets(ishift       , which     , nev       ,
-     &                np           , workl(irr), workl(iri),
-     &                workl(bounds), workl     , workl(np+1))
-c
-         if (msglvl .gt. 2) then
-            call svout(logfil, ncv, workl(irr), ndigit,
-     &      '_neupd: Real part of Ritz values after calling _NGETS.')
-            call svout(logfil, ncv, workl(iri), ndigit,
-     &      '_neupd: Imag part of Ritz values after calling _NGETS.')
-            call svout(logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23,
-     &                 slapy2( workl(irr+ncv-j), workl(iri+ncv-j) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nconv) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, [numcnv], ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, [nconv], ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine slahqr to compute the real Schur form |
-c        | of the upper Hessenberg matrix returned by SNAUPD.        |
-c        | Make a copy of the upper Hessenberg matrix.               |
-c        | Initialize the Schur vector matrix Q to the identity.     |
-c        %-----------------------------------------------------------%
-c
-         call scopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call slaset('All', ncv, ncv,
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call slahqr(.true., .true.       , ncv,
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheigr), workl(iheigi),
-     &                1     , ncv          , workl(invsub),
-     &                ldq   , ierr)
-         call scopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call svout(logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H')
-            call svout(logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imaginary part of the Eigenvalues of H')
-            call svout(logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call smout(logfil       , ncv, ncv   ,
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper quasi-triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------------%
-c           | Reorder the computed upper quasi-triangular matrix. |
-c           %-----------------------------------------------------%
-c
-            call strsen('None'       , 'V'          ,
-     &                   select       , ncv          ,
-     &                   workl(iuptri), ldh          ,
-     &                   workl(invsub), ldq          ,
-     &                   workl(iheigr), workl(iheigi),
-     &                   nconv2       , conds        ,
-     &                   sep          , workl(ihbds) ,
-     &                   ncv          , iwork        ,
-     &                   1            , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call svout(logfil, ncv, workl(iheigr), ndigit,
-     &           '_neupd: Real part of the eigenvalues of H--reordered')
-                call svout(logfil, ncv, workl(iheigi), ndigit,
-     &           '_neupd: Imag part of the eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call smout(logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &             '_neupd: Quasi-triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------%
-c        | Copy the last row of the Schur vector |
-c        | into workl(ihbds).  This will be used |
-c        | to compute the Ritz estimates of      |
-c        | converged Ritz values.                |
-c        %---------------------------------------%
-c
-         call scopy(ncv, workl(invsub+ncv-1), ldq, workl(ihbds), 1)
-c
-c        %----------------------------------------------------%
-c        | Place the computed eigenvalues of H into DR and DI |
-c        | if a spectral transformation was not used.         |
-c        %----------------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call sgeqr2(ncv, nconv , workl(invsub),
-     &               ldq, workev, workev(ncv+1),
-     &               ierr)
-c
-c        %---------------------------------------------------------%
-c        | * Postmultiply V by Q using sorm2r.                     |
-c        | * Copy the first NCONV columns of VQ into Z.            |
-c        | * Postmultiply Z by R.                                  |
-c        | The N by NCONV matrix Z is now a matrix representation  |
-c        | of the approximate invariant subspace associated with   |
-c        | the Ritz values in workl(iheigr) and workl(iheigi)      |
-c        | The first NCONV columns of V are now approximate Schur  |
-c        | vectors associated with the real upper quasi-triangular |
-c        | matrix of order NCONV in workl(iuptri)                  |
-c        %---------------------------------------------------------%
-c
-         call sorm2r('Right', 'Notranspose', n            ,
-     &                ncv   , nconv        , workl(invsub),
-     &                ldq   , workev       , v            ,
-     &                ldv   , workd(n+1)   , ierr)
-         call slacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | quasi-triangular form of workl(iuptri,ldq)        |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones           |
-c           %---------------------------------------------------%
-c
-            if (workl(invsub+(j-1)*ldq+j-1) .lt. zero) then
-               call sscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call sscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call strevc('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | strevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1;                                   |
-c           %------------------------------------------------%
-c
-            iconj = 0
-            do 40 j=1, nconv
-c
-               if ( workl(iheigi+j-1) .eq. zero ) then
-c
-c                 %----------------------%
-c                 | real eigenvalue case |
-c                 %----------------------%
-c
-                  temp = snrm2( ncv, workl(invsub+(j-1)*ldq), 1 )
-                  call sscal( ncv, one / temp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-               else
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 | columns, we further normalize by the      |
-c                 | square root of two.                       |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     temp = slapy2(snrm2(ncv,
-     &                                   workl(invsub+(j-1)*ldq),
-     &                                   1),
-     &                             snrm2(ncv,
-     &                                   workl(invsub+j*ldq),
-     &                                   1))
-                     call sscal(ncv, one/temp,
-     &                           workl(invsub+(j-1)*ldq), 1 )
-                     call sscal(ncv, one/temp,
-     &                           workl(invsub+j*ldq), 1 )
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-c
-               end if
-c
- 40         continue
-c
-            call sgemv('T', ncv, nconv, one, workl(invsub),
-     &                 ldq, workl(ihbds), 1, zero,  workev, 1)
-c
-            iconj = 0
-            do 45 j=1, nconv
-               if (workl(iheigi+j-1) .ne. zero) then
-c
-c                 %-------------------------------------------%
-c                 | Complex conjugate pair case. Note that    |
-c                 | since the real and imaginary part of      |
-c                 | the eigenvector are stored in consecutive |
-c                 %-------------------------------------------%
-c
-                  if (iconj .eq. 0) then
-                     workev(j) = slapy2(workev(j), workev(j+1))
-                     workev(j+1) = workev(j)
-                     iconj = 1
-                  else
-                     iconj = 0
-                  end if
-               end if
- 45         continue
-c
-            if (msglvl .gt. 2) then
-               call scopy(ncv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call svout(logfil, ncv, workl(ihbds), ndigit,
-     &              '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call smout(logfil, ncv, ncv, workl(invsub), ldq,
-     &                 ndigit, '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call scopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %---------------------------------------------------------%
-c           | Compute the QR factorization of the eigenvector matrix  |
-c           | associated with leading portion of T in the first NCONV |
-c           | columns of workl(invsub,ldq).                           |
-c           %---------------------------------------------------------%
-c
-            call sgeqr2(ncv, nconv , workl(invsub),
-     &                   ldq, workev, workev(ncv+1),
-     &                   ierr)
-c
-c           %----------------------------------------------%
-c           | * Postmultiply Z by Q.                       |
-c           | * Postmultiply Z by R.                       |
-c           | The N by NCONV matrix Z is now contains the  |
-c           | Ritz vectors associated with the Ritz values |
-c           | in workl(iheigr) and workl(iheigi).          |
-c           %----------------------------------------------%
-c
-            call sorm2r('Right', 'Notranspose', n            ,
-     &                   ncv  , nconv        , workl(invsub),
-     &                   ldq  , workev       , z            ,
-     &                   ldz  , workd(n+1)   , ierr)
-c
-            call strmm('Right'   , 'Upper'       , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-c
-         end if
-c
-      else
-c
-c        %------------------------------------------------------%
-c        | An approximate invariant subspace is not needed.     |
-c        | Place the Ritz values computed SNAUPD into DR and DI |
-c        %------------------------------------------------------%
-c
-         call scopy(nconv, workl(ritzr), 1, dr, 1)
-         call scopy(nconv, workl(ritzi), 1, di, 1)
-         call scopy(nconv, workl(ritzr), 1, workl(iheigr), 1)
-         call scopy(nconv, workl(ritzi), 1, workl(iheigi), 1)
-         call scopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec)
-     &      call sscal(ncv, rnorm, workl(ihbds), 1)
-c
-      else
-c
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (type .eq. 'SHIFTI') then
-c
-            if (rvec)
-     &         call sscal(ncv, rnorm, workl(ihbds), 1)
-c
-            do 50 k=1, ncv
-               temp = slapy2( workl(iheigr+k-1),
-     &                        workl(iheigi+k-1) )
-               workl(ihbds+k-1) = abs( workl(ihbds+k-1) )
-     &                          / temp / temp
- 50         continue
-c
-         else if (type .eq. 'REALPT') then
-c
-            do 60 k=1, ncv
- 60         continue
-c
-         else if (type .eq. 'IMAGPT') then
-c
-            do 70 k=1, ncv
- 70         continue
-c
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | *  Transform the Ritz values back to the original system. |
-c        |    For TYPE = 'SHIFTI' the transformation is              |
-c        |             lambda = 1/theta + sigma                      |
-c        |    For TYPE = 'REALPT' or 'IMAGPT' the user must from     |
-c        |    Rayleigh quotients or a projection. See remark 3 above.|
-c        | NOTES:                                                    |
-c        | *The Ritz vectors are not affected by the transformation. |
-c        %-----------------------------------------------------------%
-c
-         if (type .eq. 'SHIFTI') then
-c
-            do 80 k=1, ncv
-               temp = slapy2( workl(iheigr+k-1),
-     &                        workl(iheigi+k-1) )
-               workl(iheigr+k-1) = workl(iheigr+k-1)/temp/temp
-     &                           + sigmar
-               workl(iheigi+k-1) = -workl(iheigi+k-1)/temp/temp
-     &                           + sigmai
- 80         continue
-c
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-c
-         else if (type .eq. 'REALPT' .or. type .eq. 'IMAGPT') then
-c
-            call scopy(nconv, workl(iheigr), 1, dr, 1)
-            call scopy(nconv, workl(iheigi), 1, di, 1)
-c
-         end if
-c
-      end if
-c
-      if (type .eq. 'SHIFTI' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, dr, ndigit,
-     &   '_neupd: Untransformed real part of the Ritz values.')
-         call svout (logfil, nconv, di, ndigit,
-     &   '_neupd: Untransformed imag part of the Ritz values.')
-         call svout(logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Ritz estimates of untransformed Ritz values.')
-      else if (type .eq. 'REGULR' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, dr, ndigit,
-     &   '_neupd: Real parts of converged Ritz values.')
-         call svout (logfil, nconv, di, ndigit,
-     &   '_neupd: Imag parts of converged Ritz values.')
-         call svout(logfil, nconv, workl(ihbds), ndigit,
-     &   '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 2.                                   |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta. Remember that when theta  |
-c        | has nonzero imaginary part, the corresponding  |
-c        | Ritz vector is stored across two columns of Z. |
-c        %------------------------------------------------%
-c
-         iconj = 0
-         do 110 j=1, nconv
-            if ((workl(iheigi+j-1) .eq. zero) .and.
-     &           (workl(iheigr+j-1) .ne. zero)) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheigr+j-1)
-            else if (iconj .eq. 0) then
-               temp = slapy2( workl(iheigr+j-1), workl(iheigi+j-1) )
-               if (temp. ne. zero) then
-                  workev(j) = ( workl(invsub+(j-1)*ldq+ncv-1) *
-     &                          workl(iheigr+j-1) +
-     &                          workl(invsub+j*ldq+ncv-1) *
-     &                          workl(iheigi+j-1) ) / temp / temp
-                  workev(j+1) = ( workl(invsub+j*ldq+ncv-1) *
-     &                            workl(iheigr+j-1) -
-     &                            workl(invsub+(j-1)*ldq+ncv-1) *
-     &                            workl(iheigi+j-1) ) / temp / temp
-               end if
-               iconj = 1
-            else
-               iconj = 0
-            end if
- 110     continue
-c
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call sger(n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of SNEUPD |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sngets.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sngets.f
deleted file mode 100644
index 7e48c0bb18..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sngets.f
+++ /dev/null
@@ -1,231 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sngets
-c
-c\Description:
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call sngets
-c     ( ISHIFT, WHICH, KEV, NP, RITZR, RITZI, BOUNDS, SHIFTR, SHIFTI )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest real part.
-c          'SR' -> want the KEV eigenvalues of smallest real part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV      Integer.  (INPUT/OUTPUT)
-c           INPUT: KEV+NP is the size of the matrix H.
-c           OUTPUT: Possibly increases KEV by one to keep complex conjugate
-c           pairs together.
-c
-c  NP       Integer.  (INPUT/OUTPUT)
-c           Number of implicit shifts to be computed.
-c           OUTPUT: Possibly decreases NP by one to keep complex conjugate
-c           pairs together.
-c
-c  RITZR,  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c  RITZI   On INPUT, RITZR and RITZI contain the real and imaginary
-c          parts of the eigenvalues of H.
-c          On OUTPUT, RITZR and RITZI are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are
-c          selected, the unwanted part corresponds to the shifts to
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTR, SHIFTI  *** USE deprecated as of version 2.1. ***
-c
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     ssortc  ARPACK sorting routine.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. xxxx
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sngets ( ishift, which, kev, np, ritzr, ritzi, bounds,
-     &                    shiftr, shifti )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(kev+np), ritzr(kev+np), ritzi(kev+np),
-     &           shiftr(1), shifti(1)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0, zero = 0.0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, ssortc, arscnd
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mngets
-c
-c     %----------------------------------------------------%
-c     | LM, SM, LR, SR, LI, SI case.                       |
-c     | Sort the eigenvalues of H into the desired order   |
-c     | and apply the resulting order to BOUNDS.           |
-c     | The eigenvalues are sorted so that the wanted part |
-c     | are always in the last KEV locations.              |
-c     | We first do a pre-processing sort in order to keep |
-c     | complex conjugate pairs together                   |
-c     %----------------------------------------------------%
-c
-      if (which .eq. 'LM') then
-         call ssortc ('LR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SM') then
-         call ssortc ('SR', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LR') then
-         call ssortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SR') then
-         call ssortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'LI') then
-         call ssortc ('LM', .true., kev+np, ritzr, ritzi, bounds)
-      else if (which .eq. 'SI') then
-         call ssortc ('SM', .true., kev+np, ritzr, ritzi, bounds)
-      end if
-c
-      call ssortc (which, .true., kev+np, ritzr, ritzi, bounds)
-c
-c     %-------------------------------------------------------%
-c     | Increase KEV by one if the ( ritzr(np),ritzi(np) )    |
-c     | = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero |
-c     | Accordingly decrease NP by one. In other words keep   |
-c     | complex conjugate pairs together.                     |
-c     %-------------------------------------------------------%
-c
-      if (       ( ritzr(np+1) - ritzr(np) ) .eq. zero
-     &     .and. ( ritzi(np+1) + ritzi(np) ) .eq. zero ) then
-         np = np - 1
-         kev = kev + 1
-      end if
-c
-      if ( ishift .eq. 1 ) then
-c
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when they shifts |
-c        | are applied in subroutine snapps.                     |
-c        | Be careful and use 'SR' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c
-         call ssortc ( 'SR', .true., np, bounds, ritzr, ritzi )
-      end if
-c
-      call arscnd (t1)
-      tngets = tngets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
-         call svout (logfil, kev+np, ritzr, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- real part')
-         call svout (logfil, kev+np, ritzi, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix -- imag part')
-         call svout (logfil, kev+np, bounds, ndigit,
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c
-      return
-c
-c     %---------------%
-c     | End of sngets |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaitr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaitr.f
deleted file mode 100644
index a5df2c2ec7..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaitr.f
+++ /dev/null
@@ -1,853 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaitr
-c
-c\Description:
-c  Reverse communication interface for applying NP additional steps to
-c  a K step symmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in ssaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call ssaitr
-c     ( IDO, BMAT, N, K, NP, MODE, RESID, RNORM, V, LDV, H, LDH,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and does not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of matrix B that defines the
-c          semi-inner product for the operator OP.  See ssaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current order of H and the number of columns of V.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  MODE    Integer.  (INPUT)
-c          Signifies which form for "OP". If MODE=2 then
-c          a reduction in the number of B matrix vector multiplies
-c          is possible since the B-norm of OP*x is equivalent to
-c          the inv(B)-norm of A*x.
-c
-c  RESID   Real array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Real scalar.  (INPUT/OUTPUT)
-c          On INPUT the B-norm of r_{k}.
-c          On OUTPUT the B-norm of the updated residual r_{k+p}.
-c
-c  V       Real N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (K+NP) by 2 array.  (INPUT/OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          with the subdiagonal in the first column starting at H(2,1)
-c          and the main diagonal in the second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On INPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K step Arnoldi factorization. Used to save some
-c          computation at the first step.
-c          On OUTPUT, WORKD(1:N) = B*RESID where RESID is associated
-c          with the K+NP step Arnoldi factorization.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of an invariant subspace of OP is found that is
-c               less than K + NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     sgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     smout   ARPACK utility routine that prints matrices.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     sscal   Level 1 BLAS that scales a vector.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: saitr.F   SID: 2.6   DATE OF SID: 8/28/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k};
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in ssaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        alphaj <- j-th component of w_{j}
-c        rnorm = || r_{j} ||
-c        betaj+1 = rnorm
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaitr
-     &   (ido, bmat, n, k, np, mode, resid, rnorm, v, ldv, h, ldh,
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, mode, np
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           h(ldh,2), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    i, ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           infol, jj
-      Real
-     &           rnorm1, wnorm, safmin, temp1
-      save       orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           rnorm1, safmin, wnorm
-c
-c     %-----------------------%
-c     | Local Array Arguments |
-c     %-----------------------%
-c
-      Real
-     &           xtemp(2)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, sgemv, sgetv0, svout, smout,
-     &           slascl, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slamch
-      external   sdot, snrm2, slamch
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data      first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         first = .false.
-c
-c        %--------------------------------%
-c        | safmin = safe minimum is such  |
-c        | that 1/sfmin does not overflow |
-c        %--------------------------------%
-c
-         safmin = slamch('safmin')
-      end if
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaitr
-c
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-c
-c        %--------------------------------%
-c        | Pointer to the current step of |
-c        | the factorization to build     |
-c        %--------------------------------%
-c
-         j      = k + 1
-c
-c        %------------------------------------------%
-c        | Pointers used for reverse communication  |
-c        | when using WORKD.                        |
-c        %------------------------------------------%
-c
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true.                                  |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         sgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %------------------------------%
-c     | Else this is the first step. |
-c     %------------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [j], ndigit,
-     &                  '_saitr: generating Arnoldi vector no.')
-            call svout (logfil, 1, [rnorm], ndigit,
-     &                  '_saitr: B-norm of the current residual =')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Check for exact zero. Equivalent to determining whether |
-c        | a j-step Arnoldi factorization is present.              |
-c        %---------------------------------------------------------%
-c
-         if (rnorm .gt. zero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [j], ndigit,
-     &                     '_saitr: ****** restart at step ******')
-            end if
-c
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call sgetv0 (ido, bmat, itry, .false., n, j, v, ldv,
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tsaitr = tsaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call scopy (n, resid, 1, v(1,j), 1)
-         if (rnorm .ge. safmin) then
-             temp1 = one / rnorm
-             call sscal (n, temp1, v(1,j), 1)
-             call sscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine SLASCL               |
-c            %-----------------------------------------%
-c
-             call slascl ('General', i, i, rnorm, one, n, 1,
-     &                    v(1,j), n, infol)
-             call slascl ('General', i, i, rnorm, one, n, 1,
-     &                    workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call scopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c
-         go to 9000
-   50    continue
-c
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}.   |
-c        %-----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-c
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call scopy (n, workd(irj), 1, resid, 1)
-c
-c        %-------------------------------------------%
-c        | STEP 4:  Finish extending the symmetric   |
-c        |          Arnoldi to length j. If MODE = 2 |
-c        |          then B*OP = B*inv(B)*A = A and   |
-c        |          we don't need to compute B*OP.   |
-c        | NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is   |
-c        | assumed to have A*v_{j}.                  |
-c        %-------------------------------------------%
-c
-         if (mode .eq. 2) go to 65
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-              call scopy(n, resid, 1 , workd(ipj), 1)
-         end if
-   60    continue
-c
-c        %-----------------------------------%
-c        | Back from reverse communication;  |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}. |
-c        %-----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-   65    continue
-         if (mode .eq. 2) then
-c
-c           %----------------------------------%
-c           | Note that the B-norm of OP*v_{j} |
-c           | is the inv(B)-norm of A*v_{j}.   |
-c           %----------------------------------%
-c
-            wnorm = sdot (n, resid, 1, workd(ivj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'G') then
-            wnorm = sdot (n, resid, 1, workd(ipj), 1)
-            wnorm = sqrt(abs(wnorm))
-         else if (bmat .eq. 'I') then
-            wnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         if (mode .ne. 2 ) then
-            call sgemv('T', n, j, one, v, ldv, workd(ipj), 1, zero,
-     &                  workd(irj), 1)
-         else if (mode .eq. 2) then
-            call sgemv('T', n, j, one, v, ldv, workd(ivj), 1, zero,
-     &                  workd(irj), 1)
-         end if
-c
-c        %--------------------------------------%
-c        | Orthgonalize r_{j} against V_{j}.    |
-c        | RESID contains OP*v_{j}. See STEP 3. |
-c        %--------------------------------------%
-c
-         call sgemv('N', n, j, -one, v, ldv, workd(irj), 1, one,
-     &               resid, 1)
-c
-c        %--------------------------------------%
-c        | Extend H to have j rows and columns. |
-c        %--------------------------------------%
-c
-         h(j,2) = workd(irj + j - 1)
-         if (j .eq. 1  .or.  rstart) then
-            h(j,1) = zero
-         else
-            h(j,1) = rnorm
-         end if
-         call arscnd (t4)
-c
-         orth1 = .true.
-         iter  = 0
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then
-            rnorm = sdot (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        %-----------------------------------------------------------%
-c
-         if (rnorm .gt. 0.717*wnorm) go to 100
-         nrorth = nrorth + 1
-c
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            xtemp(1) = wnorm
-            xtemp(2) = rnorm
-            call svout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: re-orthonalization ; wnorm and rnorm are')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call sgemv ('T', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, workd(irj), 1)
-c
-c        %----------------------------------------------%
-c        | Compute the correction to the residual:      |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).  |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J) + |
-c        | v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j, but only   |
-c        | H(j,j) is updated.                           |
-c        %----------------------------------------------%
-c
-         call sgemv ('N', n, j, -one, v, ldv, workd(irj), 1,
-     &               one, resid, 1)
-c
-         if (j .eq. 1  .or.  rstart) h(j,1) = zero
-         h(j,2) = h(j,2) + workd(irj + j - 1)
-c
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             rnorm1 = sdot (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt(abs(rnorm1))
-         else if (bmat .eq. 'I') then
-             rnorm1 = snrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0) then
-            call ivout (logfil, 1, [j], ndigit,
-     &           '_saitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                xtemp(1) = rnorm
-                xtemp(2) = rnorm1
-                call svout (logfil, 2, xtemp, ndigit,
-     &           '_saitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if (rnorm1 .gt. 0.717*rnorm) then
-c
-c           %--------------------------------%
-c           | No need for further refinement |
-c           %--------------------------------%
-c
-            rnorm = rnorm1
-c
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = zero
-         end if
-c
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c
-         rstart = .false.
-         orth2  = .false.
-c
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c
-c        %----------------------------------------------------------%
-c        | Make sure the last off-diagonal element is non negative  |
-c        | If not perform a similarity transformation on H(1:j,1:j) |
-c        | and scale v(:,j) by -1.                                  |
-c        %----------------------------------------------------------%
-c
-         if (h(j,1) .lt. zero) then
-            h(j,1) = -h(j,1)
-            if ( j .lt. k+np) then
-               call sscal(n, -one, v(1,j+1), 1)
-            else
-               call sscal(n, -one, resid, 1)
-            end if
-         end if
-c
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tsaitr = tsaitr + (t1 - t0)
-            ido = 99
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, k+np, h(1,2), ndigit,
-     &         '_saitr: main diagonal of matrix H of step K+NP.')
-               if (k+np .gt. 1) then
-               call svout (logfil, k+np-1, h(2,1), ndigit,
-     &         '_saitr: sub diagonal of matrix H of step K+NP.')
-               end if
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssaitr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssapps.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssapps.f
deleted file mode 100644
index 77bd9d52c4..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssapps.f
+++ /dev/null
@@ -1,516 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP shifts implicitly resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix of order KEV+NP. Q is the product of
-c  rotations resulting from the NP bulge chasing sweeps.  The updated Arnoldi
-c  factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call ssapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. dimension of matrix A.
-c
-c  KEV     Integer.  (INPUT)
-c          INPUT: KEV+NP is the size of the input matrix H.
-c          OUTPUT: KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Real array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Real N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          INPUT: V contains the current KEV+NP Arnoldi vectors.
-c          OUTPUT: VNEW = V(1:n,1:KEV); the updated Arnoldi vectors
-c          are in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (KEV+NP) by 2 array.  (INPUT/OUTPUT)
-c          INPUT: H contains the symmetric tridiagonal matrix of the
-c          Arnoldi factorization with the subdiagonal in the 1st column
-c          starting at H(2,1) and the main diagonal in the 2nd column.
-c          OUTPUT: H contains the updated tridiagonal matrix in the
-c          KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Real array of length (N).  (INPUT/OUTPUT)
-c          INPUT: RESID contains the the residual vector r_{k+p}.
-c          OUTPUT: RESID is the updated residual vector rnew_{k}.
-c
-c  Q       Real KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations during the bulge
-c          chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKD   Real work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slacpy  LAPACK matrix copy routine.
-c     slaset  LAPACK matrix initialization routine.
-c     sgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: sapps.F   SID: 2.6   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the subblocks of
-c     the tridiagonal matrix H and not just to the submatrix that it
-c     comes from. This routine assumes that the subdiagonal elements
-c     of H that are stored in h(1:kev+np,1) are nonegative upon input
-c     and enforce this condition upon output. This version incorporates
-c     deflation. See code for documentation.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           h(ldh,2), q(ldq,kev+np), resid(n), shift(np),
-     &           v(ldv,kev+np), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, iend, istart, itop, j, jj, kplusp, msglvl
-      logical    first
-      Real
-     &           a1, a2, a3, a4, big, c, epsmch, f, g, r, s
-      save       epsmch, first
-c
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   saxpy, scopy, sscal, slacpy, slartg, slaset, svout,
-     &           ivout, arscnd, sgemv
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs
-c
-c     %----------------%
-c     | Data statements |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-         epsmch = slamch('Epsilon-Machine')
-         first = .false.
-      end if
-      itop = 1
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msapps
-c
-      kplusp = kev + np
-c
-c     %----------------------------------------------%
-c     | Initialize Q to the identity matrix of order |
-c     | kplusp used to accumulate the rotations.     |
-c     %----------------------------------------------%
-c
-      call slaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------------------%
-c     | Apply the np shifts implicitly. Apply each shift to the  |
-c     | whole matrix and not just to the submatrix from which it |
-c     | comes.                                                   |
-c     %----------------------------------------------------------%
-c
-      do 90 jj = 1, np
-c
-         istart = itop
-c
-c        %----------------------------------------------------------%
-c        | Check for splitting and deflation. Currently we consider |
-c        | an off-diagonal element h(i+1,1) negligible if           |
-c        |         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )   |
-c        | for i=1:KEV+NP-1.                                        |
-c        | If above condition tests true then we set h(i+1,1) = 0.  |
-c        | Note that h(1:KEV+NP,1) are assumed to be non negative.  |
-c        %----------------------------------------------------------%
-c
-   20    continue
-c
-c        %------------------------------------------------%
-c        | The following loop exits early if we encounter |
-c        | a negligible off diagonal element.             |
-c        %------------------------------------------------%
-c
-         do 30 i = istart, kplusp-1
-            big   = abs(h(i,2)) + abs(h(i+1,2))
-            if (h(i+1,1) .le. epsmch*big) then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, [i], ndigit,
-     &                 '_sapps: deflation at row/column no.')
-                  call ivout (logfil, 1, [jj], ndigit,
-     &                 '_sapps: occurred before shift number.')
-                  call svout (logfil, 1, h(i+1,1), ndigit,
-     &                 '_sapps: the corresponding off diagonal element')
-               end if
-               h(i+1,1) = zero
-               iend = i
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (istart .lt. iend) then
-c
-c           %--------------------------------------------------------%
-c           | Construct the plane rotation G'(istart,istart+1,theta) |
-c           | that attempts to drive h(istart+1,1) to zero.          |
-c           %--------------------------------------------------------%
-c
-             f = h(istart,2) - shift(jj)
-             g = h(istart+1,1)
-             call slartg (f, g, c, s, r)
-c
-c            %-------------------------------------------------------%
-c            | Apply rotation to the left and right of H;            |
-c            | H <- G' * H * G,  where G = G(istart,istart+1,theta). |
-c            | This will create a "bulge".                           |
-c            %-------------------------------------------------------%
-c
-             a1 = c*h(istart,2)   + s*h(istart+1,1)
-             a2 = c*h(istart+1,1) + s*h(istart+1,2)
-             a4 = c*h(istart+1,2) - s*h(istart+1,1)
-             a3 = c*h(istart+1,1) - s*h(istart,2)
-             h(istart,2)   = c*a1 + s*a2
-             h(istart+1,2) = c*a4 - s*a3
-             h(istart+1,1) = c*a3 + s*a4
-c
-c            %----------------------------------------------------%
-c            | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c            %----------------------------------------------------%
-c
-             do 60 j = 1, min(istart+jj,kplusp)
-                a1            =   c*q(j,istart) + s*q(j,istart+1)
-                q(j,istart+1) = - s*q(j,istart) + c*q(j,istart+1)
-                q(j,istart)   = a1
-   60        continue
-c
-c
-c            %----------------------------------------------%
-c            | The following loop chases the bulge created. |
-c            | Note that the previous rotation may also be  |
-c            | done within the following loop. But it is    |
-c            | kept separate to make the distinction among  |
-c            | the bulge chasing sweeps and the first plane |
-c            | rotation designed to drive h(istart+1,1) to  |
-c            | zero.                                        |
-c            %----------------------------------------------%
-c
-             do 70 i = istart+1, iend-1
-c
-c               %----------------------------------------------%
-c               | Construct the plane rotation G'(i,i+1,theta) |
-c               | that zeros the i-th bulge that was created   |
-c               | by G(i-1,i,theta). g represents the bulge.   |
-c               %----------------------------------------------%
-c
-                f = h(i,1)
-                g = s*h(i+1,1)
-c
-c               %----------------------------------%
-c               | Final update with G(i-1,i,theta) |
-c               %----------------------------------%
-c
-                h(i+1,1) = c*h(i+1,1)
-                call slartg (f, g, c, s, r)
-c
-c               %-------------------------------------------%
-c               | The following ensures that h(1:iend-1,1), |
-c               | the first iend-2 off diagonal of elements |
-c               | H, remain non negative.                   |
-c               %-------------------------------------------%
-c
-                if (r .lt. zero) then
-                   r = -r
-                   c = -c
-                   s = -s
-                end if
-c
-c               %--------------------------------------------%
-c               | Apply rotation to the left and right of H; |
-c               | H <- G * H * G',  where G = G(i,i+1,theta) |
-c               %--------------------------------------------%
-c
-                h(i,1) = r
-c
-                a1 = c*h(i,2)   + s*h(i+1,1)
-                a2 = c*h(i+1,1) + s*h(i+1,2)
-                a3 = c*h(i+1,1) - s*h(i,2)
-                a4 = c*h(i+1,2) - s*h(i+1,1)
-c
-                h(i,2)   = c*a1 + s*a2
-                h(i+1,2) = c*a4 - s*a3
-                h(i+1,1) = c*a3 + s*a4
-c
-c               %----------------------------------------------------%
-c               | Accumulate the rotation in the matrix Q;  Q <- Q*G |
-c               %----------------------------------------------------%
-c
-                do 50 j = 1, min( i+jj, kplusp )
-                   a1       =   c*q(j,i) + s*q(j,i+1)
-                   q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-                   q(j,i)   = a1
-   50           continue
-c
-   70        continue
-c
-         end if
-c
-c        %--------------------------%
-c        | Update the block pointer |
-c        %--------------------------%
-c
-         istart = iend + 1
-c
-c        %------------------------------------------%
-c        | Make sure that h(iend,1) is non-negative |
-c        | If not then set h(iend,1) <-- -h(iend,1) |
-c        | and negate the last column of Q.         |
-c        | We have effectively carried out a        |
-c        | similarity on transformation H           |
-c        %------------------------------------------%
-c
-         if (h(iend,1) .lt. zero) then
-             h(iend,1) = -h(iend,1)
-             call sscal(kplusp, -one, q(1,iend), 1)
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any |
-c        %--------------------------------------------------------%
-c
-         if (iend .lt. kplusp) go to 20
-c
-c        %-----------------------------------------------------%
-c        | Check if we can increase the the start of the block |
-c        %-----------------------------------------------------%
-c
-         do 80 i = itop, kplusp-1
-            if (h(i+1,1) .gt. zero) go to 90
-            itop  = itop + 1
-   80    continue
-c
-c        %-----------------------------------%
-c        | Finished applying the jj-th shift |
-c        %-----------------------------------%
-c
-   90 continue
-c
-c     %------------------------------------------%
-c     | All shifts have been applied. Check for  |
-c     | more possible deflation that might occur |
-c     | after the last shift is applied.         |
-c     %------------------------------------------%
-c
-      do 100 i = itop, kplusp-1
-         big   = abs(h(i,2)) + abs(h(i+1,2))
-         if (h(i+1,1) .le. epsmch*big) then
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [i], ndigit,
-     &              '_sapps: deflation at row/column no.')
-               call svout (logfil, 1, h(i+1,1), ndigit,
-     &              '_sapps: the corresponding off diagonal element')
-            end if
-            h(i+1,1) = zero
-         end if
- 100  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is not necessary if h(kev+1,1) = 0.         |
-c     %-------------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero )
-     &   call sgemv ('N', n, kplusp, one, v, ldv,
-     &                q(1,kev+1), 1, zero, workd(n+1), 1)
-c
-c     %-------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order    |
-c     | taking advantage that Q is an upper triangular matrix |
-c     | with lower bandwidth np.                              |
-c     | Place results in v(:,kplusp-kev:kplusp) temporarily.  |
-c     %-------------------------------------------------------%
-c
-      do 130 i = 1, kev
-         call sgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call scopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  130 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call slacpy ('All', n, kev, v(1,np+1), ldv, v, ldv)
-c
-c     %--------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the |
-c     | appropriate place if h(kev+1,1) .ne. zero. |
-c     %--------------------------------------------%
-c
-      if ( h(kev+1,1) .gt. zero )
-     &     call scopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call sscal (n, q(kplusp,kev), resid, 1)
-      if (h(kev+1,1) .gt. zero)
-     &   call saxpy (n, h(kev+1,1), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call svout (logfil, 1, q(kplusp,kev), ndigit,
-     &      '_sapps: sigmak of the updated residual vector')
-         call svout (logfil, 1, h(kev+1,1), ndigit,
-     &      '_sapps: betak of the updated residual vector')
-         call svout (logfil, kev, h(1,2), ndigit,
-     &      '_sapps: updated main diagonal of H for next iteration')
-         if (kev .gt. 1) then
-         call svout (logfil, kev-1, h(2,1), ndigit,
-     &      '_sapps: updated sub diagonal of H for next iteration')
-         end if
-      end if
-c
-      call arscnd (t1)
-      tsapps = tsapps + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssapps |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaup2.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaup2.f
deleted file mode 100644
index 504f28fb00..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaup2.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaup2
-c
-c\Description:
-c  Intermediate level interface called by ssaupd.
-c
-c\Usage:
-c  call ssaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in ssaupd.
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in ssaupd.
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi/Lanczos iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse communication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Tridiagonal matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Real N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Real (NEV+NP) by 2 array.  (OUTPUT)
-c          H is used to store the generated symmetric tridiagonal matrix
-c          The subdiagonal is stored in the first column of H starting
-c          at H(2,1).  The main diagonal is stored in the second column
-c          of H starting at H(1,2). If ssaup2 converges store the
-c          B-norm of the final residual vector in H(1,1).
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Real array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV) contains the computed Ritz values of OP.
-c
-c  BOUNDS  Real array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to RITZ.
-c
-c  Q       Real (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Real array of length at least 3*(NEV+NP).  (INPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in the computation of the
-c          tridiagonal eigenvalue problem, the calculation and
-c          application of the shifts and convergence checking.
-c          If ISHIFT .EQ. O and IDO .EQ. 3, the first NP locations
-c          of WORKL are used in reverse communication to hold the user
-c          supplied shifts.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in one of
-c                    the spectral transformation modes.  X is the current
-c                    operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Lanczos iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in ssaupd.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: All possible eigenvalues of OP has been found.
-c                   NP returns the size of the invariant subspace
-c                   spanning the operator OP.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from trid. eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Lanczos factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Routines called:
-c     sgetv0  ARPACK initial vector generation routine.
-c     ssaitr  ARPACK Lanczos factorization routine.
-c     ssapps  ARPACK application of implicit shifts routine.
-c     ssconv  ARPACK convergence of Ritz values routine.
-c     sseigt  ARPACK compute Ritz values and error bounds routine.
-c     ssgets  ARPACK reorder Ritz values and error bounds routine.
-c     ssortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sdot    Level 1 BLAS that computes the scalar product of two vectors.
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     sswap   Level 1 BLAS that swaps two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c     xx/xx/95: Version ' 2.4'.  (R.B. Lehoucq)
-c
-c\SCCS Information: @(#)
-c FILE: saup2.F   SID: 2.7   DATE OF SID: 5/19/98   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds,
-     &     q, ldq, workl, ipntr, workd, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, ldh, ldq, ldv, mxiter,
-     &           n, mode, nev, np
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Real
-     &           bounds(nev+np), h(ldh,2), q(ldq,nev+np), resid(n),
-     &           ritz(nev+np), v(ldv,nev+np), workd(3*n),
-     &           workl(3*(nev+np))
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  wprime*2
-      logical    cnorm, getv0, initv, update, ushift
-      integer    ierr, iter, j, kplusp, msglvl, nconv, nevbef, nev0,
-     &           np0, nptemp, nevd2, nevm2, kp(3)
-      Real
-     &           rnorm, temp, eps23
-      save       cnorm, getv0, initv, update, ushift,
-     &           iter, kplusp, msglvl, nconv, nev0, np0,
-     &           rnorm, eps23
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, sgetv0, ssaitr, sscal, ssconv, sseigt, ssgets,
-     &           ssapps, ssortr, svout, ivout, arscnd, sswap
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           sdot, snrm2, slamch
-      external   sdot, snrm2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = msaup2
-c
-c        %---------------------------------%
-c        | Set machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = slamch('Epsilon-Machine')
-         eps23 = eps23**(2.0E+0/3.0E+0)
-c
-c        %-------------------------------------%
-c        | nev0 and np0 are integer variables  |
-c        | hold the initial values of NEV & NP |
-c        %-------------------------------------%
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvlues.      |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev0 + np0
-         nconv  = 0
-         iter   = 0
-c
-c        %--------------------------------------------%
-c        | Set flags for computing the first NEV steps |
-c        | of the Lanczos factorization.              |
-c        %--------------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c        %--------------------------------------------%
-c        | User provides the initial residual vector. |
-c        %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call sgetv0 (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. zero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1200
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %------------------------------------------------------------%
-c     | Back from reverse communication: continue with update step |
-c     %------------------------------------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Lanczos factorization |
-c     %----------------------------------------------------------%
-c
-      call ssaitr (ido, bmat, n, 0, nev0, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-c     %---------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication  |
-c     | to compute operations involving OP and possibly B |
-c     %---------------------------------------------------%
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-c
-c        %-----------------------------------------------------%
-c        | ssaitr was unable to build an Lanczos factorization |
-c        | of length NEV0. INFO is returned with the size of   |
-c        | the factorization built. Exit main loop.            |
-c        %-----------------------------------------------------%
-c
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  LANCZOS  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Lanczos     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [iter], ndigit,
-     &           '_saup2: **** Start of major iteration number ****')
-         end if
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [nev], ndigit,
-     &     '_saup2: The length of the current Lanczos factorization')
-            call ivout (logfil, 1, [np], ndigit,
-     &           '_saup2: Extend the Lanczos factorization by')
-         end if
-c
-c        %------------------------------------------------------------%
-c        | Compute NP additional steps of the Lanczos factorization. |
-c        %------------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call ssaitr (ido, bmat, n, nev, np, mode, resid, rnorm, v,
-     &                ldv, h, ldh, ipntr, workd, info)
-c
-c        %---------------------------------------------------%
-c        | ido .ne. 99 implies use of reverse communication  |
-c        | to compute operations involving OP and possibly B |
-c        %---------------------------------------------------%
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-c
-c           %-----------------------------------------------------%
-c           | ssaitr was unable to build an Lanczos factorization |
-c           | of length NEV0+NP0. INFO is returned with the size  |
-c           | of the factorization built. Exit main loop.         |
-c           %-----------------------------------------------------%
-c
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call svout (logfil, 1, [rnorm], ndigit,
-     &           '_saup2: Current B-norm of residual for factorization')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current symmetric tridiagonal matrix.           |
-c        %--------------------------------------------------------%
-c
-         call sseigt (rnorm, kplusp, h, ldh, ritz, bounds, workl, ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %----------------------------------------------------%
-c        | Make a copy of eigenvalues and corresponding error |
-c        | bounds obtained from _seigt.                       |
-c        %----------------------------------------------------%
-c
-         call scopy(kplusp, ritz, 1, workl(kplusp+1), 1)
-         call scopy(kplusp, bounds, 1, workl(2*kplusp+1), 1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The selection is based on the requested number of |
-c        | eigenvalues instead of the current NEV and NP to  |
-c        | prevent possible misconvergence.                  |
-c        | * Wanted Ritz values := RITZ(NP+1:NEV+NP)         |
-c        | * Shifts := RITZ(1:NP) := WORKL(1:NP)             |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-         call ssgets (ishift, which, nev, np, ritz, bounds, workl)
-c
-c        %-------------------%
-c        | Convergence test. |
-c        %-------------------%
-c
-         call scopy (nev, bounds(np+1), 1, workl(np+1), 1)
-         call ssconv (nev, ritz(np+1), workl(np+1), tol, nconv)
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_saup2: NEV, NP, NCONV are')
-            call svout (logfil, kplusp, ritz, ndigit,
-     &           '_saup2: The eigenvalues of H')
-            call svout (logfil, kplusp, bounds, ndigit,
-     &          '_saup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. nev0) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP since we don't want to |
-c           | swap overlapping locations.                    |
-c           %------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %-----------------------------------------------------%
-c              | Both ends of the spectrum are requested.            |
-c              | Sort the eigenvalues into algebraically decreasing  |
-c              | order first then swap low end of the spectrum next  |
-c              | to high end in appropriate locations.               |
-c              | NOTE: when np < floor(nev/2) be careful not to swap |
-c              | overlapping locations.                              |
-c              %-----------------------------------------------------%
-c
-               wprime = 'SA'
-               call ssortr (wprime, .true., kplusp, ritz, bounds)
-               nevd2 = nev0 / 2
-               nevm2 = nev0 - nevd2
-               if ( nev .gt. 1 ) then
-                  call sswap ( min(nevd2,np), ritz(nevm2+1), 1,
-     &                 ritz( max(kplusp-nevd2+1,kplusp-np+1) ), 1)
-                  call sswap ( min(nevd2,np), bounds(nevm2+1), 1,
-     &                 bounds( max(kplusp-nevd2+1,kplusp-np+1)), 1)
-               end if
-c
-            else
-c
-c              %--------------------------------------------------%
-c              | LM, SM, LA, SA case.                             |
-c              | Sort the eigenvalues of H into the an order that |
-c              | is opposite to WHICH, and apply the resulting    |
-c              | order to BOUNDS.  The eigenvalues are sorted so  |
-c              | that the wanted part are always within the first |
-c              | NEV locations.                                   |
-c              %--------------------------------------------------%
-c
-               if (which .eq. 'LM') wprime = 'SM'
-               if (which .eq. 'SM') wprime = 'LM'
-               if (which .eq. 'LA') wprime = 'SA'
-               if (which .eq. 'SA') wprime = 'LA'
-c
-               call ssortr (wprime, .true., kplusp, ritz, bounds)
-c
-            end if
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23,magnitude of the Ritz value).   |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-               temp = max( eps23, abs(ritz(j)) )
-               bounds(j) = bounds(j)/temp
- 35         continue
-c
-c           %----------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz  |
-c           | estimates.  This will push all the converged ones  |
-c           | towards the front of ritzr, ritzi, bounds          |
-c           | (in the case when NCONV < NEV.)                    |
-c           %----------------------------------------------------%
-c
-            wprime = 'LA'
-            call ssortr(wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                temp = max( eps23, abs(ritz(j)) )
-                bounds(j) = bounds(j)*temp
- 40         continue
-c
-c           %--------------------------------------------------%
-c           | Sort the "converged" Ritz values again so that   |
-c           | the "threshold" values and their associated Ritz |
-c           | estimates appear at the appropriate position in  |
-c           | ritz and bound.                                  |
-c           %--------------------------------------------------%
-c
-            if (which .eq. 'BE') then
-c
-c              %------------------------------------------------%
-c              | Sort the "converged" Ritz values in increasing |
-c              | order.  The "threshold" values are in the      |
-c              | middle.                                        |
-c              %------------------------------------------------%
-c
-               wprime = 'LA'
-               call ssortr(wprime, .true., nconv, ritz, bounds)
-c
-            else
-c
-c              %----------------------------------------------%
-c              | In LM, SM, LA, SA case, sort the "converged" |
-c              | Ritz values according to WHICH so that the   |
-c              | "threshold" value appears at the front of    |
-c              | ritz.                                        |
-c              %----------------------------------------------%
-
-               call ssortr(which, .true., nconv, ritz, bounds)
-c
-            end if
-c
-c           %------------------------------------------%
-c           |  Use h( 1,1 ) as storage to communicate  |
-c           |  rnorm to _seupd if needed               |
-c           %------------------------------------------%
-c
-            h(1,1) = rnorm
-c
-            if (msglvl .gt. 1) then
-               call svout (logfil, kplusp, ritz, ndigit,
-     &            '_saup2: Sorted Ritz values.')
-               call svout (logfil, kplusp, bounds, ndigit,
-     &            '_saup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0) info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if (nconv .lt. nev .and. ishift .eq. 1) then
-c
-c           %---------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.    |
-c           | To prevent possible stagnation, adjust the number |
-c           | of Ritz values and the shifts.                    |
-c           %---------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min (nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 2) then
-               nev = 2
-            end if
-            np  = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call ssgets (ishift, which, nev, np, ritz, bounds,
-     &              workl)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [nconv], ndigit,
-     &           '_saup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_saup2: NEV and NP are')
-               call svout (logfil, nev, ritz(np+1), ndigit,
-     &              '_saup2: "wanted" Ritz values.')
-               call svout (logfil, nev, bounds(np+1), ndigit,
-     &              '_saup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-
-c
-         if (ishift .eq. 0) then
-c
-c           %-----------------------------------------------------%
-c           | User specified shifts: reverse communication to     |
-c           | compute the shifts. They are returned in the first  |
-c           | NP locations of WORKL.                              |
-c           %-----------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-c
-   50    continue
-c
-c        %------------------------------------%
-c        | Back from reverse communication;   |
-c        | User specified shifts are returned |
-c        | in WORKL(1:*NP)                   |
-c        %------------------------------------%
-c
-         ushift = .false.
-c
-c
-c        %---------------------------------------------------------%
-c        | Move the NP shifts to the first NP locations of RITZ to |
-c        | free up WORKL.  This is for the non-exact shift case;   |
-c        | in the exact shift case, ssgets already handles this.   |
-c        %---------------------------------------------------------%
-c
-         if (ishift .eq. 0) call scopy (np, workl, 1, ritz, 1)
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [np], ndigit,
-     &                  '_saup2: The number of shifts to apply ')
-            call svout (logfil, np, workl, ndigit,
-     &                  '_saup2: shifts selected')
-            if (ishift .eq. 1) then
-               call svout (logfil, np, bounds, ndigit,
-     &                  '_saup2: corresponding Ritz estimates')
-             end if
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP0 implicit shifts by QR bulge chasing.      |
-c        | Each shift is applied to the entire tridiagonal matrix. |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        | After ssapps is done, we have a Lanczos                 |
-c        | factorization of length NEV.                            |
-c        %---------------------------------------------------------%
-c
-         call ssapps (n, nev, np, ritz, v, ldv, h, ldh, resid, q, ldq,
-     &        workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to ssaitr.  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call scopy (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call scopy (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            rnorm = sdot (n, resid, 1, workd, 1)
-            rnorm = sqrt(abs(rnorm))
-         else if (bmat .eq. 'I') then
-            rnorm = snrm2(n, resid, 1)
-         end if
-         cnorm = .false.
-  130    continue
-c
-         if (msglvl .gt. 2) then
-            call svout (logfil, 1, [rnorm], ndigit,
-     &      '_saup2: B-norm of residual for NEV factorization')
-            call svout (logfil, nev, h(1,2), ndigit,
-     &           '_saup2: main diagonal of compressed H matrix')
-            call svout (logfil, nev-1, h(2,1), ndigit,
-     &           '_saup2: subdiagonal of compressed H matrix')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tsaup2 = t1 - t0
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssaup2 |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaupd.f
deleted file mode 100644
index 9756815270..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssaupd.f
+++ /dev/null
@@ -1,690 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssaupd
-c
-c\Description:
-c
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  Iteration.  For symmetric problems this reduces to a variant of the Lanczos
-c  method.  This method has been designed to compute approximations to a
-c  few eigenpairs of a linear operator OP that is real and symmetric
-c  with respect to a real positive semi-definite symmetric matrix B,
-c  i.e.
-c
-c       B*OP = (OP`)*B.
-c
-c  Another way to express this condition is
-c
-c       < x,OPy > = < OPx,y >  where < z,w > = z`Bw  .
-c
-c  In the standard eigenproblem B is the identity matrix.
-c  ( A` denotes transpose of A)
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  ssaupd is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x, A symmetric
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, A symmetric, M symmetric positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  K*x = lambda*M*x, K symmetric, M symmetric positive semi-definite
-c           ===> OP = (inv[K - sigma*M])*M  and  B = M.
-c           ===> Shift-and-Invert mode
-c
-c  Mode 4:  K*x = lambda*KG*x, K symmetric positive semi-definite,
-c           KG symmetric indefinite
-c           ===> OP = (inv[K - sigma*KG])*K  and  B = K.
-c           ===> Buckling mode
-c
-c  Mode 5:  A*x = lambda*M*x, A symmetric, M symmetric positive semi-definite
-c           ===> OP = inv[A - sigma*M]*[A + sigma*M]  and  B = M.
-c           ===> Cayley transformed mode
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call ssaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to ssaupd.  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          ssaupd with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          (If Mode = 2 see remark 5 below)
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3,4 and 5, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute the IPARAM(8) shifts where
-c                    IPNTR(11) is the pointer into WORKL for
-c                    placing the shifts. See remark 6 below.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Specify which of the Ritz values of OP to compute.
-c
-c          'LA' - compute the NEV largest (algebraic) eigenvalues.
-c          'SA' - compute the NEV smallest (algebraic) eigenvalues.
-c          'LM' - compute the NEV largest (in magnitude) eigenvalues.
-c          'SM' - compute the NEV smallest (in magnitude) eigenvalues.
-c          'BE' - compute NEV eigenvalues, half from each end of the
-c                 spectrum.  When NEV is odd, compute one more from the
-c                 high end than from the low end.
-c           (see remark 1 below)
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N.
-c
-c  TOL     Real  scalar.  (INPUT)
-c          Stopping criterion: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I)).
-c          If TOL .LE. 0. is passed a default is set:
-c          DEFAULT = SLAMCH('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine SLAMCH).
-c
-c  RESID   Real  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V (less than or equal to N).
-c          This will indicate how many Lanczos vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Lanczos vectors are generated, the algorithm generates
-c          NCV-NEV Lanczos vectors at each subsequent update iteration.
-c          Most of the cost in generating each Lanczos vector is in the
-c          matrix-vector product OP*x. (See remark 4 below).
-c
-c  V       Real  N by NCV array.  (OUTPUT)
-c          The NCV columns of V contain the Lanczos basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to restart
-c          the Arnoldi iteration in an implicit fashion.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the current tridiagonal matrix T are returned in
-c                      the part of WORKL array corresponding to RITZ.
-c                      See remark 6 below.
-c          ISHIFT = 1: exact shifts with respect to the reduced
-c                      tridiagonal matrix T.  This is equivalent to
-c                      restarting the iteration with a starting vector
-c                      that is a linear combination of Ritz vectors
-c                      associated with the "wanted" Ritz values.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = LEVEC
-c          No longer referenced. See remark 2 below.
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3,4,5; See under \Description of ssaupd for the
-c          five modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), ssaupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP <=NCV-NEV. See Remark
-c          6 below.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 11.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Lanczos iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by 2 tridiagonal matrix T in WORKL.
-c          IPNTR(6): pointer to the NCV RITZ values array in WORKL.
-c          IPNTR(7): pointer to the Ritz estimates in array WORKL associated
-c                    with the Ritz values located in RITZ in WORKL.
-c          IPNTR(11): pointer to the NP shifts in WORKL. See Remark 6 below.
-c
-c          Note: IPNTR(8:10) is only referenced by sseupd. See Remark 2.
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     sseupd if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  WORKD   Real  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration. Upon termination
-c          WORKD(1:N) contains B*RESID(1:N). If the Ritz vectors are desired
-c          subroutine sseupd uses this output.
-c          See Data Distribution Note below.
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least NCV**2 + 8*NCV .
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iterations allowed
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array WORKL is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Informatinal error from LAPACK routine ssteqr.
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -13: NEV and WHICH = 'BE' are incompatible.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization. The user is advised to check that
-c                   enough workspace and array storage has been allocated.
-c
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in ascending
-c     algebraic order.  The computed Ritz values are approximate
-c     eigenvalues of OP.  The selection of WHICH should be made
-c     with this in mind when Mode = 3,4,5.  After convergence,
-c     approximate eigenvalues of the original problem may be obtained
-c     with the ARPACK subroutine sseupd.
-c
-c  2. If the Ritz vectors corresponding to the converged Ritz values
-c     are needed, the user must call sseupd immediately following completion
-c     of ssaupd. This is new starting with version 2.1 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.   The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c
-c  5. If IPARAM(7) = 2 then in the Reverse communication interface the user
-c     must do the following. When IDO = 1, Y = OP * X is to be computed.
-c     When IPARAM(7) = 2 OP = inv(B)*A. After computing A*X the user
-c     must overwrite X with A*X. Y is then the solution to the linear set
-c     of equations B*Y = A*X.
-c
-c  6. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) shifts in locations:
-c     1   WORKL(IPNTR(11))
-c     2   WORKL(IPNTR(11)+1)
-c                        .
-c                        .
-c                        .
-c     NP  WORKL(IPNTR(11)+NP-1).
-c
-c     The eigenvalues of the current tridiagonal matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are in the
-c     order defined by WHICH. The associated Ritz estimates are located in
-c     WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... , WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  REAL       RESID(N), V(LDV,NCV), WORKD(3*N), WORKL(LWORKL)
-c  DECOMPOSE  D1(N), D2(N,NCV)
-c  ALIGN      RESID(I) with D1(I)
-c  ALIGN      V(I,J)   with D2(I,J)
-c  ALIGN      WORKD(I) with D1(I)     range (1:N)
-c  ALIGN      WORKD(I) with D1(I-N)   range (N+1:2*N)
-c  ALIGN      WORKD(I) with D1(I-2*N) range (2*N+1:3*N)
-c  DISTRIBUTE D1(BLOCK), D2(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c  Cray MPP syntax:
-c  ===============
-c  REAL       RESID(N), V(LDV,NCV), WORKD(N,3), WORKL(LWORKL)
-c  SHARED     RESID(BLOCK), V(BLOCK,:), WORKD(BLOCK,:)
-c  REPLICATED WORKL(LWORKL)
-c
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c  8. R.B. Lehoucq, D.C. Sorensen, "Implementation of Some Spectral
-c     Transformations in a k-Step Arnoldi Method". In Preparation.
-c
-c\Routines called:
-c     ssaup2  ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     sstats  ARPACK routine that initialize timing and other statistics
-c             variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: saupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(11)
-      Real
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, msglvl, mxiter, mode, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   ssaup2,  svout, ivout, arscnd, sstats
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call sstats
-         call arscnd (t0)
-         msglvl = msaupd
-c
-         ierr   = 0
-         ishift = iparam(1)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         if (n .le. 0) then
-            ierr = -1
-         else if (nev .le. 0) then
-            ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-            ierr = -3
-         end if
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-c
-         if (mxiter .le. 0)                     ierr = -4
-         if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LA' .and.
-     &       which .ne. 'SA' .and.
-     &       which .ne. 'BE')                   ierr = -5
-         if (bmat .ne. 'I' .and. bmat .ne. 'G') ierr = -6
-c
-         if (lworkl .lt. ncv**2 + 8*ncv)        ierr = -7
-         if (mode .lt. 1 .or. mode .gt. 5) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         else if (ishift .lt. 0 .or. ishift .gt. 1) then
-                                                ierr = -12
-         else if (nev .eq. 1 .and. which .eq. 'BE') then
-                                                ierr = -13
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)                         nb = 1
-         if (tol .le. zero)                     tol = slamch('EpsMach')
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, ncv**2 + 8*ncv
-            workl(j) = zero
- 10      continue
-c
-c        %-------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c        | etc... and the remaining workspace.                   |
-c        | Also update pointer to be used on output.             |
-c        | Memory is laid out as follows:                        |
-c        | workl(1:2*ncv) := generated tridiagonal matrix        |
-c        | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c        | workl(3*ncv+1:3*ncv+ncv) := computed error bounds     |
-c        | workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q     |
-c        | workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace     |
-c        %-------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + 2*ldh
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ncv**2
-         next   = iw     + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = bounds
-         ipntr(11) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Lanczos Iteration. |
-c     %-------------------------------------------------------%
-c
-      call ssaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw), ipntr, workd,
-     &     info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP or shifts.    |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within ssaup2.               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [mxiter], ndigit,
-     &               '_saupd: number of update iterations taken')
-         call ivout (logfil, 1, [np], ndigit,
-     &               '_saupd: number of "converged" Ritz values')
-         call svout (logfil, np, workl(Ritz), ndigit,
-     &               '_saupd: final Ritz values')
-         call svout (logfil, np, workl(Bounds), ndigit,
-     &               '_saupd: corresponding error bounds')
-      end if
-c
-      call arscnd (t1)
-      tsaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tsaupd, tsaup2, tsaitr, titref,
-     &                  tgetv0, tseigt, tsgets, tsapps, tsconv
- 1000    format (//,
-     &      5x, '==========================================',/
-     &      5x, '= Symmetric implicit Arnoldi update code =',/
-     &      5x, '= Version Number:', ' 2.4' , 19x, ' =',/
-     &      5x, '= Version Date:  ', ' 07/31/96' , 14x, ' =',/
-     &      5x, '==========================================',/
-     &      5x, '= Summary of timing statistics           =',/
-     &      5x, '==========================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in saup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in trid eigenvalue subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of ssaupd |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssconv.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssconv.f
deleted file mode 100644
index 11e4cab262..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssconv.f
+++ /dev/null
@@ -1,138 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssconv
-c
-c\Description:
-c  Convergence testing for the symmetric Arnoldi eigenvalue routine.
-c
-c\Usage:
-c  call ssconv
-c     ( N, RITZ, BOUNDS, TOL, NCONV )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Number of Ritz values to check for convergence.
-c
-c  RITZ    Real array of length N.  (INPUT)
-c          The Ritz values to be checked for convergence.
-c
-c  BOUNDS  Real array of length N.  (INPUT)
-c          Ritz estimates associated with the Ritz values in RITZ.
-c
-c  TOL     Real scalar.  (INPUT)
-c          Desired relative accuracy for a Ritz value to be considered
-c          "converged".
-c
-c  NCONV   Integer scalar.  (OUTPUT)
-c          Number of "converged" Ritz values.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     slamch  LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: sconv.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.4, this routine no longer uses the
-c        Parlett strategy using the gap conditions.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssconv (n, ritz, bounds, tol, nconv)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    n, nconv
-      Real
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           ritz(n), bounds(n)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i
-      Real
-     &           temp, eps23
-c
-c     %-------------------%
-c     | External routines |
-c     %-------------------%
-c
-      Real
-     &           slamch
-      external   slamch
-
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    abs
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      call arscnd (t0)
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0 / 3.0E+0)
-c
-      nconv  = 0
-      do 10 i = 1, n
-c
-c        %-----------------------------------------------------%
-c        | The i-th Ritz value is considered "converged"       |
-c        | when: bounds(i) .le. TOL*max(eps23, abs(ritz(i)))   |
-c        %-----------------------------------------------------%
-c
-         temp = max( eps23, abs(ritz(i)) )
-         if ( bounds(i) .le. tol*temp ) then
-            nconv = nconv + 1
-         end if
-c
-   10 continue
-c
-      call arscnd (t1)
-      tsconv = tsconv + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of ssconv |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseigt.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseigt.f
deleted file mode 100644
index 3ac336690b..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseigt.f
+++ /dev/null
@@ -1,181 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sseigt
-c
-c\Description:
-c  Compute the eigenvalues of the current symmetric tridiagonal matrix
-c  and the corresponding error bounds given the current residual norm.
-c
-c\Usage:
-c  call sseigt
-c     ( RNORM, N, H, LDH, EIG, BOUNDS, WORKL, IERR )
-c
-c\Arguments
-c  RNORM   Real scalar.  (INPUT)
-c          RNORM contains the residual norm corresponding to the current
-c          symmetric tridiagonal matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the symmetric tridiagonal matrix H.
-c
-c  H       Real N by 2 array.  (INPUT)
-c          H contains the symmetric tridiagonal matrix with the
-c          subdiagonal in the first column starting at H(2,1) and the
-c          main diagonal in second column.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  EIG     Real array of length N.  (OUTPUT)
-c          On output, EIG contains the N eigenvalues of H possibly
-c          unsorted.  The BOUNDS arrays are returned in the
-c          same sorted order as EIG.
-c
-c  BOUNDS  Real array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the error estimates corresponding
-c          to the eigenvalues EIG.  This is equal to RNORM times the
-c          last components of the eigenvectors corresponding to the
-c          eigenvalues in EIG.
-c
-c  WORKL   Real work array of length 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from sstqrb.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     sstqrb  ARPACK routine that computes the eigenvalues and the
-c             last components of the eigenvectors of a symmetric
-c             and tridiagonal matrix.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.4'
-c
-c\SCCS Information: @(#)
-c FILE: seigt.F   SID: 2.4   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sseigt
-     &   ( rnorm, n, h, ldh, eig, bounds, workl, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, ldh, n
-      Real
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           eig(n), bounds(n), h(ldh,2), workl(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           zero
-      parameter (zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, k, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy, sstqrb, svout, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mseigt
-c
-      if (msglvl .gt. 0) then
-         call svout (logfil, n, h(1,2), ndigit,
-     &              '_seigt: main diagonal of matrix H')
-         if (n .gt. 1) then
-         call svout (logfil, n-1, h(2,1), ndigit,
-     &              '_seigt: sub diagonal of matrix H')
-         end if
-      end if
-c
-      call scopy  (n, h(1,2), 1, eig, 1)
-      call scopy  (n-1, h(2,1), 1, workl, 1)
-      call sstqrb (n, eig, workl, bounds, workl(n+1), ierr)
-      if (ierr .ne. 0) go to 9000
-      if (msglvl .gt. 1) then
-         call svout (logfil, n, bounds, ndigit,
-     &              '_seigt: last row of the eigenvector matrix for H')
-      end if
-c
-c     %-----------------------------------------------%
-c     | Finally determine the error bounds associated |
-c     | with the n Ritz values of H.                  |
-c     %-----------------------------------------------%
-c
-      do 30 k = 1, n
-         bounds(k) = rnorm*abs(bounds(k))
-   30 continue
-c
-      call arscnd (t1)
-      tseigt = tseigt + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of sseigt |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssesrt.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssesrt.f
deleted file mode 100644
index afc71b0882..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssesrt.f
+++ /dev/null
@@ -1,217 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssesrt
-c
-c\Description:
-c  Sort the array X in the order specified by WHICH and optionally
-c  apply the permutation to the columns of the matrix A.
-c
-c\Usage:
-c  call ssesrt
-c     ( WHICH, APPLY, N, X, NA, A, LDA)
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X is sorted into increasing order of magnitude.
-c          'SM' -> X is sorted into decreasing order of magnitude.
-c          'LA' -> X is sorted into increasing order of algebraic.
-c          'SA' -> X is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to A.
-c          APPLY = .FALSE. -> do not apply the sorted order to A.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the array X.
-c
-c  X      Real array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  NA      Integer.  (INPUT)
-c          Number of rows of the matrix A.
-c
-c  A      Real array of length NA by N.  (INPUT/OUTPUT)
-c
-c  LDA     Integer.  (INPUT)
-c          Leading dimension of A.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines
-c     sswap  Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO and
-c               the ARPACK code ssortr
-c
-c\SCCS Information: @(#)
-c FILE: sesrt.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssesrt (which, apply, n, x, na, a, lda)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    lda, n, na
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           x(0:n-1), a(lda, 0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   sswap
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'SA') then
-c
-c        X is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x(j).lt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x(j)).lt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (x(j).gt.x(j+igap)) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'LM') then
-c
-c        X is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x(j)).gt.abs(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-               if (apply) call sswap( na, a(1, j), 1, a(1,j+igap), 1)
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssesrt |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseupd.f
deleted file mode 100644
index 03ba7ac508..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sseupd.f
+++ /dev/null
@@ -1,867 +0,0 @@
-c\BeginDoc
-c
-c\Name: sseupd
-c
-c\Description:
-c
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) the corresponding approximate eigenvectors,
-c
-c      (2) an orthonormal (Lanczos) basis for the associated approximate
-c          invariant subspace,
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  (Lanczos) basis is always computed.  There is an additional storage cost
-c  of n*nev if both are requested (in this case a separate array Z must be
-c  supplied).
-c
-c  These quantities are obtained from the Lanczos factorization computed
-c  by SSAUPD for the linear operator OP prescribed by the MODE selection
-c  (see IPARAM(7) in SSAUPD documentation.)  SSAUPD must be called before
-c  this routine is called. These approximate eigenvalues and vectors are
-c  commonly called Ritz values and Ritz vectors respectively.  They are
-c  referred to as such in the comments that follow.   The computed orthonormal
-c  basis for the invariant subspace corresponding to these Ritz values is
-c  referred to as a Lanczos basis.
-c
-c  See documentation in the header of the subroutine SSAUPD for a definition
-c  of OP as well as other terms and the relation of computed Ritz values
-c  and vectors of OP with respect to the given problem  A*z = lambda*B*z.
-c
-c  The approximate eigenvalues of the original problem are returned in
-c  ascending algebraic order.  The user may elect to call this routine
-c  once for each desired Ritz vector and store it peripherally if desired.
-c  There is also the option of computing a selected set of these vectors
-c  with a single call.
-c
-c\Usage:
-c  call sseupd
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, BMAT, N, WHICH, NEV, TOL,
-c       RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD, WORKL, LWORKL, INFO )
-c
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether Ritz vectors corresponding to the Ritz value
-c          approximations to the eigenproblem A*z = lambda*B*z are computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies how many Ritz vectors are wanted and the form of Z
-c          the matrix of Ritz vectors. See remark 1 below.
-c          = 'A': compute NEV Ritz vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT/WORKSPACE)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE..
-c          If HOWMNY = 'A' , SELECT is used as a workspace for
-c          reordering the Ritz values.
-c
-c  D       Real  array of dimension NEV.  (OUTPUT)
-c          On exit, D contains the Ritz value approximations to the
-c          eigenvalues of A*z = lambda*B*z. The values are returned
-c          in ascending order. If IPARAM(7) = 3,4,5 then D represents
-c          the Ritz values of OP computed by ssaupd transformed to
-c          those of the original eigensystem A*z = lambda*B*z. If
-c          IPARAM(7) = 1,2 then the Ritz values of OP are the same
-c          as the those of A*z = lambda*B*z.
-c
-c  Z       Real  N by NEV array if HOWMNY = 'A'.  (OUTPUT)
-c          On exit, Z contains the B-orthonormal Ritz vectors of the
-c          eigensystem A*z = lambda*B*z corresponding to the Ritz
-c          value approximations.
-c          If  RVEC = .FALSE. then Z is not referenced.
-c          NOTE: The array Z may be set equal to first NEV columns of the
-c          Arnoldi/Lanczos basis array V computed by SSAUPD.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ).  In any case,  LDZ .ge. 1.
-c
-c  SIGMA   Real   (INPUT)
-c          If IPARAM(7) = 3,4,5 represents the shift. Not referenced if
-c          IPARAM(7) = 1 or 2.
-c
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to SSAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, INFO
-c
-c         must be passed directly to SSEUPD following the last call
-c         to SSAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to SSAUPD and the call to SSEUPD.
-c
-c  Two of these parameters (WORKL, INFO) are also output parameters:
-c
-c  WORKL   Real  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:4*ncv) contains information obtained in
-c          ssaupd.  They are not changed by sseupd.
-c          WORKL(4*ncv+1:ncv*ncv+8*ncv) holds the
-c          untransformed Ritz values, the computed error estimates,
-c          and the associated eigenvector matrix of H.
-c
-c          Note: IPNTR(8:10) contains the pointer into WORKL for addresses
-c          of the above information computed by sseupd.
-c          -------------------------------------------------------------
-c          IPNTR(8): pointer to the NCV RITZ values of the original system.
-c          IPNTR(9): pointer to the NCV corresponding error bounds.
-c          IPNTR(10): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the tridiagonal matrix T. Only referenced by
-c                     sseupd if RVEC = .TRUE. See Remarks.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV must be greater than NEV and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LA', 'SA' or 'BE'.
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from trid. eigenvalue calculation;
-c                Information error from LAPACK routine ssteqr.
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3,4,5.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: NEV and WHICH = 'BE' are incompatible.
-c          = -14: SSAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: HOWMNY must be one of 'A' or 'S' if RVEC = .true.
-c          = -16: HOWMNY = 'S' not yet implemented
-c          = -17: SSEUPD got a different count of the number of converged
-c                 Ritz values than SSAUPD got.  This indicates the user
-c                 probably made an error in passing data from SSAUPD to
-c                 SSEUPD or that the data was modified before entering
-c                 SSEUPD.
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett, "The Symmetric Eigenvalue Problem". Prentice-Hall,
-c     1980.
-c  4. B.N. Parlett, B. Nour-Omid, "Towards a Black Box Lanczos Program",
-c     Computer Physics Communications, 53 (1989), pp 169-179.
-c  5. B. Nour-Omid, B.N. Parlett, T. Ericson, P.S. Jensen, "How to
-c     Implement the Spectral Transformation", Math. Comp., 48 (1987),
-c     pp 663-673.
-c  6. R.G. Grimes, J.G. Lewis and H.D. Simon, "A Shifted Block Lanczos
-c     Algorithm for Solving Sparse Symmetric Generalized Eigenproblems",
-c     SIAM J. Matr. Anal. Apps.,  January (1993).
-c  7. L. Reichel, W.B. Gragg, "Algorithm 686: FORTRAN Subroutines
-c     for Updating the QR decomposition", ACM TOMS, December 1990,
-c     Volume 16 Number 4, pp 369-377.
-c
-c\Remarks
-c  1. The converged Ritz values are always returned in increasing
-c     (algebraic) order.
-c
-c  2. Currently only HOWMNY = 'A' is implemented. It is included at this
-c     stage for the user who wants to incorporate it.
-c
-c\Routines called:
-c     ssesrt  ARPACK routine that sorts an array X, and applies the
-c             corresponding permutation to a matrix A.
-c     ssortr  ssortr  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     svout   ARPACK utility routine that prints vectors.
-c     sgeqr2  LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     slacpy  LAPACK matrix copy routine.
-c     slamch  LAPACK routine that determines machine constants.
-c     sorm2r  LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     ssteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a tridiagonal matrix.
-c     sger    Level 2 BLAS rank one update to a matrix.
-c     scopy   Level 1 BLAS that copies one vector to another .
-c     snrm2   Level 1 BLAS that computes the norm of a vector.
-c     sscal   Level 1 BLAS that scales a vector.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/15/93: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: seupd.F   SID: 2.11   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine sseupd(rvec  , howmny, select, d    ,
-     &                   z     , ldz   , sigma , bmat ,
-     &                   n     , which , nev   , tol  ,
-     &                   resid , ncv   , v     , ldv  ,
-     &                   iparam, ipntr , workd , workl,
-     &                   lworkl, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Real
-     &           sigma, tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(7), ipntr(11)
-      logical    select(ncv)
-      Real
-     &           d(nev)     , resid(n)  , v(ldv,ncv),
-     &           z(ldz, nev), workd(2*n), workl(lworkl)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0 , zero = 0.0E+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds , ierr   , ih    , ihb   , ihd   ,
-     &           iq     , iw     , j     , k     , ldh   ,
-     &           ldq    , mode   , msglvl, nconv , next  ,
-     &           ritz   , irz    , ibd   , np    , ishift,
-     &           leftptr, rghtptr, numcnv, jj
-      Real
-     &           bnorm2 , rnorm, temp, temp1, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   scopy , sger  , sgeqr2, slacpy, sorm2r, sscal,
-     &           ssesrt, ssteqr, sswap , svout , ivout , ssortr
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           snrm2, slamch
-      external   snrm2, slamch
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mseupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c     %--------------%
-c     | Quick return |
-c     %--------------%
-c
-      if (nconv .eq. 0) go to 9000
-      ierr = 0
-c
-      if (nconv .le. 0)                        ierr = -14
-      if (n .le. 0)                            ierr = -1
-      if (nev .le. 0)                          ierr = -2
-      if (ncv .le. nev .or.  ncv .gt. n)       ierr = -3
-      if (which .ne. 'LM' .and.
-     &    which .ne. 'SM' .and.
-     &    which .ne. 'LA' .and.
-     &    which .ne. 'SA' .and.
-     &    which .ne. 'BE')                     ierr = -5
-      if (bmat .ne. 'I' .and. bmat .ne. 'G')   ierr = -6
-      if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec )
-     &                                         ierr = -15
-      if (rvec .and. howmny .eq. 'S')           ierr = -16
-c
-      if (rvec .and. lworkl .lt. ncv**2+8*ncv) ierr = -7
-c
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else if (mode .eq. 4 ) then
-         type = 'BUCKLE'
-      else if (mode .eq. 5 ) then
-         type = 'CAYLEY'
-      else
-                                               ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')     ierr = -11
-      if (nev .eq. 1 .and. which .eq. 'BE')    ierr = -12
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, BOUNDS, Q  |
-c     | etc... and the remaining workspace.                   |
-c     | Also update pointer to be used on output.             |
-c     | Memory is laid out as follows:                        |
-c     | workl(1:2*ncv) := generated tridiagonal matrix H      |
-c     |       The subdiagonal is stored in workl(2:ncv).      |
-c     |       The dead spot is workl(1) but upon exiting      |
-c     |       ssaupd stores the B-norm of the last residual   |
-c     |       vector in workl(1). We use this !!!             |
-c     | workl(2*ncv+1:2*ncv+ncv) := ritz values               |
-c     |       The wanted values are in the first NCONV spots. |
-c     | workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates   |
-c     |       The wanted values are in the first NCONV spots. |
-c     | NOTE: workl(1:4*ncv) is set by ssaupd and is not      |
-c     |       modified by sseupd.                             |
-c     %-------------------------------------------------------%
-c
-c     %-------------------------------------------------------%
-c     | The following is used and set by sseupd.              |
-c     | workl(4*ncv+1:4*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the diagonal of H. Upon EXIT contains the NCV   |
-c     |       Ritz values of the original system. The first   |
-c     |       NCONV spots have the wanted values. If MODE =   |
-c     |       1 or 2 then will equal workl(2*ncv+1:3*ncv).    |
-c     | workl(5*ncv+1:5*ncv+ncv) := used as workspace during  |
-c     |       computation of the eigenvectors of H. Stores    |
-c     |       the subdiagonal of H. Upon EXIT contains the    |
-c     |       NCV corresponding Ritz estimates of the         |
-c     |       original system. The first NCONV spots have the |
-c     |       wanted values. If MODE = 1,2 then will equal    |
-c     |       workl(3*ncv+1:4*ncv).                           |
-c     | workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is  |
-c     |       the eigenvector matrix for H as returned by     |
-c     |       ssteqr. Not referenced if RVEC = .False.        |
-c     |       Ordering follows that of workl(4*ncv+1:5*ncv)   |
-c     | workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=         |
-c     |       Workspace. Needed by ssteqr and by sseupd.      |
-c     | GRAND total of NCV*(NCV+8) locations.                 |
-c     %-------------------------------------------------------%
-c
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      bounds = ipntr(7)
-      ldh    = ncv
-      ldq    = ncv
-      ihd    = bounds + ldh
-      ihb    = ihd    + ldh
-      iq     = ihb    + ldh
-      iw     = iq     + ldh*ncv
-      next   = iw     + 2*ncv
-      ipntr(4)  = next
-      ipntr(8)  = ihd
-      ipntr(9)  = ihb
-      ipntr(10) = iq
-c
-c     %----------------------------------------%
-c     | irz points to the Ritz values computed |
-c     |     by _seigt before exiting _saup2.   |
-c     | ibd points to the Ritz estimates       |
-c     |     computed by _seigt before exiting  |
-c     |     _saup2.                            |
-c     %----------------------------------------%
-c
-      irz = ipntr(11)+ncv
-      ibd = irz+ncv
-c
-c
-c     %---------------------------------%
-c     | Set machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = slamch('Epsilon-Machine')
-      eps23 = eps23**(2.0E+0  / 3.0E+0 )
-c
-c     %---------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N).    |
-c     | BNORM2 is the 2 norm of B*RESID(1:N). |
-c     | Upon exit of ssaupd WORKD(1:N) has    |
-c     | B*RESID(1:N).                         |
-c     %---------------------------------------%
-c
-      rnorm = workl(ih)
-      if (bmat .eq. 'I') then
-         bnorm2 = rnorm
-      else if (bmat .eq. 'G') then
-         bnorm2 = snrm2(n, workd, 1)
-      end if
-c
-      if (msglvl .gt. 2) then
-         call svout(logfil, ncv, workl(irz), ndigit,
-     &   '_seupd: Ritz values passed in from _SAUPD.')
-         call svout(logfil, ncv, workl(ibd), ndigit,
-     &   '_seupd: Ritz estimates passed in from _SAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(bound)     |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call ssgets(ishift, which       , nev          ,
-     &                np    , workl(irz)  , workl(bounds),
-     &                workl)
-c
-         if (msglvl .gt. 2) then
-            call svout(logfil, ncv, workl(irz), ndigit,
-     &      '_seupd: Ritz values after calling _SGETS.')
-            call svout(logfil, ncv, workl(bounds), ndigit,
-     &      '_seupd: Ritz value indices after calling _SGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            temp1 = max(eps23, abs(workl(irz+ncv-j)) )
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          workl(ibd+jj-1) .le. tol*temp1) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nconv) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by _saupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the _saupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, [numcnv], ndigit,
-     &            '_seupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, [nconv], ndigit,
-     &            '_seupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -17
-            go to 9000
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Call LAPACK routine _steqr to compute the eigenvalues and |
-c        | eigenvectors of the final symmetric tridiagonal matrix H. |
-c        | Initialize the eigenvector matrix Q to the identity.      |
-c        %-----------------------------------------------------------%
-c
-         call scopy(ncv-1, workl(ih+1), 1, workl(ihb), 1)
-         call scopy(ncv, workl(ih+ldh), 1, workl(ihd), 1)
-c
-         call ssteqr('Identity', ncv, workl(ihd), workl(ihb),
-     &                workl(iq) , ldq, workl(iw), ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call scopy(ncv, workl(iq+ncv-1), ldq, workl(iw), 1)
-            call svout(logfil, ncv, workl(ihd), ndigit,
-     &          '_seupd: NCV Ritz values of the final H matrix')
-            call svout(logfil, ncv, workl(iw), ndigit,
-     &           '_seupd: last row of the eigenvector matrix for H')
-         end if
-c
-         if (reord) then
-c
-c           %---------------------------------------------%
-c           | Reordered the eigenvalues and eigenvectors  |
-c           | computed by _steqr so that the "converged"  |
-c           | eigenvalues appear in the first NCONV       |
-c           | positions of workl(ihd), and the associated |
-c           | eigenvectors appear in the first NCONV      |
-c           | columns.                                    |
-c           %---------------------------------------------%
-c
-            leftptr = 1
-            rghtptr = ncv
-c
-            if (ncv .eq. 1) go to 30
-c
- 20         if (select(leftptr)) then
-c
-c              %-------------------------------------------%
-c              | Search, from the left, for the first Ritz |
-c              | value that has not converged.             |
-c              %-------------------------------------------%
-c
-               leftptr = leftptr + 1
-c
-            else if ( .not. select(rghtptr)) then
-c
-c              %----------------------------------------------%
-c              | Search, from the right, the first Ritz value |
-c              | that has converged.                          |
-c              %----------------------------------------------%
-c
-               rghtptr = rghtptr - 1
-c
-            else
-c
-c              %----------------------------------------------%
-c              | Swap the Ritz value on the left that has not |
-c              | converged with the Ritz value on the right   |
-c              | that has converged.  Swap the associated     |
-c              | eigenvector of the tridiagonal matrix H as   |
-c              | well.                                        |
-c              %----------------------------------------------%
-c
-               temp = workl(ihd+leftptr-1)
-               workl(ihd+leftptr-1) = workl(ihd+rghtptr-1)
-               workl(ihd+rghtptr-1) = temp
-               call scopy(ncv, workl(iq+ncv*(leftptr-1)), 1,
-     &                    workl(iw), 1)
-               call scopy(ncv, workl(iq+ncv*(rghtptr-1)), 1,
-     &                    workl(iq+ncv*(leftptr-1)), 1)
-               call scopy(ncv, workl(iw), 1,
-     &                    workl(iq+ncv*(rghtptr-1)), 1)
-               leftptr = leftptr + 1
-               rghtptr = rghtptr - 1
-c
-            end if
-c
-            if (leftptr .lt. rghtptr) go to 20
-c
-         end if
-c
- 30      if (msglvl .gt. 2) then
-             call svout (logfil, ncv, workl(ihd), ndigit,
-     &       '_seupd: The eigenvalues of H--reordered')
-         end if
-c
-c        %----------------------------------------%
-c        | Load the converged Ritz values into D. |
-c        %----------------------------------------%
-c
-         call scopy(nconv, workl(ihd), 1, d, 1)
-c
-      else
-c
-c        %-----------------------------------------------------%
-c        | Ritz vectors not required. Load Ritz values into D. |
-c        %-----------------------------------------------------%
-c
-         call scopy(nconv, workl(ritz), 1, d, 1)
-         call scopy(ncv, workl(ritz), 1, workl(ihd), 1)
-c
-      end if
-c
-c     %------------------------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors and corresponding |
-c     | Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values |
-c     | (and corresponding data) are returned in ascending order.        |
-c     %------------------------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-c        %---------------------------------------------------------%
-c        | Ascending sort of wanted Ritz values, vectors and error |
-c        | bounds. Not necessary if only Ritz values are desired.  |
-c        %---------------------------------------------------------%
-c
-         if (rvec) then
-            call ssesrt('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call scopy(ncv, workl(bounds), 1, workl(ihb), 1)
-         end if
-c
-      else
-c
-c        %-------------------------------------------------------------%
-c        | *  Make a copy of all the Ritz values.                      |
-c        | *  Transform the Ritz values back to the original system.   |
-c        |    For TYPE = 'SHIFTI' the transformation is                |
-c        |             lambda = 1/theta + sigma                        |
-c        |    For TYPE = 'BUCKLE' the transformation is                |
-c        |             lambda = sigma * theta / ( theta - 1 )          |
-c        |    For TYPE = 'CAYLEY' the transformation is                |
-c        |             lambda = sigma * (theta + 1) / (theta - 1 )     |
-c        |    where the theta are the Ritz values returned by ssaupd.  |
-c        | NOTES:                                                      |
-c        | *The Ritz vectors are not affected by the transformation.   |
-c        |  They are only reordered.                                   |
-c        %-------------------------------------------------------------%
-c
-         call scopy (ncv, workl(ihd), 1, workl(iw), 1)
-         if (type .eq. 'SHIFTI') then
-            do 40 k=1, ncv
-               workl(ihd+k-1) = one / workl(ihd+k-1) + sigma
-  40        continue
-         else if (type .eq. 'BUCKLE') then
-            do 50 k=1, ncv
-               workl(ihd+k-1) = sigma * workl(ihd+k-1) /
-     &                          (workl(ihd+k-1) - one)
-  50        continue
-         else if (type .eq. 'CAYLEY') then
-            do 60 k=1, ncv
-               workl(ihd+k-1) = sigma * (workl(ihd+k-1) + one) /
-     &                          (workl(ihd+k-1) - one)
-  60        continue
-         end if
-c
-c        %-------------------------------------------------------------%
-c        | *  Store the wanted NCONV lambda values into D.             |
-c        | *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)   |
-c        |    into ascending order and apply sort to the NCONV theta   |
-c        |    values in the transformed system. We will need this to   |
-c        |    compute Ritz estimates in the original system.           |
-c        | *  Finally sort the lambda`s into ascending order and apply |
-c        |    to Ritz vectors if wanted. Else just sort lambda`s into  |
-c        |    ascending order.                                         |
-c        | NOTES:                                                      |
-c        | *workl(iw:iw+ncv-1) contain the theta ordered so that they  |
-c        |  match the ordering of the lambda. We`ll use them again for |
-c        |  Ritz vector purification.                                  |
-c        %-------------------------------------------------------------%
-c
-         call scopy(nconv, workl(ihd), 1, d, 1)
-         call ssortr('LA', .true., nconv, workl(ihd), workl(iw))
-         if (rvec) then
-            call ssesrt('LA', rvec , nconv, d, ncv, workl(iq), ldq)
-         else
-            call scopy(ncv, workl(bounds), 1, workl(ihb), 1)
-            call sscal(ncv, bnorm2/rnorm, workl(ihb), 1)
-            call ssortr('LA', .true., nconv, d, workl(ihb))
-         end if
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Compute the Ritz vectors. Transform the wanted |
-c     | eigenvectors of the symmetric tridiagonal H by |
-c     | the Lanczos basis matrix V.                    |
-c     %------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A') then
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(iq,ldq).                                |
-c        %----------------------------------------------------------%
-c
-         call sgeqr2(ncv, nconv        , workl(iq) ,
-     &                ldq, workl(iw+ncv), workl(ihb),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q.                                 |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(ihd).                         |
-c        %--------------------------------------------------------%
-c
-         call sorm2r('Right', 'Notranspose', n        ,
-     &                ncv    , nconv        , workl(iq),
-     &                ldq    , workl(iw+ncv), v        ,
-     &                ldv    , workd(n+1)   , ierr)
-         call slacpy('All', n, nconv, v, ldv, z, ldz)
-c
-c        %-----------------------------------------------------%
-c        | In order to compute the Ritz estimates for the Ritz |
-c        | values in both systems, need the last row of the    |
-c        | eigenvector matrix. Remember, it`s in factored form |
-c        %-----------------------------------------------------%
-c
-         do 65 j = 1, ncv-1
-            workl(ihb+j-1) = zero
-  65     continue
-         workl(ihb+ncv-1) = one
-         call sorm2r('Left', 'Transpose'  , ncv       ,
-     &                1     , nconv        , workl(iq) ,
-     &                ldq   , workl(iw+ncv), workl(ihb),
-     &                ncv   , temp         , ierr)
-c
-c        %-----------------------------------------------------%
-c        | Make a copy of the last row into                    |
-c        | workl(iw+ncv:iw+2*ncv), as it is needed again in    |
-c        | the Ritz vector purification step below             |
-c        %-----------------------------------------------------%
-c
-         do 67 j = 1, nconv
-            workl(iw+ncv+j-1) = workl(ihb+j-1)
- 67      continue
-
-      else if (rvec .and. howmny .eq. 'S') then
-c
-c     Not yet implemented. See remark 2 above.
-c
-      end if
-c
-      if (type .eq. 'REGULR' .and. rvec) then
-c
-            do 70 j=1, ncv
-               workl(ihb+j-1) = rnorm * abs( workl(ihb+j-1) )
- 70         continue
-c
-      else if (type .ne. 'REGULR' .and. rvec) then
-c
-c        %-------------------------------------------------%
-c        | *  Determine Ritz estimates of the theta.       |
-c        |    If RVEC = .true. then compute Ritz estimates |
-c        |               of the theta.                     |
-c        |    If RVEC = .false. then copy Ritz estimates   |
-c        |              as computed by ssaupd.             |
-c        | *  Determine Ritz estimates of the lambda.      |
-c        %-------------------------------------------------%
-c
-         call sscal (ncv, bnorm2, workl(ihb), 1)
-         if (type .eq. 'SHIFTI') then
-c
-            do 80 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1) )
-     &                        / workl(iw+k-1)**2
- 80         continue
-c
-         else if (type .eq. 'BUCKLE') then
-c
-            do 90 k=1, ncv
-               workl(ihb+k-1) = sigma * abs( workl(ihb+k-1) )
-     &                        / (workl(iw+k-1)-one )**2
- 90         continue
-c
-         else if (type .eq. 'CAYLEY') then
-c
-            do 100 k=1, ncv
-               workl(ihb+k-1) = abs( workl(ihb+k-1)
-     &                        / workl(iw+k-1)*(workl(iw+k-1)-one) )
- 100        continue
-c
-         end if
-c
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call svout(logfil, nconv, d, ndigit,
-     &          '_seupd: Untransformed converged Ritz values')
-         call svout(logfil, nconv, workl(ihb), ndigit,
-     &     '_seupd: Ritz estimates of the untransformed Ritz values')
-      else if (msglvl .gt. 1) then
-         call svout(logfil, nconv, d, ndigit,
-     &          '_seupd: Converged Ritz values')
-         call svout(logfil, nconv, workl(ihb), ndigit,
-     &     '_seupd: Associated Ritz estimates')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Ritz vector purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3,4,5. See reference 7               |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. (type .eq. 'SHIFTI' .or. type .eq. 'CAYLEY')) then
-c
-         do 110 k=0, nconv-1
-            workl(iw+k) = workl(iw+ncv+k)
-     &                  / workl(iw+k)
- 110     continue
-c
-      else if (rvec .and. type .eq. 'BUCKLE') then
-c
-         do 120 k=0, nconv-1
-            workl(iw+k) = workl(iw+ncv+k)
-     &                  / (workl(iw+k)-one)
- 120     continue
-c
-      end if
-c
-      if (type .ne. 'REGULR')
-     &   call sger (n, nconv, one, resid, 1, workl(iw), 1, z, ldz)
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of sseupd|
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssgets.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssgets.f
deleted file mode 100644
index f40ca76a8a..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssgets.f
+++ /dev/null
@@ -1,219 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssgets
-c
-c\Description:
-c  Given the eigenvalues of the symmetric tridiagonal matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: This is called even in the case of user specified shifts in
-c  order to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call ssgets
-c     ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS, SHIFTS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> KEV eigenvalues of largest magnitude are retained.
-c          'SM' -> KEV eigenvalues of smallest magnitude are retained.
-c          'LA' -> KEV eigenvalues of largest value are retained.
-c          'SA' -> KEV eigenvalues of smallest value are retained.
-c          'BE' -> KEV eigenvalues, half from each end of the spectrum.
-c                  If KEV is odd, compute one more from the high end.
-c
-c  KEV      Integer.  (INPUT)
-c          KEV+NP is the size of the matrix H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be computed.
-c
-c  RITZ    Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted eigenvalues
-c          are in the first NP locations and the wanted part is in
-c          the last KEV locations.  When exact shifts are selected, the
-c          unwanted part corresponds to the shifts to be applied.
-c
-c  BOUNDS  Real array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c  SHIFTS  Real array of length NP.  (INPUT/OUTPUT)
-c          On INPUT:  contains the user specified shifts if ISHIFT = 0.
-c          On OUTPUT: contains the shifts sorted into decreasing order
-c          of magnitude with respect to the Ritz estimates contained in
-c          BOUNDS. If ISHIFT = 0, SHIFTS is not modified on exit.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     ssortr  ARPACK utility sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     svout   ARPACK utility routine that prints vectors.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/93: Version ' 2.1'
-c
-c\SCCS Information: @(#)
-c FILE: sgets.F   SID: 2.4   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssgets ( ishift, which, kev, np, ritz, bounds, shifts )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           bounds(kev+np), ritz(kev+np), shifts(np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Real
-     &           one, zero
-      parameter (one = 1.0E+0, zero = 0.0E+0)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    kevd2, msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   sswap, scopy, ssortr, arscnd
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic    max, min
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = msgets
-c
-      if (which .eq. 'BE') then
-c
-c        %-----------------------------------------------------%
-c        | Both ends of the spectrum are requested.            |
-c        | Sort the eigenvalues into algebraically increasing  |
-c        | order first then swap high end of the spectrum next |
-c        | to low end in appropriate locations.                |
-c        | NOTE: when np < floor(kev/2) be careful not to swap |
-c        | overlapping locations.                              |
-c        %-----------------------------------------------------%
-c
-         call ssortr ('LA', .true., kev+np, ritz, bounds)
-         kevd2 = kev / 2
-         if ( kev .gt. 1 ) then
-            call sswap ( min(kevd2,np), ritz, 1,
-     &                   ritz( max(kevd2,np)+1 ), 1)
-            call sswap ( min(kevd2,np), bounds, 1,
-     &                   bounds( max(kevd2,np)+1 ), 1)
-         end if
-c
-      else
-c
-c        %----------------------------------------------------%
-c        | LM, SM, LA, SA case.                               |
-c        | Sort the eigenvalues of H into the desired order   |
-c        | and apply the resulting order to BOUNDS.           |
-c        | The eigenvalues are sorted so that the wanted part |
-c        | are always in the last KEV locations.               |
-c        %----------------------------------------------------%
-c
-         call ssortr (which, .true., kev+np, ritz, bounds)
-      end if
-c
-      if (ishift .eq. 1 .and. np .gt. 0) then
-c
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first.       |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine ssapps.                     |
-c        %-------------------------------------------------------%
-c
-         call ssortr ('SM', .true., np, bounds, ritz)
-         call scopy (np, ritz, 1, shifts, 1)
-      end if
-c
-      call arscnd (t1)
-      tsgets = tsgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [kev], ndigit, '_sgets: KEV is')
-         call ivout (logfil, 1, [np], ndigit, '_sgets: NP is')
-         call svout (logfil, kev+np, ritz, ndigit,
-     &        '_sgets: Eigenvalues of current H matrix')
-         call svout (logfil, kev+np, bounds, ndigit,
-     &        '_sgets: Associated Ritz estimates')
-      end if
-c
-      return
-c
-c     %---------------%
-c     | End of ssgets |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortc.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortc.f
deleted file mode 100644
index e322039cdd..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortc.f
+++ /dev/null
@@ -1,344 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssortc
-c
-c\Description:
-c  Sorts the complex array in XREAL and XIMAG into the order
-c  specified by WHICH and optionally applies the permutation to the
-c  real array Y. It is assumed that if an element of XIMAG is
-c  nonzero, then its negative is also an element. In other words,
-c  both members of a complex conjugate pair are to be sorted and the
-c  pairs are kept adjacent to each other.
-c
-c\Usage:
-c  call ssortc
-c     ( WHICH, APPLY, N, XREAL, XIMAG, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort XREAL,XIMAG into increasing order of magnitude.
-c          'SM' -> sort XREAL,XIMAG into decreasing order of magnitude.
-c          'LR' -> sort XREAL into increasing order of algebraic.
-c          'SR' -> sort XREAL into decreasing order of algebraic.
-c          'LI' -> sort XIMAG into increasing order of magnitude.
-c          'SI' -> sort XIMAG into decreasing order of magnitude.
-c          NOTE: If an element of XIMAG is non-zero, then its negative
-c                is also an element.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  XREAL,  Real array of length N.  (INPUT/OUTPUT)
-c  XIMAG   Real and imaginary part of the array to be sorted.
-c
-c  Y       Real array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     xx/xx/92: Version ' 2.1'
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.3   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssortc (which, apply, n, xreal, ximag, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           xreal(0:n-1), ximag(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp, temp1, temp2
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Real
-     &           slapy2
-      external   slapy2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'LM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = slapy2(xreal(j),ximag(j))
-            temp2 = slapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.gt.temp2) then
-                temp = xreal(j)
-                xreal(j) = xreal(j+igap)
-                xreal(j+igap) = temp
-c
-                temp = ximag(j)
-                ximag(j) = ximag(j+igap)
-                ximag(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %------------------------------------------------------%
-c        | Sort XREAL,XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = slapy2(xreal(j),ximag(j))
-            temp2 = slapy2(xreal(j+igap),ximag(j+igap))
-c
-            if (temp1.lt.temp2) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (xreal(j).gt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (xreal(j).lt.xreal(j+igap)) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c
-      else if (which .eq. 'LI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into increasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (abs(ximag(j)).gt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c
-      else if (which .eq. 'SI') then
-c
-c        %------------------------------------------------%
-c        | Sort XIMAG into decreasing order of magnitude. |
-c        %------------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (abs(ximag(j)).lt.abs(ximag(j+igap))) then
-               temp = xreal(j)
-               xreal(j) = xreal(j+igap)
-               xreal(j+igap) = temp
-c
-               temp = ximag(j)
-               ximag(j) = ximag(j+igap)
-               ximag(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssortc |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortr.f
deleted file mode 100644
index 25d324b657..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/ssortr.f
+++ /dev/null
@@ -1,218 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: ssortr
-c
-c\Description:
-c  Sort the array X1 in the order specified by WHICH and optionally
-c  applies the permutation to the array X2.
-c
-c\Usage:
-c  call ssortr
-c     ( WHICH, APPLY, N, X1, X2 )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> X1 is sorted into increasing order of magnitude.
-c          'SM' -> X1 is sorted into decreasing order of magnitude.
-c          'LA' -> X1 is sorted into increasing order of algebraic.
-c          'SA' -> X1 is sorted into decreasing order of algebraic.
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to X2.
-c          APPLY = .FALSE. -> do not apply the sorted order to X2.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X1      Real array of length N.  (INPUT/OUTPUT)
-c          The array to be sorted.
-c
-c  X2      Real array of length N.  (INPUT/OUTPUT)
-c          Only referenced if APPLY = .TRUE.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\Revision history:
-c     12/16/93: Version ' 2.1'.
-c               Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortr.F   SID: 2.3   DATE OF SID: 4/19/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine ssortr (which, apply, n, x1, x2)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           x1(0:n-1), x2(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Real
-     &           temp
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'SA') then
-c
-c        X1 is sorted into decreasing order of algebraic.
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            if (x1(j).lt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 30
-            endif
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        X1 is sorted into decreasing order of magnitude.
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j.lt.0) go to 60
-c
-            if (abs(x1(j)).lt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LA') then
-c
-c        X1 is sorted into increasing order of algebraic.
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (x1(j).gt.x1(j+igap)) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'LM') then
-c
-c        X1 is sorted into increasing order of magnitude.
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (abs(x1(j)).gt.abs(x1(j+igap))) then
-               temp = x1(j)
-               x1(j) = x1(j+igap)
-               x1(j+igap) = temp
-               if (apply) then
-                  temp = x2(j)
-                  x2(j) = x2(j+igap)
-                  x2(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of ssortr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstatn.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstatn.f
deleted file mode 100644
index f3288c1aba..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstatn.f
+++ /dev/null
@@ -1,61 +0,0 @@
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for nonsymmetric Arnoldi code.              |
-c     %---------------------------------------------%
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.4   DATE OF SID: 4/20/96   RELEASE: 2
-c
-      subroutine sstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-c
-      tnaupd = 0.0E+0
-      tnaup2 = 0.0E+0
-      tnaitr = 0.0E+0
-      tneigh = 0.0E+0
-      tngets = 0.0E+0
-      tnapps = 0.0E+0
-      tnconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
-c
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-c
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
-c
-      return
-c
-c
-c     %---------------%
-c     | End of sstatn |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstats.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstats.f
deleted file mode 100644
index 0822d3f3aa..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstats.f
+++ /dev/null
@@ -1,47 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: stats.F   SID: 2.1   DATE OF SID: 4/19/96   RELEASE: 2
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for symmetric Arnoldi code.                 |
-c     %---------------------------------------------%
-
-      subroutine sstats
-
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-      include   'stat.h'
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-
-      tsaupd = 0.0E+0
-      tsaup2 = 0.0E+0
-      tsaitr = 0.0E+0
-      tseigt = 0.0E+0
-      tsgets = 0.0E+0
-      tsapps = 0.0E+0
-      tsconv = 0.0E+0
-      titref = 0.0E+0
-      tgetv0 = 0.0E+0
-      trvec  = 0.0E+0
-
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0E+0
-      tmvbx  = 0.0E+0
-
-      return
-c
-c     End of sstats
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstqrb.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstqrb.f
deleted file mode 100644
index 9697c36602..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/sstqrb.f
+++ /dev/null
@@ -1,594 +0,0 @@
-c-----------------------------------------------------------------------
-c\BeginDoc
-c
-c\Name: sstqrb
-c
-c\Description:
-c  Computes all eigenvalues and the last component of the eigenvectors
-c  of a symmetric tridiagonal matrix using the implicit QL or QR method.
-c
-c  This is mostly a modification of the LAPACK routine ssteqr.
-c  See Remarks.
-c
-c\Usage:
-c  call sstqrb
-c     ( N, D, E, Z, WORK, INFO )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          The number of rows and columns in the matrix.  N >= 0.
-c
-c  D       Real array, dimension (N).  (INPUT/OUTPUT)
-c          On entry, D contains the diagonal elements of the
-c          tridiagonal matrix.
-c          On exit, D contains the eigenvalues, in ascending order.
-c          If an error exit is made, the eigenvalues are correct
-c          for indices 1,2,...,INFO-1, but they are unordered and
-c          may not be the smallest eigenvalues of the matrix.
-c
-c  E       Real array, dimension (N-1).  (INPUT/OUTPUT)
-c          On entry, E contains the subdiagonal elements of the
-c          tridiagonal matrix in positions 1 through N-1.
-c          On exit, E has been destroyed.
-c
-c  Z       Real array, dimension (N).  (OUTPUT)
-c          On exit, Z contains the last row of the orthonormal
-c          eigenvector matrix of the symmetric tridiagonal matrix.
-c          If an error exit is made, Z contains the last row of the
-c          eigenvector matrix associated with the stored eigenvalues.
-c
-c  WORK    Real array, dimension (max(1,2*N-2)).  (WORKSPACE)
-c          Workspace used in accumulating the transformation for
-c          computing the last components of the eigenvectors.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0:  normal return.
-c          < 0:  if INFO = -i, the i-th argument had an illegal value.
-c          > 0:  if INFO = +i, the i-th eigenvalue has not converged
-c                              after a total of  30*N  iterations.
-c
-c\Remarks
-c  1. None.
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  real
-c
-c\Routines called:
-c     saxpy   Level 1 BLAS that computes a vector triad.
-c     scopy   Level 1 BLAS that copies one vector to another.
-c     sswap   Level 1 BLAS that swaps the contents of two vectors.
-c     lsame   LAPACK character comparison routine.
-c     slae2   LAPACK routine that computes the eigenvalues of a 2-by-2
-c             symmetric matrix.
-c     slaev2  LAPACK routine that eigendecomposition of a 2-by-2 symmetric
-c             matrix.
-c     slamch  LAPACK routine that determines machine constants.
-c     slanst  LAPACK routine that computes the norm of a matrix.
-c     slapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     slartg  LAPACK Givens rotation construction routine.
-c     slascl  LAPACK routine for careful scaling of a matrix.
-c     slaset  LAPACK matrix initialization routine.
-c     slasr   LAPACK routine that applies an orthogonal transformation to
-c             a matrix.
-c     slasrt  LAPACK sorting routine.
-c     ssteqr  LAPACK routine that computes eigenvalues and eigenvectors
-c             of a symmetric tridiagonal matrix.
-c     xerbla  LAPACK error handler routine.
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: stqrb.F   SID: 2.5   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c     1. Starting with version 2.5, this routine is a modified version
-c        of LAPACK version 2.0 subroutine SSTEQR. No lines are deleted,
-c        only commented out and new lines inserted.
-c        All lines commented out have "c$$$" at the beginning.
-c        Note that the LAPACK version 1.0 subroutine SSTEQR contained
-c        bugs.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine sstqrb ( n, d, e, z, work, info )
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    info, n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Real
-     &           d( n ), e( n-1 ), z( n ), work( 2*n-2 )
-c
-c     .. parameters ..
-      Real
-     &                   zero, one, two, three
-      parameter          ( zero = 0.0E+0, one = 1.0E+0,
-     &                     two = 2.0E+0, three = 3.0E+0 )
-      integer            maxit
-      parameter          ( maxit = 30 )
-c     ..
-c     .. local scalars ..
-      integer            i, icompz, ii, iscale, j, jtot, k, l, l1, lend,
-     &                   lendm1, lendp1, lendsv, lm1, lsv, m, mm, mm1,
-     &                   nm1, nmaxit
-      Real
-     &                   anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2,
-     &                   s, safmax, safmin, ssfmax, ssfmin, tst
-c     ..
-c     .. external functions ..
-      logical            lsame
-      Real
-     &                   slamch, slanst, slapy2
-      external           lsame, slamch, slanst, slapy2
-c     ..
-c     .. external subroutines ..
-      external           slae2, slaev2, slartg, slascl, slaset, slasr,
-     &                   slasrt, sswap, xerbla
-c     ..
-c     .. intrinsic functions ..
-      intrinsic          abs, max, sign, sqrt
-c     ..
-c     .. executable statements ..
-c
-c     test the input parameters.
-c
-      info = 0
-c
-c$$$      IF( LSAME( COMPZ, 'N' ) ) THEN
-c$$$         ICOMPZ = 0
-c$$$      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
-c$$$         ICOMPZ = 1
-c$$$      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
-c$$$         ICOMPZ = 2
-c$$$      ELSE
-c$$$         ICOMPZ = -1
-c$$$      END IF
-c$$$      IF( ICOMPZ.LT.0 ) THEN
-c$$$         INFO = -1
-c$$$      ELSE IF( N.LT.0 ) THEN
-c$$$         INFO = -2
-c$$$      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
-c$$$     $         N ) ) ) THEN
-c$$$         INFO = -6
-c$$$      END IF
-c$$$      IF( INFO.NE.0 ) THEN
-c$$$         CALL XERBLA( 'SSTEQR', -INFO )
-c$$$         RETURN
-c$$$      END IF
-c
-c    *** New starting with version 2.5 ***
-c
-      icompz = 2
-c    *************************************
-c
-c     quick return if possible
-c
-      if( n.eq.0 )
-     $   return
-c
-      if( n.eq.1 ) then
-         if( icompz.eq.2 )  z( 1 ) = one
-         return
-      end if
-c
-c     determine the unit roundoff and over/underflow thresholds.
-c
-      eps = slamch( 'e' )
-      eps2 = eps**2
-      safmin = slamch( 's' )
-      safmax = one / safmin
-      ssfmax = sqrt( safmax ) / three
-      ssfmin = sqrt( safmin ) / eps2
-c
-c     compute the eigenvalues and eigenvectors of the tridiagonal
-c     matrix.
-c
-c$$      if( icompz.eq.2 )
-c$$$     $   call slaset( 'full', n, n, zero, one, z, ldz )
-c
-c     *** New starting with version 2.5 ***
-c
-      if ( icompz .eq. 2 ) then
-         do 5 j = 1, n-1
-            z(j) = zero
-  5      continue
-         z( n ) = one
-      end if
-c     *************************************
-c
-      nmaxit = n*maxit
-      jtot = 0
-c
-c     determine where the matrix splits and choose ql or qr iteration
-c     for each block, according to whether top or bottom diagonal
-c     element is smaller.
-c
-      l1 = 1
-      nm1 = n - 1
-c
-   10 continue
-      if( l1.gt.n )
-     $   go to 160
-      if( l1.gt.1 )
-     $   e( l1-1 ) = zero
-      if( l1.le.nm1 ) then
-         do 20 m = l1, nm1
-            tst = abs( e( m ) )
-            if( tst.eq.zero )
-     $         go to 30
-            if( tst.le.( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+
-     $          1 ) ) ) )*eps ) then
-               e( m ) = zero
-               go to 30
-            end if
-   20    continue
-      end if
-      m = n
-c
-   30 continue
-      l = l1
-      lsv = l
-      lend = m
-      lendsv = lend
-      l1 = m + 1
-      if( lend.eq.l )
-     $   go to 10
-c
-c     scale submatrix in rows and columns l to lend
-c
-      anorm = slanst( 'i', lend-l+1, d( l ), e( l ) )
-      iscale = 0
-      if( anorm.eq.zero )
-     $   go to 10
-      if( anorm.gt.ssfmax ) then
-         iscale = 1
-         call slascl( 'g', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,
-     $                info )
-         call slascl( 'g', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,
-     $                info )
-      else if( anorm.lt.ssfmin ) then
-         iscale = 2
-         call slascl( 'g', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,
-     $                info )
-         call slascl( 'g', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,
-     $                info )
-      end if
-c
-c     choose between ql and qr iteration
-c
-      if( abs( d( lend ) ).lt.abs( d( l ) ) ) then
-         lend = lsv
-         l = lendsv
-      end if
-c
-      if( lend.gt.l ) then
-c
-c        ql iteration
-c
-c        look for small subdiagonal element.
-c
-   40    continue
-         if( l.ne.lend ) then
-            lendm1 = lend - 1
-            do 50 m = l, lendm1
-               tst = abs( e( m ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+
-     $             safmin )go to 60
-   50       continue
-         end if
-c
-         m = lend
-c
-   60    continue
-         if( m.lt.lend )
-     $      e( m ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 80
-c
-c        if remaining matrix is 2-by-2, use slae2 or slaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l+1 ) then
-            if( icompz.gt.0 ) then
-               call slaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
-               work( l ) = c
-               work( n-1+l ) = s
-c$$$               call slasr( 'r', 'v', 'b', n, 2, work( l ),
-c$$$     $                     work( n-1+l ), z( 1, l ), ldz )
-c
-c              *** New starting with version 2.5 ***
-c
-               tst      = z(l+1)
-               z(l+1) = c*tst - s*z(l)
-               z(l)   = s*tst + c*z(l)
-c              *************************************
-            else
-               call slae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
-            end if
-            d( l ) = rt1
-            d( l+1 ) = rt2
-            e( l ) = zero
-            l = l + 2
-            if( l.le.lend )
-     $         go to 40
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l+1 )-p ) / ( two*e( l ) )
-         r = slapy2( g, one )
-         g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         mm1 = m - 1
-         do 70 i = mm1, l, -1
-            f = s*e( i )
-            b = c*e( i )
-            call slartg( g, f, c, s, r )
-            if( i.ne.m-1 )
-     $         e( i+1 ) = r
-            g = d( i+1 ) - p
-            r = ( d( i )-g )*s + two*c*b
-            p = s*r
-            d( i+1 ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = -s
-            end if
-c
-   70    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = m - l + 1
-c$$$            call slasr( 'r', 'v', 'b', n, mm, work( l ), work( n-1+l ),
-c$$$     $                  z( 1, l ), ldz )
-c
-c             *** New starting with version 2.5 ***
-c
-              call slasr( 'r', 'v', 'b', 1, mm, work( l ),
-     &                    work( n-1+l ), z( l ), 1 )
-c             *************************************
-         end if
-c
-         d( l ) = d( l ) - p
-         e( l ) = g
-         go to 40
-c
-c        eigenvalue found.
-c
-   80    continue
-         d( l ) = p
-c
-         l = l + 1
-         if( l.le.lend )
-     $      go to 40
-         go to 140
-c
-      else
-c
-c        qr iteration
-c
-c        look for small superdiagonal element.
-c
-   90    continue
-         if( l.ne.lend ) then
-            lendp1 = lend + 1
-            do 100 m = l, lendp1, -1
-               tst = abs( e( m-1 ) )**2
-               if( tst.le.( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+
-     $             safmin )go to 110
-  100       continue
-         end if
-c
-         m = lend
-c
-  110    continue
-         if( m.gt.lend )
-     $      e( m-1 ) = zero
-         p = d( l )
-         if( m.eq.l )
-     $      go to 130
-c
-c        if remaining matrix is 2-by-2, use slae2 or slaev2
-c        to compute its eigensystem.
-c
-         if( m.eq.l-1 ) then
-            if( icompz.gt.0 ) then
-               call slaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
-c$$$               work( m ) = c
-c$$$               work( n-1+m ) = s
-c$$$               call slasr( 'r', 'v', 'f', n, 2, work( m ),
-c$$$     $                     work( n-1+m ), z( 1, l-1 ), ldz )
-c
-c               *** New starting with version 2.5 ***
-c
-                tst      = z(l)
-                z(l)   = c*tst - s*z(l-1)
-                z(l-1) = s*tst + c*z(l-1)
-c               *************************************
-            else
-               call slae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
-            end if
-            d( l-1 ) = rt1
-            d( l ) = rt2
-            e( l-1 ) = zero
-            l = l - 2
-            if( l.ge.lend )
-     $         go to 90
-            go to 140
-         end if
-c
-         if( jtot.eq.nmaxit )
-     $      go to 140
-         jtot = jtot + 1
-c
-c        form shift.
-c
-         g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
-         r = slapy2( g, one )
-         g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
-c
-         s = one
-         c = one
-         p = zero
-c
-c        inner loop
-c
-         lm1 = l - 1
-         do 120 i = m, lm1
-            f = s*e( i )
-            b = c*e( i )
-            call slartg( g, f, c, s, r )
-            if( i.ne.m )
-     $         e( i-1 ) = r
-            g = d( i ) - p
-            r = ( d( i+1 )-g )*s + two*c*b
-            p = s*r
-            d( i ) = g + p
-            g = c*r - b
-c
-c           if eigenvectors are desired, then save rotations.
-c
-            if( icompz.gt.0 ) then
-               work( i ) = c
-               work( n-1+i ) = s
-            end if
-c
-  120    continue
-c
-c        if eigenvectors are desired, then apply saved rotations.
-c
-         if( icompz.gt.0 ) then
-            mm = l - m + 1
-c$$$            call slasr( 'r', 'v', 'f', n, mm, work( m ), work( n-1+m ),
-c$$$     $                  z( 1, m ), ldz )
-c
-c           *** New starting with version 2.5 ***
-c
-            call slasr( 'r', 'v', 'f', 1, mm, work( m ), work( n-1+m ),
-     &                  z( m ), 1 )
-c           *************************************
-         end if
-c
-         d( l ) = d( l ) - p
-         e( lm1 ) = g
-         go to 90
-c
-c        eigenvalue found.
-c
-  130    continue
-         d( l ) = p
-c
-         l = l - 1
-         if( l.ge.lend )
-     $      go to 90
-         go to 140
-c
-      end if
-c
-c     undo scaling if necessary
-c
-  140 continue
-      if( iscale.eq.1 ) then
-         call slascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call slascl( 'g', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      else if( iscale.eq.2 ) then
-         call slascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,
-     $                d( lsv ), n, info )
-         call slascl( 'g', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),
-     $                n, info )
-      end if
-c
-c     check for no convergence to an eigenvalue after a total
-c     of n*maxit iterations.
-c
-      if( jtot.lt.nmaxit )
-     $   go to 10
-      do 150 i = 1, n - 1
-         if( e( i ).ne.zero )
-     $      info = info + 1
-  150 continue
-      go to 190
-c
-c     order eigenvalues and eigenvectors.
-c
-  160 continue
-      if( icompz.eq.0 ) then
-c
-c        use quick sort
-c
-         call slasrt( 'i', n, d, info )
-c
-      else
-c
-c        use selection sort to minimize swaps of eigenvectors
-c
-         do 180 ii = 2, n
-            i = ii - 1
-            k = i
-            p = d( i )
-            do 170 j = ii, n
-               if( d( j ).lt.p ) then
-                  k = j
-                  p = d( j )
-               end if
-  170       continue
-            if( k.ne.i ) then
-               d( k ) = d( i )
-               d( i ) = p
-c$$$               call sswap( n, z( 1, i ), 1, z( 1, k ), 1 )
-c           *** New starting with version 2.5 ***
-c
-               p    = z(k)
-               z(k) = z(i)
-               z(i) = p
-c           *************************************
-            end if
-  180    continue
-      end if
-c
-  190 continue
-      return
-c
-c     %---------------%
-c     | End of sstqrb |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/stat.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/stat.h
deleted file mode 100644
index 81d49c3bd2..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/stat.h
+++ /dev/null
@@ -1,21 +0,0 @@
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-c\SCCS Information: @(#) 
-c FILE: stat.h   SID: 2.2   DATE OF SID: 11/16/95   RELEASE: 2 
-c
-c      real       t0, t1, t2, t3, t4, t5
-c      save       t0, t1, t2, t3, t4, t5
-c
-c      integer    nopx, nbx, nrorth, nitref, nrstrt
-c      real       tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-c     &           tmvopx, tmvbx, tgetv0, titref, trvec
-c      common /timing/
-c     &           nopx, nbx, nrorth, nitref, nrstrt,
-c     &           tsaupd, tsaup2, tsaitr, tseigt, tsgets, tsapps, tsconv,
-c     &           tnaupd, tnaup2, tnaitr, tneigh, tngets, tnapps, tnconv,
-c     &           tcaupd, tcaup2, tcaitr, tceigh, tcgets, tcapps, tcconv,
-c     &           tmvopx, tmvbx, tgetv0, titref, trvec
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/version.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/version.h
deleted file mode 100644
index ecdd9b3405..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/version.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-
- In the current version, the parameter KAPPA in the Kahan's test
- for orthogonality is set to 0.717, the same as used by Gragg & Reichel.
- However computational experience indicates that this is a little too 
- strict and will frequently force reorthogonalization when it is not
- necessary to do so. 
-
- Also the "moving boundary" idea is not currently activated in the nonsymmetric
- code since it is not conclusive that it's the right thing to do all the time.  
- Requires further investigation.
-
- As of 02/01/93 Richard Lehoucq assumes software control of the codes from
- Phuong Vu. On 03/01/93 all the *.F files were migrated SCCS. The 1.1 version
- of codes are those received from Phuong Vu. The frozen version of 07/08/92
- is now considered version 1.1.
-
- Version 2.1 contains two new symmetric routines, sesrt and seupd. 
- Changes as well as bug fixes for version 1.1 codes that were only corrected 
- for programming bugs are version 1.2. These 1.2 versions will also be in version 2.1.
- Subroutine [d,s]saupd now requires slightly more workspace. See [d,s]saupd for the
- details. 
-
- \SCCS Information: @(#) 
-  FILE: version.h   SID: 2.3   DATE OF SID: 11/16/95   RELEASE: 2
-
- */
-
-#define VERSION_NUMBER ' 2.1'
-#define VERSION_DATE   ' 11/15/95'
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zgetv0.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zgetv0.f
deleted file mode 100644
index 1fbd508519..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zgetv0.f
+++ /dev/null
@@ -1,416 +0,0 @@
-c\BeginDoc
-c
-c\Name: zgetv0
-c
-c\Description:
-c  Generate a random initial residual vector for the Arnoldi process.
-c  Force the residual vector to be in the range of the operator OP.
-c
-c\Usage:
-c  call zgetv0
-c     ( IDO, BMAT, ITRY, INITV, N, J, V, LDV, RESID, RNORM,
-c       IPNTR, WORKD, IERR )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to zgetv0.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B in the (generalized)
-c          eigenvalue problem A*x = lambda*B*x.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*B*x
-c
-c  ITRY    Integer.  (INPUT)
-c          ITRY counts the number of times that zgetv0 is called.
-c          It should be set to 1 on the initial call to zgetv0.
-c
-c  INITV   Logical variable.  (INPUT)
-c          .TRUE.  => the initial residual vector is given in RESID.
-c          .FALSE. => generate a random initial residual vector.
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the problem.
-c
-c  J       Integer.  (INPUT)
-c          Index of the residual vector to be generated, with respect to
-c          the Arnoldi process.  J > 1 in case of a "restart".
-c
-c  V       Complex*16 N by J array.  (INPUT)
-c          The first J-1 columns of V contain the current Arnoldi basis
-c          if this is a "restart".
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          Initial residual vector to be generated.  If RESID is
-c          provided, force RESID into the range of the operator OP.
-c
-c  RNORM   Double precision scalar.  (OUTPUT)
-c          B-norm of the generated residual.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c
-c  WORKD   Complex*16 work array of length 2*N.  (REVERSE COMMUNICATION).
-c          On exit, WORK(1:N) = B*RESID to be used in SSAITR.
-c
-c  IERR    Integer.  (OUTPUT)
-c          =  0: Normal exit.
-c          = -1: Cannot generate a nontrivial restarted residual vector
-c                in the range of the operator OP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     arscnd  ARPACK utility routine for timing.
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlarnv  LAPACK routine for generating a random vector.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: getv0.F   SID: 2.3   DATE OF SID: 08/27/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zgetv0
-     &   ( ido, bmat, itry, initv, n, j, v, ldv, resid, rnorm,
-     &     ipntr, workd, ierr )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      logical    initv
-      integer    ido, ierr, itry, j, ldv, n
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex*16
-     &           resid(n), v(ldv,j), workd(2*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &            rzero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    first, inits, orth
-      integer    idist, iseed(4), iter, msglvl, jj
-      Double precision
-     &           rnorm0
-      Complex*16
-     &           cnorm
-      save       first, iseed, inits, iter, msglvl, orth, rnorm0
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy, zgemv, zlarnv, zvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dznrm2, dlapy2
-      Complex*16
-     &           zzdotc
-      external   zzdotc, dznrm2, dlapy2
-c
-c     %-----------------%
-c     | Data Statements |
-c     %-----------------%
-c
-      data       inits /.true./
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c
-c     %-----------------------------------%
-c     | Initialize the seed of the LAPACK |
-c     | random number generator           |
-c     %-----------------------------------%
-c
-      if (inits) then
-          iseed(1) = 1
-          iseed(2) = 3
-          iseed(3) = 5
-          iseed(4) = 7
-          inits = .false.
-      end if
-c
-      if (ido .eq.  0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mgetv0
-c
-         ierr   = 0
-         iter   = 0
-         first  = .FALSE.
-         orth   = .FALSE.
-c
-c        %-----------------------------------------------------%
-c        | Possibly generate a random starting vector in RESID |
-c        | Use a LAPACK random number generator used by the    |
-c        | matrix generation routines.                         |
-c        |    idist = 1: uniform (0,1)  distribution;          |
-c        |    idist = 2: uniform (-1,1) distribution;          |
-c        |    idist = 3: normal  (0,1)  distribution;          |
-c        %-----------------------------------------------------%
-c
-         if (.not.initv) then
-            idist = 2
-            call zlarnv (idist, iseed, n, resid)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Force the starting vector into the range of OP to handle |
-c        | the generalized problem when B is possibly (singular).   |
-c        %----------------------------------------------------------%
-c
-         call arscnd (t2)
-         if (itry .eq. 1) then
-            nopx = nopx + 1
-            ipntr(1) = 1
-            ipntr(2) = n + 1
-            call zcopy (n, resid, 1, workd, 1)
-            ido = -1
-            go to 9000
-         else if (itry .gt. 1 .and. bmat .eq. 'G') then
-            call zcopy (n, resid, 1, workd(n + 1), 1)
-         end if
-      end if
-c
-c     %----------------------------------------%
-c     | Back from computing OP*(initial-vector) |
-c     %----------------------------------------%
-c
-      if (first) go to 20
-c
-c     %-----------------------------------------------%
-c     | Back from computing OP*(orthogonalized-vector) |
-c     %-----------------------------------------------%
-c
-      if (orth)  go to 40
-c
-      call arscnd (t3)
-      tmvopx = tmvopx + (t3 - t2)
-c
-c     %------------------------------------------------------%
-c     | Starting vector is now in the range of OP; r = OP*r; |
-c     | Compute B-norm of starting vector.                   |
-c     %------------------------------------------------------%
-c
-      call arscnd (t2)
-      first = .TRUE.
-      if (itry .eq. 1) call zcopy (n, workd(n + 1), 1, resid, 1)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call zcopy (n, resid, 1, workd, 1)
-      end if
-c
-   20 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      first = .FALSE.
-      if (bmat .eq. 'G') then
-          cnorm  = zzdotc (n, resid, 1, workd, 1)
-          rnorm0 = sqrt(dlapy2(dble(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-           rnorm0 = dznrm2(n, resid, 1)
-      end if
-      rnorm  = rnorm0
-c
-c     %---------------------------------------------%
-c     | Exit if this is the very first Arnoldi step |
-c     %---------------------------------------------%
-c
-      if (j .eq. 1) go to 50
-c
-c     %----------------------------------------------------------------
-c     | Otherwise need to B-orthogonalize the starting vector against |
-c     | the current Arnoldi basis using Gram-Schmidt with iter. ref.  |
-c     | This is the case where an invariant subspace is encountered   |
-c     | in the middle of the Arnoldi factorization.                   |
-c     |                                                               |
-c     |       s = V^{T}*B*r;   r = r - V*s;                           |
-c     |                                                               |
-c     | Stopping criteria used for iter. ref. is discussed in         |
-c     | Parlett's book, page 107 and in Gragg & Reichel TOMS paper.   |
-c     %---------------------------------------------------------------%
-c
-      orth = .TRUE.
-   30 continue
-c
-      call zgemv ('C', n, j-1, one, v, ldv, workd, 1,
-     &            zero, workd(n+1), 1)
-      call zgemv ('N', n, j-1, -one, v, ldv, workd(n+1), 1,
-     &            one, resid, 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute the B-norm of the orthogonalized starting vector |
-c     %----------------------------------------------------------%
-c
-      call arscnd (t2)
-      if (bmat .eq. 'G') then
-         nbx = nbx + 1
-         call zcopy (n, resid, 1, workd(n+1), 1)
-         ipntr(1) = n + 1
-         ipntr(2) = 1
-         ido = 2
-         go to 9000
-      else if (bmat .eq. 'I') then
-         call zcopy (n, resid, 1, workd, 1)
-      end if
-c
-   40 continue
-c
-      if (bmat .eq. 'G') then
-         call arscnd (t3)
-         tmvbx = tmvbx + (t3 - t2)
-      end if
-c
-      if (bmat .eq. 'G') then
-         cnorm = zzdotc (n, resid, 1, workd, 1)
-         rnorm = sqrt(dlapy2(dble(cnorm),aimag(cnorm)))
-      else if (bmat .eq. 'I') then
-         rnorm = dznrm2(n, resid, 1)
-      end if
-c
-c     %--------------------------------------%
-c     | Check for further orthogonalization. |
-c     %--------------------------------------%
-c
-      if (msglvl .gt. 2) then
-          call dvout (logfil, 1, [rnorm0], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm0 is')
-          call dvout (logfil, 1, [rnorm], ndigit,
-     &                '_getv0: re-orthonalization ; rnorm is')
-      end if
-c
-      if (rnorm .gt. 0.717*rnorm0) go to 50
-c
-      iter = iter + 1
-      if (iter .le. 1) then
-c
-c        %-----------------------------------%
-c        | Perform iterative refinement step |
-c        %-----------------------------------%
-c
-         rnorm0 = rnorm
-         go to 30
-      else
-c
-c        %------------------------------------%
-c        | Iterative refinement step "failed" |
-c        %------------------------------------%
-c
-         do 45 jj = 1, n
-            resid(jj) = zero
-   45    continue
-         rnorm = rzero
-         ierr = -1
-      end if
-c
-   50 continue
-c
-      if (msglvl .gt. 0) then
-         call dvout (logfil, 1, [rnorm], ndigit,
-     &        '_getv0: B-norm of initial / restarted starting vector')
-      end if
-      if (msglvl .gt. 2) then
-         call zvout (logfil, n, resid, ndigit,
-     &        '_getv0: initial / restarted starting vector')
-      end if
-      ido = 99
-c
-      call arscnd (t1)
-      tgetv0 = tgetv0 + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zgetv0 |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaitr.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaitr.f
deleted file mode 100644
index 240412ca02..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaitr.f
+++ /dev/null
@@ -1,850 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaitr
-c
-c\Description:
-c  Reverse communication interface for applying NP additional steps to
-c  a K step nonsymmetric Arnoldi factorization.
-c
-c  Input:  OP*V_{k}  -  V_{k}*H = r_{k}*e_{k}^T
-c
-c          with (V_{k}^T)*B*V_{k} = I, (V_{k}^T)*B*r_{k} = 0.
-c
-c  Output: OP*V_{k+p}  -  V_{k+p}*H = r_{k+p}*e_{k+p}^T
-c
-c          with (V_{k+p}^T)*B*V_{k+p} = I, (V_{k+p}^T)*B*r_{k+p} = 0.
-c
-c  where OP and B are as in znaupd.  The B-norm of r_{k+p} is also
-c  computed and returned.
-c
-c\Usage:
-c  call znaitr
-c     ( IDO, BMAT, N, K, NP, NB, RESID, RNORM, V, LDV, H, LDH,
-c       IPNTR, WORKD, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c                    This is for the restart phase to force the new
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y,
-c                    IPNTR(3) is the pointer into WORK for B * X.
-c          IDO =  2: compute  Y = B * X  where
-c                    IPNTR(1) is the pointer into WORK for X,
-c                    IPNTR(2) is the pointer into WORK for Y.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          When the routine is used in the "shift-and-invert" mode, the
-c          vector B * Q is already available and do not need to be
-c          recomputed in forming OP * Q.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.  See znaupd.
-c          B = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          B = 'G' -> generalized eigenvalue problem A*x = lambda*M**x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  K       Integer.  (INPUT)
-c          Current size of V and H.
-c
-c  NP      Integer.  (INPUT)
-c          Number of additional Arnoldi steps to take.
-c
-c  NB      Integer.  (INPUT)
-c          Blocksize to be used in the recurrence.
-c          Only work for NB = 1 right now.  The goal is to have a
-c          program that implement both the block and non-block method.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          On INPUT:  RESID contains the residual vector r_{k}.
-c          On OUTPUT: RESID contains the residual vector r_{k+p}.
-c
-c  RNORM   Double precision scalar.  (INPUT/OUTPUT)
-c          B-norm of the starting residual on input.
-c          B-norm of the updated residual r_{k+p} on output.
-c
-c  V       Complex*16 N by K+NP array.  (INPUT/OUTPUT)
-c          On INPUT:  V contains the Arnoldi vectors in the first K
-c          columns.
-c          On OUTPUT: V contains the new NP Arnoldi vectors in the next
-c          NP columns.  The first K columns are unchanged.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16 (K+NP) by (K+NP) array.  (INPUT/OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORK for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16 work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The calling program should not
-c          use WORKD as temporary workspace during the iteration !!!!!!
-c          On input, WORKD(1:N) = B*RESID and is used to save some
-c          computation at the first step.
-c
-c  INFO    Integer.  (OUTPUT)
-c          = 0: Normal exit.
-c          > 0: Size of the spanning invariant subspace of OP found.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     zgetv0  ARPACK routine to generate the initial vector.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlanhs  LAPACK routine that computes various norms of a matrix.
-c     zlascl  LAPACK routine for careful scaling of a matrix.
-c     dlabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zaxpy   Level 1 BLAS that computes a vector triad.
-c     zcopy   Level 1 BLAS that copies one vector to another .
-c     zdotc   Level 1 BLAS that computes the scalar product of two vectors.
-c     zscal   Level 1 BLAS that scales a vector.
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naitr.F   SID: 2.3   DATE OF SID: 8/27/96   RELEASE: 2
-c
-c\Remarks
-c  The algorithm implemented is:
-c
-c  restart = .false.
-c  Given V_{k} = [v_{1}, ..., v_{k}], r_{k};
-c  r_{k} contains the initial residual vector even for k = 0;
-c  Also assume that rnorm = || B*r_{k} || and B*r_{k} are already
-c  computed by the calling program.
-c
-c  betaj = rnorm ; p_{k+1} = B*r_{k} ;
-c  For  j = k+1, ..., k+np  Do
-c     1) if ( betaj < tol ) stop or restart depending on j.
-c        ( At present tol is zero )
-c        if ( restart ) generate a new starting vector.
-c     2) v_{j} = r(j-1)/betaj;  V_{j} = [V_{j-1}, v_{j}];
-c        p_{j} = p_{j}/betaj
-c     3) r_{j} = OP*v_{j} where OP is defined as in znaupd
-c        For shift-invert mode p_{j} = B*v_{j} is already available.
-c        wnorm = || OP*v_{j} ||
-c     4) Compute the j-th step residual vector.
-c        w_{j} =  V_{j}^T * B * OP * v_{j}
-c        r_{j} =  OP*v_{j} - V_{j} * w_{j}
-c        H(:,j) = w_{j};
-c        H(j,j-1) = rnorm
-c        rnorm = || r_(j) ||
-c        If (rnorm > 0.717*wnorm) accept step and go back to 1)
-c     5) Re-orthogonalization step:
-c        s = V_{j}'*B*r_{j}
-c        r_{j} = r_{j} - V_{j}*s;  rnorm1 = || r_{j} ||
-c        alphaj = alphaj + s_{j};
-c     6) Iterative refinement step:
-c        If (rnorm1 > 0.717*rnorm) then
-c           rnorm = rnorm1
-c           accept step and go back to 1)
-c        Else
-c           rnorm = rnorm1
-c           If this is the first time in step 6), go to 5)
-c           Else r_{j} lies in the span of V_{j} numerically.
-c              Set r_{j} = 0 and rnorm = 0; go to 1)
-c        EndIf
-c  End Do
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaitr
-     &   (ido, bmat, n, k, np, nb, resid, rnorm, v, ldv, h, ldh,
-     &    ipntr, workd, info)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1
-      integer    ido, info, k, ldh, ldv, n, nb, np
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(3)
-      Complex*16
-     &           h(ldh,k+np), resid(n), v(ldv,k+np), workd(3*n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rone, rzero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rone = 1.0D+0, rzero = 0.0D+0)
-c
-c     %--------------%
-c     | Local Arrays |
-c     %--------------%
-c
-      Double precision
-     &           rtemp(2)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    first, orth1, orth2, rstart, step3, step4
-      integer    ierr, i, infol, ipj, irj, ivj, iter, itry, j, msglvl,
-     &           jj
-      Double precision
-     &           ovfl, smlnum, tst1, ulp, unfl, betaj,
-     &           temp1, rnorm1, wnorm
-      Complex*16
-     &           cnorm
-c
-      save       first, orth1, orth2, rstart, step3, step4,
-     &           ierr, ipj, irj, ivj, iter, itry, j, msglvl, ovfl,
-     &           betaj, rnorm1, smlnum, ulp, unfl, wnorm
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zaxpy, zcopy, zscal, zdscal, zgemv, zgetv0,
-     &           dlabad, zvout, zmout, ivout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Complex*16
-     &           zzdotc
-      Double precision
-     &           dlamch,  dznrm2, zlanhs, dlapy2
-      external   zzdotc, dznrm2, zlanhs, dlamch, dlapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag, dble, max, sqrt
-c
-c     %-----------------%
-c     | Data statements |
-c     %-----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------%
-c        | Set machine-dependent constants for the |
-c        | the splitting and deflation criterion.  |
-c        | If norm(H) <= sqrt(OVFL),               |
-c        | overflow should not occur.              |
-c        | REFERENCE: LAPACK subroutine zlahqr     |
-c        %-----------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = dble(one / unfl)
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call arscnd (t0)
-         msglvl = mcaitr
-c
-c        %------------------------------%
-c        | Initial call to this routine |
-c        %------------------------------%
-c
-         info   = 0
-         step3  = .false.
-         step4  = .false.
-         rstart = .false.
-         orth1  = .false.
-         orth2  = .false.
-         j      = k + 1
-         ipj    = 1
-         irj    = ipj   + n
-         ivj    = irj   + n
-      end if
-c
-c     %-------------------------------------------------%
-c     | When in reverse communication mode one of:      |
-c     | STEP3, STEP4, ORTH1, ORTH2, RSTART              |
-c     | will be .true. when ....                        |
-c     | STEP3: return from computing OP*v_{j}.          |
-c     | STEP4: return from computing B-norm of OP*v_{j} |
-c     | ORTH1: return from computing B-norm of r_{j+1}  |
-c     | ORTH2: return from computing B-norm of          |
-c     |        correction to the residual vector.       |
-c     | RSTART: return from OP computations needed by   |
-c     |         zgetv0.                                 |
-c     %-------------------------------------------------%
-c
-      if (step3)  go to 50
-      if (step4)  go to 60
-      if (orth1)  go to 70
-      if (orth2)  go to 90
-      if (rstart) go to 30
-c
-c     %-----------------------------%
-c     | Else this is the first step |
-c     %-----------------------------%
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |        A R N O L D I     I T E R A T I O N     L O O P       |
-c     |                                                              |
-c     | Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1) |
-c     %--------------------------------------------------------------%
-
- 1000 continue
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [j], ndigit,
-     &                  '_naitr: generating Arnoldi vector number')
-            call dvout (logfil, 1, [rnorm], ndigit,
-     &                  '_naitr: B-norm of the current residual is')
-         end if
-c
-c        %---------------------------------------------------%
-c        | STEP 1: Check if the B norm of j-th residual      |
-c        | vector is zero. Equivalent to determine whether   |
-c        | an exact j-step Arnoldi factorization is present. |
-c        %---------------------------------------------------%
-c
-         betaj = rnorm
-         if (rnorm .gt. rzero) go to 40
-c
-c           %---------------------------------------------------%
-c           | Invariant subspace found, generate a new starting |
-c           | vector which is orthogonal to the current Arnoldi |
-c           | basis and continue the iteration.                 |
-c           %---------------------------------------------------%
-c
-            if (msglvl .gt. 0) then
-               call ivout (logfil, 1, [j], ndigit,
-     &                     '_naitr: ****** RESTART AT STEP ******')
-            end if
-c
-c           %---------------------------------------------%
-c           | ITRY is the loop variable that controls the |
-c           | maximum amount of times that a restart is   |
-c           | attempted. NRSTRT is used by stat.h         |
-c           %---------------------------------------------%
-c
-            betaj  = rzero
-            nrstrt = nrstrt + 1
-            itry   = 1
-   20       continue
-            rstart = .true.
-            ido    = 0
-   30       continue
-c
-c           %--------------------------------------%
-c           | If in reverse communication mode and |
-c           | RSTART = .true. flow returns here.   |
-c           %--------------------------------------%
-c
-            call zgetv0 (ido, bmat, itry, .false., n, j, v, ldv,
-     &                   resid, rnorm, ipntr, workd, ierr)
-            if (ido .ne. 99) go to 9000
-            if (ierr .lt. 0) then
-               itry = itry + 1
-               if (itry .le. 3) go to 20
-c
-c              %------------------------------------------------%
-c              | Give up after several restart attempts.        |
-c              | Set INFO to the size of the invariant subspace |
-c              | which spans OP and exit.                       |
-c              %------------------------------------------------%
-c
-               info = j - 1
-               call arscnd (t1)
-               tcaitr = tcaitr + (t1 - t0)
-               ido = 99
-               go to 9000
-            end if
-c
-   40    continue
-c
-c        %---------------------------------------------------------%
-c        | STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm  |
-c        | Note that p_{j} = B*r_{j-1}. In order to avoid overflow |
-c        | when reciprocating a small RNORM, test against lower    |
-c        | machine bound.                                          |
-c        %---------------------------------------------------------%
-c
-         call zcopy (n, resid, 1, v(1,j), 1)
-         if ( rnorm .ge. unfl) then
-             temp1 = rone / rnorm
-             call zdscal (n, temp1, v(1,j), 1)
-             call zdscal (n, temp1, workd(ipj), 1)
-         else
-c
-c            %-----------------------------------------%
-c            | To scale both v_{j} and p_{j} carefully |
-c            | use LAPACK routine zlascl               |
-c            %-----------------------------------------%
-c
-             call zlascl ('General', i, i, rnorm, rone,
-     &                    n, 1, v(1,j), n, infol)
-             call zlascl ('General', i, i, rnorm, rone,
-     &                    n, 1, workd(ipj), n, infol)
-         end if
-c
-c        %------------------------------------------------------%
-c        | STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j} |
-c        | Note that this is not quite yet r_{j}. See STEP 4    |
-c        %------------------------------------------------------%
-c
-         step3 = .true.
-         nopx  = nopx + 1
-         call arscnd (t2)
-         call zcopy (n, v(1,j), 1, workd(ivj), 1)
-         ipntr(1) = ivj
-         ipntr(2) = irj
-         ipntr(3) = ipj
-         ido = 1
-c
-c        %-----------------------------------%
-c        | Exit in order to compute OP*v_{j} |
-c        %-----------------------------------%
-c
-         go to 9000
-   50    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IRJ:IRJ+N-1) := OP*v_{j}   |
-c        | if step3 = .true.                |
-c        %----------------------------------%
-c
-         call arscnd (t3)
-         tmvopx = tmvopx + (t3 - t2)
-
-         step3 = .false.
-c
-c        %------------------------------------------%
-c        | Put another copy of OP*v_{j} into RESID. |
-c        %------------------------------------------%
-c
-         call zcopy (n, workd(irj), 1, resid, 1)
-c
-c        %---------------------------------------%
-c        | STEP 4:  Finish extending the Arnoldi |
-c        |          factorization to length j.   |
-c        %---------------------------------------%
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            step4 = .true.
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-------------------------------------%
-c           | Exit in order to compute B*OP*v_{j} |
-c           %-------------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   60    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(IPJ:IPJ+N-1) := B*OP*v_{j} |
-c        | if step4 = .true.                |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         step4 = .false.
-c
-c        %-------------------------------------%
-c        | The following is needed for STEP 5. |
-c        | Compute the B-norm of OP*v_{j}.     |
-c        %-------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             cnorm = zzdotc (n, resid, 1, workd(ipj), 1)
-             wnorm = sqrt( dlapy2(dble(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             wnorm = dznrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------%
-c        | Compute the j-th residual corresponding |
-c        | to the j step factorization.            |
-c        | Use Classical Gram Schmidt and compute: |
-c        | w_{j} <-  V_{j}^T * B * OP * v_{j}      |
-c        | r_{j} <-  OP*v_{j} - V_{j} * w_{j}      |
-c        %-----------------------------------------%
-c
-c
-c        %------------------------------------------%
-c        | Compute the j Fourier coefficients w_{j} |
-c        | WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.  |
-c        %------------------------------------------%
-c
-         call zgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, h(1,j), 1)
-c
-c        %--------------------------------------%
-c        | Orthogonalize r_{j} against V_{j}.   |
-c        | RESID contains OP*v_{j}. See STEP 3. |
-c        %--------------------------------------%
-c
-         call zgemv ('N', n, j, -one, v, ldv, h(1,j), 1,
-     &               one, resid, 1)
-c
-         if (j .gt. 1) h(j,j-1) = cmplx(betaj, rzero, Kind=Kind(0d0))
-c
-         call arscnd (t4)
-c
-         orth1 = .true.
-c
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*r_{j} |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   70    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH1 = .true. |
-c        | WORKD(IPJ:IPJ+N-1) := B*r_{j}.                    |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         orth1 = .false.
-c
-c        %------------------------------%
-c        | Compute the B-norm of r_{j}. |
-c        %------------------------------%
-c
-         if (bmat .eq. 'G') then
-            cnorm = zzdotc (n, resid, 1, workd(ipj), 1)
-            rnorm = sqrt( dlapy2(dble(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-            rnorm = dznrm2(n, resid, 1)
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | STEP 5: Re-orthogonalization / Iterative refinement phase |
-c        | Maximum NITER_ITREF tries.                                |
-c        |                                                           |
-c        |          s      = V_{j}^T * B * r_{j}                     |
-c        |          r_{j}  = r_{j} - V_{j}*s                         |
-c        |          alphaj = alphaj + s_{j}                          |
-c        |                                                           |
-c        | The stopping criteria used for iterative refinement is    |
-c        | discussed in Parlett's book SEP, page 107 and in Gragg &  |
-c        | Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.         |
-c        | Determine if we need to correct the residual. The goal is |
-c        | to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||  |
-c        | The following test determines whether the sine of the     |
-c        | angle between  OP*x and the computed residual is less     |
-c        | than or equal to 0.717.                                   |
-c        %-----------------------------------------------------------%
-c
-         if ( rnorm .gt. 0.717*wnorm ) go to 100
-c
-         iter  = 0
-         nrorth = nrorth + 1
-c
-c        %---------------------------------------------------%
-c        | Enter the Iterative refinement phase. If further  |
-c        | refinement is necessary, loop back here. The loop |
-c        | variable is ITER. Perform a step of Classical     |
-c        | Gram-Schmidt using all the Arnoldi vectors V_{j}  |
-c        %---------------------------------------------------%
-c
-   80    continue
-c
-         if (msglvl .gt. 2) then
-            rtemp(1) = wnorm
-            rtemp(2) = rnorm
-            call dvout (logfil, 2, rtemp, ndigit,
-     &      '_naitr: re-orthogonalization; wnorm and rnorm are')
-            call zvout (logfil, j, h(1,j), ndigit,
-     &                  '_naitr: j-th column of H')
-         end if
-c
-c        %----------------------------------------------------%
-c        | Compute V_{j}^T * B * r_{j}.                       |
-c        | WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1). |
-c        %----------------------------------------------------%
-c
-         call zgemv ('C', n, j, one, v, ldv, workd(ipj), 1,
-     &               zero, workd(irj), 1)
-c
-c        %---------------------------------------------%
-c        | Compute the correction to the residual:     |
-c        | r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1). |
-c        | The correction to H is v(:,1:J)*H(1:J,1:J)  |
-c        | + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.         |
-c        %---------------------------------------------%
-c
-         call zgemv ('N', n, j, -one, v, ldv, workd(irj), 1,
-     &               one, resid, 1)
-         call zaxpy (j, one, workd(irj), 1, h(1,j), 1)
-c
-         orth2 = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy (n, resid, 1, workd(irj), 1)
-            ipntr(1) = irj
-            ipntr(2) = ipj
-            ido = 2
-c
-c           %-----------------------------------%
-c           | Exit in order to compute B*r_{j}. |
-c           | r_{j} is the corrected residual.  |
-c           %-----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy (n, resid, 1, workd(ipj), 1)
-         end if
-   90    continue
-c
-c        %---------------------------------------------------%
-c        | Back from reverse communication if ORTH2 = .true. |
-c        %---------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Compute the B-norm of the corrected residual r_{j}. |
-c        %-----------------------------------------------------%
-c
-         if (bmat .eq. 'G') then
-             cnorm  = zzdotc (n, resid, 1, workd(ipj), 1)
-             rnorm1 = sqrt( dlapy2(dble(cnorm),aimag(cnorm)) )
-         else if (bmat .eq. 'I') then
-             rnorm1 = dznrm2(n, resid, 1)
-         end if
-c
-         if (msglvl .gt. 0 .and. iter .gt. 0 ) then
-            call ivout (logfil, 1, [j], ndigit,
-     &           '_naitr: Iterative refinement for Arnoldi residual')
-            if (msglvl .gt. 2) then
-                rtemp(1) = rnorm
-                rtemp(2) = rnorm1
-                call dvout (logfil, 2, rtemp, ndigit,
-     &           '_naitr: iterative refinement ; rnorm and rnorm1 are')
-            end if
-         end if
-c
-c        %-----------------------------------------%
-c        | Determine if we need to perform another |
-c        | step of re-orthogonalization.           |
-c        %-----------------------------------------%
-c
-         if ( rnorm1 .gt. 0.717*rnorm ) then
-c
-c           %---------------------------------------%
-c           | No need for further refinement.       |
-c           | The cosine of the angle between the   |
-c           | corrected residual vector and the old |
-c           | residual vector is greater than 0.717 |
-c           | In other words the corrected residual |
-c           | and the old residual vector share an  |
-c           | angle of less than arcCOS(0.717)      |
-c           %---------------------------------------%
-c
-            rnorm = rnorm1
-c
-         else
-c
-c           %-------------------------------------------%
-c           | Another step of iterative refinement step |
-c           | is required. NITREF is used by stat.h     |
-c           %-------------------------------------------%
-c
-            nitref = nitref + 1
-            rnorm  = rnorm1
-            iter   = iter + 1
-            if (iter .le. 1) go to 80
-c
-c           %-------------------------------------------------%
-c           | Otherwise RESID is numerically in the span of V |
-c           %-------------------------------------------------%
-c
-            do 95 jj = 1, n
-               resid(jj) = zero
-  95        continue
-            rnorm = rzero
-         end if
-c
-c        %----------------------------------------------%
-c        | Branch here directly if iterative refinement |
-c        | wasn't necessary or after at most NITER_REF  |
-c        | steps of iterative refinement.               |
-c        %----------------------------------------------%
-c
-  100    continue
-c
-         rstart = .false.
-         orth2  = .false.
-c
-         call arscnd (t5)
-         titref = titref + (t5 - t4)
-c
-c        %------------------------------------%
-c        | STEP 6: Update  j = j+1;  Continue |
-c        %------------------------------------%
-c
-         j = j + 1
-         if (j .gt. k+np) then
-            call arscnd (t1)
-            tcaitr = tcaitr + (t1 - t0)
-            ido = 99
-            do 110 i = max(1,k), k+np-1
-c
-c              %--------------------------------------------%
-c              | Check for splitting and deflation.         |
-c              | Use a standard test as in the QR algorithm |
-c              | REFERENCE: LAPACK subroutine zlahqr        |
-c              %--------------------------------------------%
-c
-               tst1 = dlapy2(dble(h(i,i)),aimag(h(i,i)))
-     &              + dlapy2(dble(h(i+1,i+1)), aimag(h(i+1,i+1)))
-               if( tst1.eq.dble(zero) )
-     &              tst1 = zlanhs( '1', k+np, h, ldh, workd(n+1) )
-               if( dlapy2(dble(h(i+1,i)),aimag(h(i+1,i))) .le.
-     &                    max( ulp*tst1, smlnum ) )
-     &             h(i+1,i) = zero
- 110        continue
-c
-            if (msglvl .gt. 2) then
-               call zmout (logfil, k+np, k+np, h, ldh, ndigit,
-     &          '_naitr: Final upper Hessenberg matrix H of order K+NP')
-            end if
-c
-            go to 9000
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Loop back to extend the factorization by another step. |
-c        %--------------------------------------------------------%
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of znaitr |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znapps.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znapps.f
deleted file mode 100644
index 792fe6168f..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znapps.f
+++ /dev/null
@@ -1,507 +0,0 @@
-c\BeginDoc
-c
-c\Name: znapps
-c
-c\Description:
-c  Given the Arnoldi factorization
-c
-c     A*V_{k} - V_{k}*H_{k} = r_{k+p}*e_{k+p}^T,
-c
-c  apply NP implicit shifts resulting in
-c
-c     A*(V_{k}*Q) - (V_{k}*Q)*(Q^T* H_{k}*Q) = r_{k+p}*e_{k+p}^T * Q
-c
-c  where Q is an orthogonal matrix which is the product of rotations
-c  and reflections resulting from the NP bulge change sweeps.
-c  The updated Arnoldi factorization becomes:
-c
-c     A*VNEW_{k} - VNEW_{k}*HNEW_{k} = rnew_{k}*e_{k}^T.
-c
-c\Usage:
-c  call znapps
-c     ( N, KEV, NP, SHIFT, V, LDV, H, LDH, RESID, Q, LDQ,
-c       WORKL, WORKD )
-c
-c\Arguments
-c  N       Integer.  (INPUT)
-c          Problem size, i.e. size of matrix A.
-c
-c  KEV     Integer.  (INPUT/OUTPUT)
-c          KEV+NP is the size of the input matrix H.
-c          KEV is the size of the updated matrix HNEW.
-c
-c  NP      Integer.  (INPUT)
-c          Number of implicit shifts to be applied.
-c
-c  SHIFT   Complex*16 array of length NP.  (INPUT)
-c          The shifts to be applied.
-c
-c  V       Complex*16 N by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, V contains the current KEV+NP Arnoldi vectors.
-c          On OUTPUT, V contains the updated KEV Arnoldi vectors
-c          in the first KEV columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16 (KEV+NP) by (KEV+NP) array.  (INPUT/OUTPUT)
-c          On INPUT, H contains the current KEV+NP by KEV+NP upper
-c          Hessenberg matrix of the Arnoldi factorization.
-c          On OUTPUT, H contains the updated KEV by KEV upper Hessenberg
-c          matrix in the KEV leading submatrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RESID   Complex*16 array of length N.  (INPUT/OUTPUT)
-c          On INPUT, RESID contains the the residual vector r_{k+p}.
-c          On OUTPUT, RESID is the update residual vector rnew_{k}
-c          in the first KEV locations.
-c
-c  Q       Complex*16 KEV+NP by KEV+NP work array.  (WORKSPACE)
-c          Work array used to accumulate the rotations and reflections
-c          during the bulge chase sweep.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16 work array of length (KEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  WORKD   Complex*16 work array of length 2*N.  (WORKSPACE)
-c          Distributed array used in the application of the accumulated
-c          orthogonal matrix Q.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlanhs  LAPACK routine that computes various norms of a matrix.
-c     zlartg  LAPACK Givens rotation construction routine.
-c     zlaset  LAPACK matrix initialization routine.
-c     dlabad  LAPACK routine for defining the underflow and overflow
-c             limits.
-c     dlamch  LAPACK routine that determines machine constants.
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zgemv   Level 2 BLAS routine for matrix vector multiplication.
-c     zaxpy   Level 1 BLAS that computes a vector triad.
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zscal   Level 1 BLAS that scales a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: napps.F   SID: 2.3   DATE OF SID: 3/28/97   RELEASE: 2
-c
-c\Remarks
-c  1. In this version, each shift is applied to all the sublocks of
-c     the Hessenberg matrix H and not just to the submatrix that it
-c     comes from. Deflation as in LAPACK routine zlahqr (QR algorithm
-c     for upper Hessenberg matrices ) is used.
-c     Upon output, the subdiagonals of H are enforced to be non-negative
-c     real numbers.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znapps
-     &   ( n, kev, np, shift, v, ldv, h, ldh, resid, q, ldq,
-     &     workl, workd )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    kev, ldh, ldq, ldv, n, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           h(ldh,kev+np), resid(n), shift(np),
-     &           v(ldv,kev+np), q(ldq,kev+np), workd(2*n), workl(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rzero = 0.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      integer    i, iend, istart, j, jj, kplusp, msglvl
-      logical    first
-      Complex*16
-     &           cdum, f, g, h11, h21, r, s, sigma, t
-      Double precision
-     &           c,  ovfl, smlnum, ulp, unfl, tst1
-      save       first, ovfl, smlnum, ulp, unfl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zaxpy, zcopy, zgemv, zscal, zlacpy, zlartg,
-     &           zvout, zlaset, dlabad, zmout, arscnd, ivout
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           zlanhs, dlamch, dlapy2
-      external   zlanhs, dlamch, dlapy2
-c
-c     %----------------------%
-c     | Intrinsics Functions |
-c     %----------------------%
-c
-      intrinsic  abs, aimag, conjg, cmplx, max, min, dble
-c
-c     %---------------------%
-c     | Statement Functions |
-c     %---------------------%
-c
-      Double precision
-     &           zabs1
-      zabs1( cdum ) = abs( dble( cdum ) ) + abs( aimag( cdum ) )
-c
-c     %----------------%
-c     | Data statements |
-c     %----------------%
-c
-      data       first / .true. /
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (first) then
-c
-c        %-----------------------------------------------%
-c        | Set machine-dependent constants for the       |
-c        | stopping criterion. If norm(H) <= sqrt(OVFL), |
-c        | overflow should not occur.                    |
-c        | REFERENCE: LAPACK subroutine zlahqr           |
-c        %-----------------------------------------------%
-c
-         unfl = dlamch( 'safe minimum' )
-         ovfl = dble(one / unfl)
-         call dlabad( unfl, ovfl )
-         ulp = dlamch( 'precision' )
-         smlnum = unfl*( n / ulp )
-         first = .false.
-      end if
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcapps
-c
-      kplusp = kev + np
-c
-c     %--------------------------------------------%
-c     | Initialize Q to the identity to accumulate |
-c     | the rotations and reflections              |
-c     %--------------------------------------------%
-c
-      call zlaset ('All', kplusp, kplusp, zero, one, q, ldq)
-c
-c     %----------------------------------------------%
-c     | Quick return if there are no shifts to apply |
-c     %----------------------------------------------%
-c
-      if (np .eq. 0) go to 9000
-c
-c     %----------------------------------------------%
-c     | Chase the bulge with the application of each |
-c     | implicit shift. Each shift is applied to the |
-c     | whole matrix including each block.           |
-c     %----------------------------------------------%
-c
-      do 110 jj = 1, np
-         sigma = shift(jj)
-c
-         if (msglvl .gt. 2 ) then
-            call ivout (logfil, 1, [jj], ndigit,
-     &               '_napps: shift number.')
-            call zvout (logfil, 1, [sigma], ndigit,
-     &               '_napps: Value of the shift ')
-         end if
-c
-         istart = 1
-   20    continue
-c
-         do 30 i = istart, kplusp-1
-c
-c           %----------------------------------------%
-c           | Check for splitting and deflation. Use |
-c           | a standard test as in the QR algorithm |
-c           | REFERENCE: LAPACK subroutine zlahqr    |
-c           %----------------------------------------%
-c
-            tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
-            if( tst1.eq.rzero )
-     &         tst1 = zlanhs( '1', kplusp-jj+1, h, ldh, workl )
-            if ( abs(dble(h(i+1,i)))
-     &           .le. max(ulp*tst1, smlnum) )  then
-               if (msglvl .gt. 0) then
-                  call ivout (logfil, 1, [i], ndigit,
-     &                 '_napps: matrix splitting at row/column no.')
-                  call ivout (logfil, 1, [jj], ndigit,
-     &                 '_napps: matrix splitting with shift number.')
-                  call zvout (logfil, 1, h(i+1,i), ndigit,
-     &                 '_napps: off diagonal element.')
-               end if
-               iend = i
-               h(i+1,i) = zero
-               go to 40
-            end if
-   30    continue
-         iend = kplusp
-   40    continue
-c
-         if (msglvl .gt. 2) then
-             call ivout (logfil, 1, [istart], ndigit,
-     &                   '_napps: Start of current block ')
-             call ivout (logfil, 1, [iend], ndigit,
-     &                   '_napps: End of current block ')
-         end if
-c
-c        %------------------------------------------------%
-c        | No reason to apply a shift to block of order 1 |
-c        | or if the current block starts after the point |
-c        | of compression since we'll discard this stuff  |
-c        %------------------------------------------------%
-c
-         if ( istart .eq. iend .or. istart .gt. kev) go to 100
-c
-         h11 = h(istart,istart)
-         h21 = h(istart+1,istart)
-         f = h11 - sigma
-         g = h21
-c
-         do 80 i = istart, iend-1
-c
-c           %------------------------------------------------------%
-c           | Construct the plane rotation G to zero out the bulge |
-c           %------------------------------------------------------%
-c
-            call zlartg (f, g, c, s, r)
-            if (i .gt. istart) then
-               h(i,i-1) = r
-               h(i+1,i-1) = zero
-            end if
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the left of H;  H <- G'*H |
-c           %---------------------------------------------%
-c
-            do 50 j = i, kplusp
-               t        =  c*h(i,j) + s*h(i+1,j)
-               h(i+1,j) = -conjg(s)*h(i,j) + c*h(i+1,j)
-               h(i,j)   = t
-   50       continue
-c
-c           %---------------------------------------------%
-c           | Apply rotation to the right of H;  H <- H*G |
-c           %---------------------------------------------%
-c
-            do 60 j = 1, min(i+2,iend)
-               t        =  c*h(j,i) + conjg(s)*h(j,i+1)
-               h(j,i+1) = -s*h(j,i) + c*h(j,i+1)
-               h(j,i)   = t
-   60       continue
-c
-c           %-----------------------------------------------------%
-c           | Accumulate the rotation in the matrix Q;  Q <- Q*G' |
-c           %-----------------------------------------------------%
-c
-            do 70 j = 1, min(i+jj, kplusp)
-               t        =   c*q(j,i) + conjg(s)*q(j,i+1)
-               q(j,i+1) = - s*q(j,i) + c*q(j,i+1)
-               q(j,i)   = t
-   70       continue
-c
-c           %---------------------------%
-c           | Prepare for next rotation |
-c           %---------------------------%
-c
-            if (i .lt. iend-1) then
-               f = h(i+1,i)
-               g = h(i+2,i)
-            end if
-   80    continue
-c
-c        %-------------------------------%
-c        | Finished applying the shift.  |
-c        %-------------------------------%
-c
-  100    continue
-c
-c        %---------------------------------------------------------%
-c        | Apply the same shift to the next block if there is any. |
-c        %---------------------------------------------------------%
-c
-         istart = iend + 1
-         if (iend .lt. kplusp) go to 20
-c
-c        %---------------------------------------------%
-c        | Loop back to the top to get the next shift. |
-c        %---------------------------------------------%
-c
-  110 continue
-c
-c     %---------------------------------------------------%
-c     | Perform a similarity transformation that makes    |
-c     | sure that the compressed H will have non-negative |
-c     | real subdiagonal elements.                        |
-c     %---------------------------------------------------%
-c
-      do 120 j=1,kev
-         if ( dble( h(j+1,j) ) .lt. rzero .or.
-     &        aimag( h(j+1,j) ) .ne. rzero ) then
-            t = h(j+1,j) / dlapy2(dble(h(j+1,j)),aimag(h(j+1,j)))
-            call zscal( kplusp-j+1, conjg(t), h(j+1,j), ldh )
-            call zscal( min(j+2, kplusp), t, h(1,j+1), 1 )
-            call zscal( min(j+np+1,kplusp), t, q(1,j+1), 1 )
-            h(j+1,j) = cmplx( dble( h(j+1,j) ), rzero, Kind=Kind(0d0) )
-         end if
-  120 continue
-c
-      do 130 i = 1, kev
-c
-c        %--------------------------------------------%
-c        | Final check for splitting and deflation.   |
-c        | Use a standard test as in the QR algorithm |
-c        | REFERENCE: LAPACK subroutine zlahqr.       |
-c        | Note: Since the subdiagonals of the        |
-c        | compressed H are nonnegative real numbers, |
-c        | we take advantage of this.                 |
-c        %--------------------------------------------%
-c
-         tst1 = zabs1( h( i, i ) ) + zabs1( h( i+1, i+1 ) )
-         if( tst1 .eq. rzero )
-     &       tst1 = zlanhs( '1', kev, h, ldh, workl )
-         if( dble( h( i+1,i ) ) .le. max( ulp*tst1, smlnum ) )
-     &       h(i+1,i) = zero
- 130  continue
-c
-c     %-------------------------------------------------%
-c     | Compute the (kev+1)-st column of (V*Q) and      |
-c     | temporarily store the result in WORKD(N+1:2*N). |
-c     | This is needed in the residual update since we  |
-c     | cannot GUARANTEE that the corresponding entry   |
-c     | of H would be zero as in exact arithmetic.      |
-c     %-------------------------------------------------%
-c
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zgemv ('N', n, kplusp, one, v, ldv, q(1,kev+1), 1, zero,
-     &                workd(n+1), 1)
-c
-c     %----------------------------------------------------------%
-c     | Compute column 1 to kev of (V*Q) in backward order       |
-c     | taking advantage of the upper Hessenberg structure of Q. |
-c     %----------------------------------------------------------%
-c
-      do 140 i = 1, kev
-         call zgemv ('N', n, kplusp-i+1, one, v, ldv,
-     &               q(1,kev-i+1), 1, zero, workd, 1)
-         call zcopy (n, workd, 1, v(1,kplusp-i+1), 1)
-  140 continue
-c
-c     %-------------------------------------------------%
-c     |  Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev). |
-c     %-------------------------------------------------%
-c
-      call zlacpy ('A', n, kev, v(1,kplusp-kev+1), ldv, v, ldv)
-c
-c     %--------------------------------------------------------------%
-c     | Copy the (kev+1)-st column of (V*Q) in the appropriate place |
-c     %--------------------------------------------------------------%
-c
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zcopy (n, workd(n+1), 1, v(1,kev+1), 1)
-c
-c     %-------------------------------------%
-c     | Update the residual vector:         |
-c     |    r <- sigmak*r + betak*v(:,kev+1) |
-c     | where                               |
-c     |    sigmak = (e_{kev+p}'*Q)*e_{kev}  |
-c     |    betak = e_{kev+1}'*H*e_{kev}     |
-c     %-------------------------------------%
-c
-      call zscal (n, q(kplusp,kev), resid, 1)
-      if ( dble( h(kev+1,kev) ) .gt. rzero )
-     &   call zaxpy (n, h(kev+1,kev), v(1,kev+1), 1, resid, 1)
-c
-      if (msglvl .gt. 1) then
-         call zvout (logfil, 1, q(kplusp,kev), ndigit,
-     &        '_napps: sigmak = (e_{kev+p}^T*Q)*e_{kev}')
-         call zvout (logfil, 1, h(kev+1,kev), ndigit,
-     &        '_napps: betak = e_{kev+1}^T*H*e_{kev}')
-         call ivout (logfil, 1, [kev], ndigit,
-     &               '_napps: Order of the final Hessenberg matrix ')
-         if (msglvl .gt. 2) then
-            call zmout (logfil, kev, kev, h, ldh, ndigit,
-     &      '_napps: updated Hessenberg matrix H for next iteration')
-         end if
-c
-      end if
-c
- 9000 continue
-      call arscnd (t1)
-      tcapps = tcapps + (t1 - t0)
-c
-      return
-c
-c     %---------------%
-c     | End of znapps |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaup2.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaup2.f
deleted file mode 100644
index 0ab01dd0eb..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaup2.f
+++ /dev/null
@@ -1,801 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaup2
-c
-c\Description:
-c  Intermediate level interface called by znaupd .
-c
-c\Usage:
-c  call znaup2
-c     ( IDO, BMAT, N, WHICH, NEV, NP, TOL, RESID, MODE, IUPD,
-c       ISHIFT, MXITER, V, LDV, H, LDH, RITZ, BOUNDS,
-c       Q, LDQ, WORKL, IPNTR, WORKD, RWORK, INFO )
-c
-c\Arguments
-c
-c  IDO, BMAT, N, WHICH, NEV, TOL, RESID: same as defined in znaupd .
-c  MODE, ISHIFT, MXITER: see the definition of IPARAM in znaupd .
-c
-c  NP      Integer.  (INPUT/OUTPUT)
-c          Contains the number of implicit shifts to apply during
-c          each Arnoldi iteration.
-c          If ISHIFT=1, NP is adjusted dynamically at each iteration
-c          to accelerate convergence and prevent stagnation.
-c          This is also roughly equal to the number of matrix-vector
-c          products (involving the operator OP) per Arnoldi iteration.
-c          The logic for adjusting is contained within the current
-c          subroutine.
-c          If ISHIFT=0, NP is the number of shifts the user needs
-c          to provide via reverse communication. 0 < NP < NCV-NEV.
-c          NP may be less than NCV-NEV since a leading block of the current
-c          upper Hessenberg matrix has split off and contains "unwanted"
-c          Ritz values.
-c          Upon termination of the IRA iteration, NP contains the number
-c          of "converged" wanted Ritz values.
-c
-c  IUPD    Integer.  (INPUT)
-c          IUPD .EQ. 0: use explicit restart instead implicit update.
-c          IUPD .NE. 0: use implicit update.
-c
-c  V       Complex*16  N by (NEV+NP) array.  (INPUT/OUTPUT)
-c          The Arnoldi basis vectors are returned in the first NEV
-c          columns of V.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling
-c          program.
-c
-c  H       Complex*16  (NEV+NP) by (NEV+NP) array.  (OUTPUT)
-c          H is used to store the generated upper Hessenberg matrix
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex*16  array of length NEV+NP.  (OUTPUT)
-c          RITZ(1:NEV)  contains the computed Ritz values of OP.
-c
-c  BOUNDS  Complex*16  array of length NEV+NP.  (OUTPUT)
-c          BOUNDS(1:NEV) contain the error bounds corresponding to
-c          the computed Ritz values.
-c
-c  Q       Complex*16  (NEV+NP) by (NEV+NP) array.  (WORKSPACE)
-c          Private (replicated) work array used to accumulate the
-c          rotation in the shift application step.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16  work array of length at least
-c          (NEV+NP)**2 + 3*(NEV+NP).  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  It is used in shifts calculation, shifts
-c          application and convergence checking.
-c
-c
-c  IPNTR   Integer array of length 3.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD for
-c          vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X.
-c          IPNTR(2): pointer to the current result vector Y.
-c          IPNTR(3): pointer to the vector B * X when used in the
-c                    shift-and-invert mode.  X is the current operand.
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16  work array of length 3*N.  (WORKSPACE)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note in ZNAUPD .
-c
-c  RWORK   Double precision    work array of length  NEV+NP ( WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =     0: Normal return.
-c          =     1: Maximum number of iterations taken.
-c                   All possible eigenvalues of OP has been found.
-c                   NP returns the number of converged Ritz values.
-c          =     2: No shifts could be applied.
-c          =    -8: Error return from LAPACK eigenvalue calculation;
-c                   This should never happen.
-c          =    -9: Starting vector is zero.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   Size that was built in returned in NP.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c
-c\Routines called:
-c     zgetv0   ARPACK initial vector generation routine.
-c     znaitr   ARPACK Arnoldi factorization routine.
-c     znapps   ARPACK application of implicit shifts routine.
-c     zneigh   ARPACK compute Ritz values and error bounds routine.
-c     zngets   ARPACK reorder Ritz values and error bounds routine.
-c     zsortc   ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout    ARPACK utility routine that prints matrices
-c     zvout    ARPACK utility routine that prints vectors.
-c     dvout    ARPACK utility routine that prints vectors.
-c     dlamch   LAPACK routine that determines machine constants.
-c     dlapy2   LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c     zcopy    Level 1 BLAS that copies one vector to another .
-c     zdotc    Level 1 BLAS that computes the scalar product of two vectors.
-c     zswap    Level 1 BLAS that swaps two vectors.
-c     dznrm2   Level 1 BLAS that computes the norm of a vector.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice Universitya
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naup2.F   SID: 2.6   DATE OF SID: 06/01/00   RELEASE: 2
-c
-c\Remarks
-c     1. None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaup2
-     &   ( ido, bmat, n, which, nev, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, h, ldh, ritz, bounds,
-     &     q, ldq, workl, ipntr, workd, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ishift, iupd, mode, ldh, ldq, ldv, mxiter,
-     &           n, nev, np
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    ipntr(13)
-      Complex*16
-     &           bounds(nev+np), h(ldh,nev+np), q(ldq,nev+np),
-     &           resid(n), ritz(nev+np),  v(ldv,nev+np),
-     &           workd(3*n), workl( (nev+np)*(nev+np+3) )
-       Double precision
-     &           rwork(nev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rzero
-      parameter (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) ,
-     &           rzero = 0.0D+0 )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      logical    cnorm , getv0, initv , update, ushift
-      integer    ierr  , iter , kplusp, msglvl, nconv,
-     &           nevbef, nev0 , np0   , nptemp, i    ,
-     &           j
-      Complex*16
-     &           cmpnorm
-      Double precision
-     &           rnorm , eps23, rtemp
-      character  wprime*2
-c
-      save       cnorm,  getv0, initv , update, ushift,
-     &           rnorm,  iter , kplusp, msglvl, nconv ,
-     &           nevbef, nev0 , np0   , eps23
-c
-c
-c     %-----------------------%
-c     | Local array arguments |
-c     %-----------------------%
-c
-      integer    kp(3)
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy , zgetv0 , znaitr , zneigh , zngets , znapps ,
-     &           zsortc , zswap , zmout , zvout , ivout, arscnd
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Complex*16
-     &           zzdotc
-      Double precision
-     &           dznrm2 , dlamch , dlapy2
-      external   zzdotc , dznrm2 , dlamch , dlapy2
-c
-c     %---------------------%
-c     | Intrinsic Functions |
-c     %---------------------%
-c
-      intrinsic  aimag , dble , min, max
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-         call arscnd (t0)
-c
-         msglvl = mcaup2
-c
-         nev0   = nev
-         np0    = np
-c
-c        %-------------------------------------%
-c        | kplusp is the bound on the largest  |
-c        |        Lanczos factorization built. |
-c        | nconv is the current number of      |
-c        |        "converged" eigenvalues.     |
-c        | iter is the counter on the current  |
-c        |      iteration step.                |
-c        %-------------------------------------%
-c
-         kplusp = nev + np
-         nconv  = 0
-         iter   = 0
-c
-c        %---------------------------------%
-c        | Get machine dependent constant. |
-c        %---------------------------------%
-c
-         eps23 = dlamch ('Epsilon-Machine')
-         eps23 = eps23**(2.0D+0  / 3.0D+0 )
-c
-c        %---------------------------------------%
-c        | Set flags for computing the first NEV |
-c        | steps of the Arnoldi factorization.   |
-c        %---------------------------------------%
-c
-         getv0    = .true.
-         update   = .false.
-         ushift   = .false.
-         cnorm    = .false.
-c
-         if (info .ne. 0) then
-c
-c           %--------------------------------------------%
-c           | User provides the initial residual vector. |
-c           %--------------------------------------------%
-c
-            initv = .true.
-            info  = 0
-         else
-            initv = .false.
-         end if
-      end if
-c
-c     %---------------------------------------------%
-c     | Get a possibly random starting vector and   |
-c     | force it into the range of the operator OP. |
-c     %---------------------------------------------%
-c
-   10 continue
-c
-      if (getv0) then
-         call zgetv0  (ido, bmat, 1, initv, n, 1, v, ldv, resid, rnorm,
-     &                ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (rnorm .eq. rzero) then
-c
-c           %-----------------------------------------%
-c           | The initial vector is zero. Error exit. |
-c           %-----------------------------------------%
-c
-            info = -9
-            go to 1100
-         end if
-         getv0 = .false.
-         ido  = 0
-      end if
-c
-c     %-----------------------------------%
-c     | Back from reverse communication : |
-c     | continue with update step         |
-c     %-----------------------------------%
-c
-      if (update) go to 20
-c
-c     %-------------------------------------------%
-c     | Back from computing user specified shifts |
-c     %-------------------------------------------%
-c
-      if (ushift) go to 50
-c
-c     %-------------------------------------%
-c     | Back from computing residual norm   |
-c     | at the end of the current iteration |
-c     %-------------------------------------%
-c
-      if (cnorm)  go to 100
-c
-c     %----------------------------------------------------------%
-c     | Compute the first NEV steps of the Arnoldi factorization |
-c     %----------------------------------------------------------%
-c
-      call znaitr  (ido, bmat, n, 0, nev, mode, resid, rnorm, v, ldv,
-     &             h, ldh, ipntr, workd, info)
-c
-      if (ido .ne. 99) go to 9000
-c
-      if (info .gt. 0) then
-         np   = info
-         mxiter = iter
-         info = -9999
-         go to 1200
-      end if
-c
-c     %--------------------------------------------------------------%
-c     |                                                              |
-c     |           M A I N  ARNOLDI  I T E R A T I O N  L O O P       |
-c     |           Each iteration implicitly restarts the Arnoldi     |
-c     |           factorization in place.                            |
-c     |                                                              |
-c     %--------------------------------------------------------------%
-c
- 1000 continue
-c
-         iter = iter + 1
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [iter], ndigit,
-     &           '_naup2: **** Start of major iteration number ****')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        | Adjust NP since NEV might have been updated by last call  |
-c        | to the shift application routine znapps .                  |
-c        %-----------------------------------------------------------%
-c
-         np  = kplusp - nev
-c
-         if (msglvl .gt. 1) then
-            call ivout (logfil, 1, [nev], ndigit,
-     &     '_naup2: The length of the current Arnoldi factorization')
-            call ivout (logfil, 1, [np], ndigit,
-     &           '_naup2: Extend the Arnoldi factorization by')
-         end if
-c
-c        %-----------------------------------------------------------%
-c        | Compute NP additional steps of the Arnoldi factorization. |
-c        %-----------------------------------------------------------%
-c
-         ido = 0
-   20    continue
-         update = .true.
-c
-         call znaitr (ido, bmat, n, nev, np,    mode,  resid, rnorm,
-     &               v  , ldv , h, ldh, ipntr, workd, info)
-c
-         if (ido .ne. 99) go to 9000
-c
-         if (info .gt. 0) then
-            np = info
-            mxiter = iter
-            info = -9999
-            go to 1200
-         end if
-         update = .false.
-c
-         if (msglvl .gt. 1) then
-            call dvout  (logfil, 1, [rnorm], ndigit,
-     &           '_naup2: Corresponding B-norm of the residual')
-         end if
-c
-c        %--------------------------------------------------------%
-c        | Compute the eigenvalues and corresponding error bounds |
-c        | of the current upper Hessenberg matrix.                |
-c        %--------------------------------------------------------%
-c
-         call zneigh  (rnorm, kplusp, h, ldh, ritz, bounds,
-     &                q, ldq, workl, rwork,  ierr)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 1200
-         end if
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | error bounds are in the last NEV loc. of RITZ,    |
-c        | and BOUNDS respectively.                          |
-c        %---------------------------------------------------%
-c
-         nev = nev0
-         np = np0
-c
-c        %--------------------------------------------------%
-c        | Make a copy of Ritz values and the corresponding |
-c        | Ritz estimates obtained from zneigh .             |
-c        %--------------------------------------------------%
-c
-         call zcopy (kplusp,ritz,1,workl(kplusp**2+1),1)
-         call zcopy (kplusp,bounds,1,workl(kplusp**2+kplusp+1),1)
-c
-c        %---------------------------------------------------%
-c        | Select the wanted Ritz values and their bounds    |
-c        | to be used in the convergence test.               |
-c        | The wanted part of the spectrum and corresponding |
-c        | bounds are in the last NEV loc. of RITZ           |
-c        | BOUNDS respectively.                              |
-c        %---------------------------------------------------%
-c
-         call zngets  (ishift, which, nev, np, ritz, bounds)
-c
-c        %------------------------------------------------------------%
-c        | Convergence test: currently we use the following criteria. |
-c        | The relative accuracy of a Ritz value is considered        |
-c        | acceptable if:                                             |
-c        |                                                            |
-c        | error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)). |
-c        |                                                            |
-c        %------------------------------------------------------------%
-c
-         nconv  = 0
-c
-         do 25 i = 1, nev
-            rtemp = max( eps23, dlapy2 ( dble (ritz(np+i)),
-     &                                  aimag (ritz(np+i)) ) )
-            if ( dlapy2 (dble (bounds(np+i)),aimag (bounds(np+i)))
-     &                 .le. tol*rtemp ) then
-               nconv = nconv + 1
-            end if
-   25    continue
-c
-         if (msglvl .gt. 2) then
-            kp(1) = nev
-            kp(2) = np
-            kp(3) = nconv
-            call ivout (logfil, 3, kp, ndigit,
-     &                  '_naup2: NEV, NP, NCONV are')
-            call zvout  (logfil, kplusp, ritz, ndigit,
-     &           '_naup2: The eigenvalues of H')
-            call zvout  (logfil, kplusp, bounds, ndigit,
-     &          '_naup2: Ritz estimates of the current NCV Ritz values')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Count the number of unwanted Ritz values that have zero |
-c        | Ritz estimates. If any Ritz estimates are equal to zero |
-c        | then a leading block of H of order equal to at least    |
-c        | the number of Ritz values with zero Ritz estimates has  |
-c        | split off. None of these Ritz values may be removed by  |
-c        | shifting. Decrease NP the number of shifts to apply. If |
-c        | no shifts may be applied, then prepare to exit          |
-c        %---------------------------------------------------------%
-c
-         nptemp = np
-         do 30 j=1, nptemp
-            if (bounds(j) .eq. zero) then
-               np = np - 1
-               nev = nev + 1
-            end if
- 30      continue
-c
-         if ( (nconv .ge. nev0) .or.
-     &        (iter .gt. mxiter) .or.
-     &        (np .eq. 0) ) then
-c
-            if (msglvl .gt. 4) then
-               call zvout (logfil, kplusp, workl(kplusp**2+1), ndigit,
-     &             '_naup2: Eigenvalues computed by _neigh:')
-               call zvout (logfil, kplusp, workl(kplusp**2+kplusp+1),
-     &                     ndigit,
-     &             '_naup2: Ritz estimates computed by _neigh:')
-            end if
-c
-c           %------------------------------------------------%
-c           | Prepare to exit. Put the converged Ritz values |
-c           | and corresponding bounds in RITZ(1:NCONV) and  |
-c           | BOUNDS(1:NCONV) respectively. Then sort. Be    |
-c           | careful when NCONV > NP                        |
-c           %------------------------------------------------%
-c
-c           %------------------------------------------%
-c           |  Use h( 3,1 ) as storage to communicate  |
-c           |  rnorm to zneupd  if needed               |
-c           %------------------------------------------%
-
-            h(3,1) = cmplx (rnorm,rzero,Kind=Kind(0d0))
-c
-c           %----------------------------------------------%
-c           | Sort Ritz values so that converged Ritz      |
-c           | values appear within the first NEV locations |
-c           | of ritz and bounds, and the most desired one |
-c           | appears at the front.                        |
-c           %----------------------------------------------%
-c
-            if (which .eq. 'LM') wprime = 'SM'
-            if (which .eq. 'SM') wprime = 'LM'
-            if (which .eq. 'LR') wprime = 'SR'
-            if (which .eq. 'SR') wprime = 'LR'
-            if (which .eq. 'LI') wprime = 'SI'
-            if (which .eq. 'SI') wprime = 'LI'
-c
-            call zsortc (wprime, .true., kplusp, ritz, bounds)
-c
-c           %--------------------------------------------------%
-c           | Scale the Ritz estimate of each Ritz value       |
-c           | by 1 / max(eps23, magnitude of the Ritz value).  |
-c           %--------------------------------------------------%
-c
-            do 35 j = 1, nev0
-                rtemp = max( eps23, dlapy2 ( dble (ritz(j)),
-     &                                       aimag (ritz(j)) ) )
-                bounds(j) = bounds(j)/rtemp
- 35         continue
-c
-c           %---------------------------------------------------%
-c           | Sort the Ritz values according to the scaled Ritz |
-c           | estimates.  This will push all the converged ones |
-c           | towards the front of ritz, bounds (in the case    |
-c           | when NCONV < NEV.)                                |
-c           %---------------------------------------------------%
-c
-            wprime = 'LM'
-            call zsortc (wprime, .true., nev0, bounds, ritz)
-c
-c           %----------------------------------------------%
-c           | Scale the Ritz estimate back to its original |
-c           | value.                                       |
-c           %----------------------------------------------%
-c
-            do 40 j = 1, nev0
-                rtemp = max( eps23, dlapy2 ( dble (ritz(j)),
-     &                                       aimag (ritz(j)) ) )
-                bounds(j) = bounds(j)*rtemp
- 40         continue
-c
-c           %-----------------------------------------------%
-c           | Sort the converged Ritz values again so that  |
-c           | the "threshold" value appears at the front of |
-c           | ritz and bound.                               |
-c           %-----------------------------------------------%
-c
-            call zsortc (which, .true., nconv, ritz, bounds)
-c
-            if (msglvl .gt. 1) then
-               call zvout  (logfil, kplusp, ritz, ndigit,
-     &            '_naup2: Sorted eigenvalues')
-               call zvout  (logfil, kplusp, bounds, ndigit,
-     &            '_naup2: Sorted ritz estimates.')
-            end if
-c
-c           %------------------------------------%
-c           | Max iterations have been exceeded. |
-c           %------------------------------------%
-c
-            if (iter .gt. mxiter .and. nconv .lt. nev0) info = 1
-c
-c           %---------------------%
-c           | No shifts to apply. |
-c           %---------------------%
-c
-            if (np .eq. 0 .and. nconv .lt. nev0)  info = 2
-c
-            np = nconv
-            go to 1100
-c
-         else if ( (nconv .lt. nev0) .and. (ishift .eq. 1) ) then
-c
-c           %-------------------------------------------------%
-c           | Do not have all the requested eigenvalues yet.  |
-c           | To prevent possible stagnation, adjust the size |
-c           | of NEV.                                         |
-c           %-------------------------------------------------%
-c
-            nevbef = nev
-            nev = nev + min(nconv, np/2)
-            if (nev .eq. 1 .and. kplusp .ge. 6) then
-               nev = kplusp / 2
-            else if (nev .eq. 1 .and. kplusp .gt. 3) then
-               nev = 2
-            end if
-            np = kplusp - nev
-c
-c           %---------------------------------------%
-c           | If the size of NEV was just increased |
-c           | resort the eigenvalues.               |
-c           %---------------------------------------%
-c
-            if (nevbef .lt. nev)
-     &         call zngets  (ishift, which, nev, np, ritz, bounds)
-c
-         end if
-c
-         if (msglvl .gt. 0) then
-            call ivout (logfil, 1, [nconv], ndigit,
-     &           '_naup2: no. of "converged" Ritz values at this iter.')
-            if (msglvl .gt. 1) then
-               kp(1) = nev
-               kp(2) = np
-               call ivout (logfil, 2, kp, ndigit,
-     &              '_naup2: NEV and NP are')
-               call zvout  (logfil, nev, ritz(np+1), ndigit,
-     &              '_naup2: "wanted" Ritz values ')
-               call zvout  (logfil, nev, bounds(np+1), ndigit,
-     &              '_naup2: Ritz estimates of the "wanted" values ')
-            end if
-         end if
-c
-         if (ishift .eq. 0) then
-c
-c           %-------------------------------------------------------%
-c           | User specified shifts: pop back out to get the shifts |
-c           | and return them in the first 2*NP locations of WORKL. |
-c           %-------------------------------------------------------%
-c
-            ushift = .true.
-            ido = 3
-            go to 9000
-         end if
-   50    continue
-         ushift = .false.
-c
-         if ( ishift .ne. 1 ) then
-c
-c            %----------------------------------%
-c            | Move the NP shifts from WORKL to |
-c            | RITZ, to free up WORKL           |
-c            | for non-exact shift case.        |
-c            %----------------------------------%
-c
-             call zcopy  (np, workl, 1, ritz, 1)
-         end if
-c
-         if (msglvl .gt. 2) then
-            call ivout (logfil, 1, [np], ndigit,
-     &                  '_naup2: The number of shifts to apply ')
-            call zvout  (logfil, np, ritz, ndigit,
-     &                  '_naup2: values of the shifts')
-            if ( ishift .eq. 1 )
-     &          call zvout  (logfil, np, bounds, ndigit,
-     &                  '_naup2: Ritz estimates of the shifts')
-         end if
-c
-c        %---------------------------------------------------------%
-c        | Apply the NP implicit shifts by QR bulge chasing.       |
-c        | Each shift is applied to the whole upper Hessenberg     |
-c        | matrix H.                                               |
-c        | The first 2*N locations of WORKD are used as workspace. |
-c        %---------------------------------------------------------%
-c
-         call znapps  (n, nev, np, ritz, v, ldv,
-     &                h, ldh, resid, q, ldq, workl, workd)
-c
-c        %---------------------------------------------%
-c        | Compute the B-norm of the updated residual. |
-c        | Keep B*RESID in WORKD(1:N) to be used in    |
-c        | the first step of the next call to znaitr .  |
-c        %---------------------------------------------%
-c
-         cnorm = .true.
-         call arscnd (t2)
-         if (bmat .eq. 'G') then
-            nbx = nbx + 1
-            call zcopy  (n, resid, 1, workd(n+1), 1)
-            ipntr(1) = n + 1
-            ipntr(2) = 1
-            ido = 2
-c
-c           %----------------------------------%
-c           | Exit in order to compute B*RESID |
-c           %----------------------------------%
-c
-            go to 9000
-         else if (bmat .eq. 'I') then
-            call zcopy  (n, resid, 1, workd, 1)
-         end if
-c
-  100    continue
-c
-c        %----------------------------------%
-c        | Back from reverse communication; |
-c        | WORKD(1:N) := B*RESID            |
-c        %----------------------------------%
-c
-         if (bmat .eq. 'G') then
-            call arscnd (t3)
-            tmvbx = tmvbx + (t3 - t2)
-         end if
-c
-         if (bmat .eq. 'G') then
-            cmpnorm = zzdotc  (n, resid, 1, workd, 1)
-            rnorm = sqrt(dlapy2 (dble (cmpnorm),aimag (cmpnorm)))
-         else if (bmat .eq. 'I') then
-            rnorm = dznrm2 (n, resid, 1)
-         end if
-         cnorm = .false.
-c
-         if (msglvl .gt. 2) then
-            call dvout  (logfil, 1, [rnorm], ndigit,
-     &      '_naup2: B-norm of residual for compressed factorization')
-            call zmout  (logfil, nev, nev, h, ldh, ndigit,
-     &        '_naup2: Compressed upper Hessenberg matrix H')
-         end if
-c
-      go to 1000
-c
-c     %---------------------------------------------------------------%
-c     |                                                               |
-c     |  E N D     O F     M A I N     I T E R A T I O N     L O O P  |
-c     |                                                               |
-c     %---------------------------------------------------------------%
-c
- 1100 continue
-c
-      mxiter = iter
-      nev = nconv
-c
- 1200 continue
-      ido = 99
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      call arscnd (t1)
-      tcaup2 = t1 - t0
-c
- 9000 continue
-c
-c     %---------------%
-c     | End of znaup2  |
-c     %---------------%
-c
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaupd.f
deleted file mode 100644
index c7d58aaab9..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/znaupd.f
+++ /dev/null
@@ -1,664 +0,0 @@
-c\BeginDoc
-c
-c\Name: znaupd
-c
-c\Description:
-c  Reverse communication interface for the Implicitly Restarted Arnoldi
-c  iteration. This is intended to be used to find a few eigenpairs of a
-c  complex linear operator OP with respect to a semi-inner product defined
-c  by a hermitian positive semi-definite real matrix B. B may be the identity
-c  matrix.  NOTE: if both OP and B are real, then dsaupd  or dnaupd  should
-c  be used.
-c
-c
-c  The computed approximate eigenvalues are called Ritz values and
-c  the corresponding approximate eigenvectors are called Ritz vectors.
-c
-c  znaupd  is usually called iteratively to solve one of the
-c  following problems:
-c
-c  Mode 1:  A*x = lambda*x.
-c           ===> OP = A  and  B = I.
-c
-c  Mode 2:  A*x = lambda*M*x, M hermitian positive definite
-c           ===> OP = inv[M]*A  and  B = M.
-c           ===> (If M can be factored see remark 3 below)
-c
-c  Mode 3:  A*x = lambda*M*x, M hermitian semi-definite
-c           ===> OP =  inv[A - sigma*M]*M   and  B = M.
-c           ===> shift-and-invert mode
-c           If OP*x = amu*x, then lambda = sigma + 1/amu.
-c
-c
-c  NOTE: The action of w <- inv[A - sigma*M]*v or w <- inv[M]*v
-c        should be accomplished either by a direct method
-c        using a sparse matrix factorization and solving
-c
-c           [A - sigma*M]*w = v  or M*w = v,
-c
-c        or through an iterative method for solving these
-c        systems.  If an iterative method is used, the
-c        convergence test must be more stringent than
-c        the accuracy requirements for the eigenvalue
-c        approximations.
-c
-c\Usage:
-c  call znaupd
-c     ( IDO, BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM,
-c       IPNTR, WORKD, WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments
-c  IDO     Integer.  (INPUT/OUTPUT)
-c          Reverse communication flag.  IDO must be zero on the first
-c          call to znaupd .  IDO will be set internally to
-c          indicate the type of operation to be performed.  Control is
-c          then given back to the calling routine which has the
-c          responsibility to carry out the requested operation and call
-c          znaupd  with the result.  The operand is given in
-c          WORKD(IPNTR(1)), the result must be put in WORKD(IPNTR(2)).
-c          -------------------------------------------------------------
-c          IDO =  0: first call to the reverse communication interface
-c          IDO = -1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    This is for the initialization phase to force the
-c                    starting vector into the range of OP.
-c          IDO =  1: compute  Y = OP * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c                    In mode 3, the vector B * X is already
-c                    available in WORKD(ipntr(3)).  It does not
-c                    need to be recomputed in forming OP * X.
-c          IDO =  2: compute  Y = M * X  where
-c                    IPNTR(1) is the pointer into WORKD for X,
-c                    IPNTR(2) is the pointer into WORKD for Y.
-c          IDO =  3: compute and return the shifts in the first
-c                    NP locations of WORKL.
-c          IDO = 99: done
-c          -------------------------------------------------------------
-c          After the initialization phase, when the routine is used in
-c          the "shift-and-invert" mode, the vector M * X is already
-c          available and does not need to be recomputed in forming OP*X.
-c
-c  BMAT    Character*1.  (INPUT)
-c          BMAT specifies the type of the matrix B that defines the
-c          semi-inner product for the operator OP.
-c          BMAT = 'I' -> standard eigenvalue problem A*x = lambda*x
-c          BMAT = 'G' -> generalized eigenvalue problem A*x = lambda*M*x
-c
-c  N       Integer.  (INPUT)
-c          Dimension of the eigenproblem.
-c
-c  WHICH   Character*2.  (INPUT)
-c          'LM' -> want the NEV eigenvalues of largest magnitude.
-c          'SM' -> want the NEV eigenvalues of smallest magnitude.
-c          'LR' -> want the NEV eigenvalues of largest real part.
-c          'SR' -> want the NEV eigenvalues of smallest real part.
-c          'LI' -> want the NEV eigenvalues of largest imaginary part.
-c          'SI' -> want the NEV eigenvalues of smallest imaginary part.
-c
-c  NEV     Integer.  (INPUT)
-c          Number of eigenvalues of OP to be computed. 0 < NEV < N-1.
-c
-c  TOL     Double precision   scalar.  (INPUT)
-c          Stopping criteria: the relative accuracy of the Ritz value
-c          is considered acceptable if BOUNDS(I) .LE. TOL*ABS(RITZ(I))
-c          where ABS(RITZ(I)) is the magnitude when RITZ(I) is complex.
-c          DEFAULT = dlamch ('EPS')  (machine precision as computed
-c                    by the LAPACK auxiliary subroutine dlamch ).
-c
-c  RESID   Complex*16  array of length N.  (INPUT/OUTPUT)
-c          On INPUT:
-c          If INFO .EQ. 0, a random initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          On OUTPUT:
-c          RESID contains the final residual vector.
-c
-c  NCV     Integer.  (INPUT)
-c          Number of columns of the matrix V. NCV must satisfy the two
-c          inequalities 1 <= NCV-NEV and NCV <= N.
-c          This will indicate how many Arnoldi vectors are generated
-c          at each iteration.  After the startup phase in which NEV
-c          Arnoldi vectors are generated, the algorithm generates
-c          approximately NCV-NEV Arnoldi vectors at each subsequent update
-c          iteration. Most of the cost in generating each Arnoldi vector is
-c          in the matrix-vector operation OP*x. (See remark 4 below.)
-c
-c  V       Complex*16  array N by NCV.  (OUTPUT)
-c          Contains the final set of Arnoldi basis vectors.
-c
-c  LDV     Integer.  (INPUT)
-c          Leading dimension of V exactly as declared in the calling program.
-c
-c  IPARAM  Integer array of length 11.  (INPUT/OUTPUT)
-c          IPARAM(1) = ISHIFT: method for selecting the implicit shifts.
-c          The shifts selected at each iteration are used to filter out
-c          the components of the unwanted eigenvector.
-c          -------------------------------------------------------------
-c          ISHIFT = 0: the shifts are to be provided by the user via
-c                      reverse communication.  The NCV eigenvalues of
-c                      the Hessenberg matrix H are returned in the part
-c                      of WORKL array corresponding to RITZ.
-c          ISHIFT = 1: exact shifts with respect to the current
-c                      Hessenberg matrix H.  This is equivalent to
-c                      restarting the iteration from the beginning
-c                      after updating the starting vector with a linear
-c                      combination of Ritz vectors associated with the
-c                      "wanted" eigenvalues.
-c          ISHIFT = 2: other choice of internal shift to be defined.
-c          -------------------------------------------------------------
-c
-c          IPARAM(2) = No longer referenced
-c
-c          IPARAM(3) = MXITER
-c          On INPUT:  maximum number of Arnoldi update iterations allowed.
-c          On OUTPUT: actual number of Arnoldi update iterations taken.
-c
-c          IPARAM(4) = NB: blocksize to be used in the recurrence.
-c          The code currently works only for NB = 1.
-c
-c          IPARAM(5) = NCONV: number of "converged" Ritz values.
-c          This represents the number of Ritz values that satisfy
-c          the convergence criterion.
-c
-c          IPARAM(6) = IUPD
-c          No longer referenced. Implicit restarting is ALWAYS used.
-c
-c          IPARAM(7) = MODE
-c          On INPUT determines what type of eigenproblem is being solved.
-c          Must be 1,2,3; See under \Description of znaupd  for the
-c          four modes available.
-c
-c          IPARAM(8) = NP
-c          When ido = 3 and the user provides shifts through reverse
-c          communication (IPARAM(1)=0), _naupd returns NP, the number
-c          of shifts the user is to provide. 0 < NP < NCV-NEV.
-c
-c          IPARAM(9) = NUMOP, IPARAM(10) = NUMOPB, IPARAM(11) = NUMREO,
-c          OUTPUT: NUMOP  = total number of OP*x operations,
-c                  NUMOPB = total number of B*x operations if BMAT='G',
-c                  NUMREO = total number of steps of re-orthogonalization.
-c
-c  IPNTR   Integer array of length 14.  (OUTPUT)
-c          Pointer to mark the starting locations in the WORKD and WORKL
-c          arrays for matrices/vectors used by the Arnoldi iteration.
-c          -------------------------------------------------------------
-c          IPNTR(1): pointer to the current operand vector X in WORKD.
-c          IPNTR(2): pointer to the current result vector Y in WORKD.
-c          IPNTR(3): pointer to the vector B * X in WORKD when used in
-c                    the shift-and-invert mode.
-c          IPNTR(4): pointer to the next available location in WORKL
-c                    that is untouched by the program.
-c          IPNTR(5): pointer to the NCV by NCV upper Hessenberg
-c                    matrix H in WORKL.
-c          IPNTR(6): pointer to the  ritz value array  RITZ
-c          IPNTR(7): pointer to the (projected) ritz vector array Q
-c          IPNTR(8): pointer to the error BOUNDS array in WORKL.
-c          IPNTR(14): pointer to the NP shifts in WORKL. See Remark 5 below.
-c
-c          Note: IPNTR(9:13) is only referenced by zneupd . See Remark 2 below.
-c
-c          IPNTR(9): pointer to the NCV RITZ values of the
-c                    original system.
-c          IPNTR(10): Not Used
-c          IPNTR(11): pointer to the NCV corresponding error bounds.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     zneupd  if RVEC = .TRUE. See Remark 2 below.
-c
-c          -------------------------------------------------------------
-c
-c  WORKD   Complex*16  work array of length 3*N.  (REVERSE COMMUNICATION)
-c          Distributed array to be used in the basic Arnoldi iteration
-c          for reverse communication.  The user should not use WORKD
-c          as temporary workspace during the iteration !!!!!!!!!!
-c          See Data Distribution Note below.
-c
-c  WORKL   Complex*16  work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  See Data Distribution Note below.
-c
-c  LWORKL  Integer.  (INPUT)
-c          LWORKL must be at least 3*NCV**2 + 5*NCV.
-c
-c  RWORK   Double precision   work array of length NCV (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c
-c  INFO    Integer.  (INPUT/OUTPUT)
-c          If INFO .EQ. 0, a randomly initial residual vector is used.
-c          If INFO .NE. 0, RESID contains the initial residual vector,
-c                          possibly from a previous run.
-c          Error flag on output.
-c          =  0: Normal exit.
-c          =  1: Maximum number of iterations taken.
-c                All possible eigenvalues of OP has been found. IPARAM(5)
-c                returns the number of wanted converged Ritz values.
-c          =  2: No longer an informational error. Deprecated starting
-c                with release 2 of ARPACK.
-c          =  3: No shifts could be applied during a cycle of the
-c                Implicitly restarted Arnoldi iteration. One possibility
-c                is to increase the size of NCV relative to NEV.
-c                See remark 4 below.
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 2 and less than or equal to N.
-c          = -4: The maximum number of Arnoldi update iteration
-c                must be greater than zero.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation;
-c          = -9: Starting vector is zero.
-c          = -10: IPARAM(7) must be 1,2,3.
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: IPARAM(1) must be equal to 0 or 1.
-c          = -9999: Could not build an Arnoldi factorization.
-c                   User input error highly likely.  Please
-c                   check actual array dimensions and layout.
-c                   IPARAM(5) returns the size of the current Arnoldi
-c                   factorization.
-c
-c\Remarks
-c  1. The computed Ritz values are approximate eigenvalues of OP. The
-c     selection of WHICH should be made with this in mind when using
-c     Mode = 3.  When operating in Mode = 3 setting WHICH = 'LM' will
-c     compute the NEV eigenvalues of the original problem that are
-c     closest to the shift SIGMA . After convergence, approximate eigenvalues
-c     of the original problem may be obtained with the ARPACK subroutine zneupd .
-c
-c  2. If a basis for the invariant subspace corresponding to the converged Ritz
-c     values is needed, the user must call zneupd  immediately following
-c     completion of znaupd . This is new starting with release 2 of ARPACK.
-c
-c  3. If M can be factored into a Cholesky factorization M = LL`
-c     then Mode = 2 should not be selected.  Instead one should use
-c     Mode = 1 with  OP = inv(L)*A*inv(L`).  Appropriate triangular
-c     linear systems should be solved with L and L` rather
-c     than computing inverses.  After convergence, an approximate
-c     eigenvector z of the original problem is recovered by solving
-c     L`z = x  where x is a Ritz vector of OP.
-c
-c  4. At present there is no a-priori analysis to guide the selection
-c     of NCV relative to NEV.  The only formal requirement is that NCV > NEV + 1.
-c     However, it is recommended that NCV .ge. 2*NEV.  If many problems of
-c     the same type are to be solved, one should experiment with increasing
-c     NCV while keeping NEV fixed for a given test problem.  This will
-c     usually decrease the required number of OP*x operations but it
-c     also increases the work and storage required to maintain the orthogonal
-c     basis vectors.  The optimal "cross-over" with respect to CPU time
-c     is problem dependent and must be determined empirically.
-c     See Chapter 8 of Reference 2 for further information.
-c
-c  5. When IPARAM(1) = 0, and IDO = 3, the user needs to provide the
-c     NP = IPARAM(8) complex shifts in locations
-c     WORKL(IPNTR(14)), WORKL(IPNTR(14)+1), ... , WORKL(IPNTR(14)+NP).
-c     Eigenvalues of the current upper Hessenberg matrix are located in
-c     WORKL(IPNTR(6)) through WORKL(IPNTR(6)+NCV-1). They are ordered
-c     according to the order defined by WHICH.  The associated Ritz estimates
-c     are located in WORKL(IPNTR(8)), WORKL(IPNTR(8)+1), ... ,
-c     WORKL(IPNTR(8)+NCV-1).
-c
-c-----------------------------------------------------------------------
-c
-c\Data Distribution Note:
-c
-c  Fortran-D syntax:
-c  ================
-c  Complex*16  resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-c  decompose  d1(n), d2(n,ncv)
-c  align      resid(i) with d1(i)
-c  align      v(i,j)   with d2(i,j)
-c  align      workd(i) with d1(i)     range (1:n)
-c  align      workd(i) with d1(i-n)   range (n+1:2*n)
-c  align      workd(i) with d1(i-2*n) range (2*n+1:3*n)
-c  distribute d1(block), d2(block,:)
-c  replicated workl(lworkl)
-c
-c  Cray MPP syntax:
-c  ===============
-c  Complex*16  resid(n), v(ldv,ncv), workd(n,3), workl(lworkl)
-c  shared     resid(block), v(block,:), workd(block,:)
-c  replicated workl(lworkl)
-c
-c  CM2/CM5 syntax:
-c  ==============
-c
-c-----------------------------------------------------------------------
-c
-c     include   'ex-nonsym.doc'
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B.N. Parlett & Y. Saad, "_Complex_ Shift and Invert Strategies for
-c     _Real_ Matrices", Linear Algebra and its Applications, vol 88/89,
-c     pp 575-595, (1987).
-c
-c\Routines called:
-c     znaup2   ARPACK routine that implements the Implicitly Restarted
-c             Arnoldi Iteration.
-c     zstatn   ARPACK routine that initializes the timing variables.
-c     ivout   ARPACK utility routine that prints integers.
-c     zvout    ARPACK utility routine that prints vectors.
-c     arscnd  ARPACK utility routine for timing.
-c     dlamch   LAPACK routine that determines machine constants.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: naupd.F   SID: 2.8   DATE OF SID: 04/10/01   RELEASE: 2
-c
-c\Remarks
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine znaupd
-     &   ( ido, bmat, n, which, nev, tol, resid, ncv, v, ldv, iparam,
-     &     ipntr, workd, workl, lworkl, rwork, info )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat*1, which*2
-      integer    ido, info, ldv, lworkl, n, ncv, nev
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      Complex*16
-     &           resid(n), v(ldv,ncv), workd(3*n), workl(lworkl)
-      Double precision
-     &           rwork(ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter (one = (1.0D+0, 0.0D+0) , zero = (0.0D+0, 0.0D+0) )
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    bounds, ierr, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz, j
-      save       bounds, ih, iq, ishift, iupd, iw,
-     &           ldh, ldq, levec, mode, msglvl, mxiter, nb,
-     &           nev0, next, np, ritz
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   znaup2 , zvout , ivout, arscnd, zstatn
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlamch
-      external   dlamch
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      if (ido .eq. 0) then
-c
-c        %-------------------------------%
-c        | Initialize timing statistics  |
-c        | & message level for debugging |
-c        %-------------------------------%
-c
-         call zstatn
-         call arscnd (t0)
-         msglvl = mcaupd
-c
-c        %----------------%
-c        | Error checking |
-c        %----------------%
-c
-         ierr   = 0
-         ishift = iparam(1)
-c         levec  = iparam(2)
-         mxiter = iparam(3)
-c         nb     = iparam(4)
-         nb     = 1
-c
-c        %--------------------------------------------%
-c        | Revision 2 performs only implicit restart. |
-c        %--------------------------------------------%
-c
-         iupd   = 1
-         mode   = iparam(7)
-c
-         if (n .le. 0) then
-             ierr = -1
-         else if (nev .le. 0) then
-             ierr = -2
-         else if (ncv .le. nev .or.  ncv .gt. n) then
-             ierr = -3
-         else if (mxiter .le. 0) then
-             ierr = -4
-         else if (which .ne. 'LM' .and.
-     &       which .ne. 'SM' .and.
-     &       which .ne. 'LR' .and.
-     &       which .ne. 'SR' .and.
-     &       which .ne. 'LI' .and.
-     &       which .ne. 'SI') then
-            ierr = -5
-         else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-            ierr = -6
-         else if (lworkl .lt. 3*ncv**2 + 5*ncv) then
-            ierr = -7
-         else if (mode .lt. 1 .or. mode .gt. 3) then
-                                                ierr = -10
-         else if (mode .eq. 1 .and. bmat .eq. 'G') then
-                                                ierr = -11
-         end if
-c
-c        %------------%
-c        | Error Exit |
-c        %------------%
-c
-         if (ierr .ne. 0) then
-            info = ierr
-            ido  = 99
-            go to 9000
-         end if
-c
-c        %------------------------%
-c        | Set default parameters |
-c        %------------------------%
-c
-         if (nb .le. 0)				nb = 1
-         if (tol .le. 0.0D+0  )			tol = dlamch ('EpsMach')
-         if (ishift .ne. 0  .and.
-     &       ishift .ne. 1  .and.
-     &       ishift .ne. 2) 			ishift = 1
-c
-c        %----------------------------------------------%
-c        | NP is the number of additional steps to      |
-c        | extend the length NEV Lanczos factorization. |
-c        | NEV0 is the local variable designating the   |
-c        | size of the invariant subspace desired.      |
-c        %----------------------------------------------%
-c
-         np     = ncv - nev
-         nev0   = nev
-c
-c        %-----------------------------%
-c        | Zero out internal workspace |
-c        %-----------------------------%
-c
-         do 10 j = 1, 3*ncv**2 + 5*ncv
-            workl(j) = zero
-  10     continue
-c
-c        %-------------------------------------------------------------%
-c        | Pointer into WORKL for address of H, RITZ, BOUNDS, Q        |
-c        | etc... and the remaining workspace.                         |
-c        | Also update pointer to be used on output.                   |
-c        | Memory is laid out as follows:                              |
-c        | workl(1:ncv*ncv) := generated Hessenberg matrix             |
-c        | workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values             |
-c        | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds        |
-c        | workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q |
-c        | workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace       |
-c        | The final workspace is needed by subroutine zneigh  called   |
-c        | by znaup2 . Subroutine zneigh  calls LAPACK routines for      |
-c        | calculating eigenvalues and the last row of the eigenvector |
-c        | matrix.                                                     |
-c        %-------------------------------------------------------------%
-c
-         ldh    = ncv
-         ldq    = ncv
-         ih     = 1
-         ritz   = ih     + ldh*ncv
-         bounds = ritz   + ncv
-         iq     = bounds + ncv
-         iw     = iq     + ldq*ncv
-         next   = iw     + ncv**2 + 3*ncv
-c
-         ipntr(4) = next
-         ipntr(5) = ih
-         ipntr(6) = ritz
-         ipntr(7) = iq
-         ipntr(8) = bounds
-         ipntr(14) = iw
-      end if
-c
-c     %-------------------------------------------------------%
-c     | Carry out the Implicitly restarted Arnoldi Iteration. |
-c     %-------------------------------------------------------%
-c
-      call znaup2
-     &   ( ido, bmat, n, which, nev0, np, tol, resid, mode, iupd,
-     &     ishift, mxiter, v, ldv, workl(ih), ldh, workl(ritz),
-     &     workl(bounds), workl(iq), ldq, workl(iw),
-     &     ipntr, workd, rwork, info )
-c
-c     %--------------------------------------------------%
-c     | ido .ne. 99 implies use of reverse communication |
-c     | to compute operations involving OP.              |
-c     %--------------------------------------------------%
-c
-      if (ido .eq. 3) iparam(8) = np
-      if (ido .ne. 99) go to 9000
-c
-      iparam(3) = mxiter
-      iparam(5) = np
-      iparam(9) = nopx
-      iparam(10) = nbx
-      iparam(11) = nrorth
-c
-c     %------------------------------------%
-c     | Exit if there was an informational |
-c     | error within znaup2 .               |
-c     %------------------------------------%
-c
-      if (info .lt. 0) go to 9000
-      if (info .eq. 2) info = 3
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [mxiter], ndigit,
-     &               '_naupd: Number of update iterations taken')
-         call ivout (logfil, 1, [np], ndigit,
-     &               '_naupd: Number of wanted "converged" Ritz values')
-         call zvout  (logfil, np, workl(ritz), ndigit,
-     &               '_naupd: The final Ritz values')
-         call zvout  (logfil, np, workl(bounds), ndigit,
-     &               '_naupd: Associated Ritz estimates')
-      end if
-c
-      call arscnd (t1)
-      tcaupd = t1 - t0
-c
-      if (msglvl .gt. 0) then
-c
-c        %--------------------------------------------------------%
-c        | Version Number & Version Date are defined in version.h |
-c        %--------------------------------------------------------%
-c
-         write (6,1000)
-         write (6,1100) mxiter, nopx, nbx, nrorth, nitref, nrstrt,
-     &                  tmvopx, tmvbx, tcaupd, tcaup2, tcaitr, titref,
-     &                  tgetv0, tceigh, tcgets, tcapps, tcconv, trvec
- 1000    format (//,
-     &      5x, '=============================================',/
-     &      5x, '= Complex implicit Arnoldi update code      =',/
-     &      5x, '= Version Number: ', ' 2.3' , 21x, ' =',/
-     &      5x, '= Version Date:   ', ' 07/31/96' , 16x,   ' =',/
-     &      5x, '=============================================',/
-     &      5x, '= Summary of timing statistics              =',/
-     &      5x, '=============================================',//)
- 1100    format (
-     &      5x, 'Total number update iterations             = ', i5,/
-     &      5x, 'Total number of OP*x operations            = ', i5,/
-     &      5x, 'Total number of B*x operations             = ', i5,/
-     &      5x, 'Total number of reorthogonalization steps  = ', i5,/
-     &      5x, 'Total number of iterative refinement steps = ', i5,/
-     &      5x, 'Total number of restart steps              = ', i5,/
-     &      5x, 'Total time in user OP*x operation          = ', f12.6,/
-     &      5x, 'Total time in user B*x operation           = ', f12.6,/
-     &      5x, 'Total time in Arnoldi update routine       = ', f12.6,/
-     &      5x, 'Total time in naup2 routine                = ', f12.6,/
-     &      5x, 'Total time in basic Arnoldi iteration loop = ', f12.6,/
-     &      5x, 'Total time in reorthogonalization phase    = ', f12.6,/
-     &      5x, 'Total time in (re)start vector generation  = ', f12.6,/
-     &      5x, 'Total time in Hessenberg eig. subproblem   = ', f12.6,/
-     &      5x, 'Total time in getting the shifts           = ', f12.6,/
-     &      5x, 'Total time in applying the shifts          = ', f12.6,/
-     &      5x, 'Total time in convergence testing          = ', f12.6,/
-     &      5x, 'Total time in computing final Ritz vectors = ', f12.6/)
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of znaupd  |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneigh.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneigh.f
deleted file mode 100644
index db1bc22985..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneigh.f
+++ /dev/null
@@ -1,257 +0,0 @@
-c\BeginDoc
-c
-c\Name: zneigh
-c
-c\Description:
-c  Compute the eigenvalues of the current upper Hessenberg matrix
-c  and the corresponding Ritz estimates given the current residual norm.
-c
-c\Usage:
-c  call zneigh
-c     ( RNORM, N, H, LDH, RITZ, BOUNDS, Q, LDQ, WORKL, RWORK, IERR )
-c
-c\Arguments
-c  RNORM   Double precision scalar.  (INPUT)
-c          Residual norm corresponding to the current upper Hessenberg
-c          matrix H.
-c
-c  N       Integer.  (INPUT)
-c          Size of the matrix H.
-c
-c  H       Complex*16 N by N array.  (INPUT)
-c          H contains the current upper Hessenberg matrix.
-c
-c  LDH     Integer.  (INPUT)
-c          Leading dimension of H exactly as declared in the calling
-c          program.
-c
-c  RITZ    Complex*16 array of length N.  (OUTPUT)
-c          On output, RITZ(1:N) contains the eigenvalues of H.
-c
-c  BOUNDS  Complex*16 array of length N.  (OUTPUT)
-c          On output, BOUNDS contains the Ritz estimates associated with
-c          the eigenvalues held in RITZ.  This is equal to RNORM
-c          times the last components of the eigenvectors corresponding
-c          to the eigenvalues in RITZ.
-c
-c  Q       Complex*16 N by N array.  (WORKSPACE)
-c          Workspace needed to store the eigenvectors of H.
-c
-c  LDQ     Integer.  (INPUT)
-c          Leading dimension of Q exactly as declared in the calling
-c          program.
-c
-c  WORKL   Complex*16 work array of length N**2 + 3*N.  (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.  This is needed to keep the full Schur form
-c          of H and also in the calculation of the eigenvectors of H.
-c
-c  RWORK   Double precision  work array of length N (WORKSPACE)
-c          Private (replicated) array on each PE or array allocated on
-c          the front end.
-c
-c  IERR    Integer.  (OUTPUT)
-c          Error exit flag from zlahqr or ztrevc.
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     dvout   ARPACK utility routine that prints vectors.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlahqr  LAPACK routine to compute the Schur form of an
-c             upper Hessenberg matrix.
-c     zlaset  LAPACK matrix initialization routine.
-c     ztrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form
-c     zcopy   Level 1 BLAS that copies one vector to another.
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2  Level 1 BLAS that computes the norm of a vector.
-c
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neigh.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     None
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zneigh (rnorm, n, h, ldh, ritz, bounds,
-     &                   q, ldq, workl, rwork, ierr)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      integer    ierr, n, ldh, ldq
-      Double precision
-     &           rnorm
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           bounds(n), h(ldh,n), q(ldq,n), ritz(n),
-     &           workl(n*(n+3))
-      Double precision
-     &           rwork(n)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      Double precision
-     &           rone
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0),
-     &           rone = 1.0D+0)
-c
-c     %------------------------%
-c     | Local Scalars & Arrays |
-c     %------------------------%
-c
-      logical    select(1)
-      integer    j,  msglvl
-      Complex*16
-     &           vl(1)
-      Double precision
-     &           temp
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zlacpy, zlahqr, ztrevc, zcopy,
-     &           zdscal, zmout, zvout, arscnd
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dznrm2
-      external   dznrm2
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mceigh
-c
-      if (msglvl .gt. 2) then
-          call zmout (logfil, n, n, h, ldh, ndigit,
-     &         '_neigh: Entering upper Hessenberg matrix H ')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 1. Compute the eigenvalues, the last components of the   |
-c     |    corresponding Schur vectors and the full Schur form T |
-c     |    of the current upper Hessenberg matrix H.             |
-c     |    zlahqr returns the full Schur form of H               |
-c     |    in WORKL(1:N**2), and the Schur vectors in q.         |
-c     %----------------------------------------------------------%
-c
-      call zlacpy ('All', n, n, h, ldh, workl, n)
-      call zlaset ('All', n, n, zero, one, q, ldq)
-      call zlahqr (.true., .true., n, 1, n, workl, ldh, ritz,
-     &             1, n, q, ldq, ierr)
-      if (ierr .ne. 0) go to 9000
-c
-      call zcopy (n, q(n-1,1), ldq, bounds, 1)
-      if (msglvl .gt. 1) then
-         call zvout (logfil, n, bounds, ndigit,
-     &              '_neigh: last row of the Schur matrix for H')
-      end if
-c
-c     %----------------------------------------------------------%
-c     | 2. Compute the eigenvectors of the full Schur form T and |
-c     |    apply the Schur vectors to get the corresponding      |
-c     |    eigenvectors.                                         |
-c     %----------------------------------------------------------%
-c
-      call ztrevc ('Right', 'Back', select, n, workl, n, vl, n, q,
-     &             ldq, n, n, workl(n*n+1), rwork, ierr)
-c
-      if (ierr .ne. 0) go to 9000
-c
-c     %------------------------------------------------%
-c     | Scale the returning eigenvectors so that their |
-c     | Euclidean norms are all one. LAPACK subroutine |
-c     | ztrevc returns each eigenvector normalized so  |
-c     | that the element of largest magnitude has      |
-c     | magnitude 1; here the magnitude of a complex   |
-c     | number (x,y) is taken to be |x| + |y|.         |
-c     %------------------------------------------------%
-c
-      do 10 j=1, n
-            temp = dznrm2( n, q(1,j), 1 )
-            call zdscal ( n, rone / temp, q(1,j), 1 )
-   10 continue
-c
-      if (msglvl .gt. 1) then
-         call zcopy(n, q(n,1), ldq, workl, 1)
-         call zvout (logfil, n, workl, ndigit,
-     &              '_neigh: Last row of the eigenvector matrix for H')
-      end if
-c
-c     %----------------------------%
-c     | Compute the Ritz estimates |
-c     %----------------------------%
-c
-      call zcopy(n, q(n,1), n, bounds, 1)
-      call zdscal(n, rnorm, bounds, 1)
-c
-      if (msglvl .gt. 2) then
-         call zvout (logfil, n, ritz, ndigit,
-     &              '_neigh: The eigenvalues of H')
-         call zvout (logfil, n, bounds, ndigit,
-     &              '_neigh: Ritz estimates for the eigenvalues of H')
-      end if
-c
-      call arscnd(t1)
-      tceigh = tceigh + (t1 - t0)
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zneigh |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneupd.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneupd.f
deleted file mode 100644
index 92e7dc9980..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zneupd.f
+++ /dev/null
@@ -1,876 +0,0 @@
-c\BeginDoc
-c
-c\Name: zneupd
-c
-c\Description:
-c  This subroutine returns the converged approximations to eigenvalues
-c  of A*z = lambda*B*z and (optionally):
-c
-c      (1) The corresponding approximate eigenvectors;
-c
-c      (2) An orthonormal basis for the associated approximate
-c          invariant subspace;
-c
-c      (3) Both.
-c
-c  There is negligible additional cost to obtain eigenvectors.  An orthonormal
-c  basis is always computed.  There is an additional storage cost of n*nev
-c  if both are requested (in this case a separate array Z must be supplied).
-c
-c  The approximate eigenvalues and eigenvectors of  A*z = lambda*B*z
-c  are derived from approximate eigenvalues and eigenvectors of
-c  of the linear operator OP prescribed by the MODE selection in the
-c  call to ZNAUPD.  ZNAUPD must be called before this routine is called.
-c  These approximate eigenvalues and vectors are commonly called Ritz
-c  values and Ritz vectors respectively.  They are referred to as such
-c  in the comments that follow.   The computed orthonormal basis for the
-c  invariant subspace corresponding to these Ritz values is referred to as a
-c  Schur basis.
-c
-c  The definition of OP as well as other terms and the relation of computed
-c  Ritz values and vectors of OP with respect to the given problem
-c  A*z = lambda*B*z may be found in the header of ZNAUPD.  For a brief
-c  description, see definitions of IPARAM(7), MODE and WHICH in the
-c  documentation of ZNAUPD.
-c
-c\Usage:
-c  call zneupd
-c     ( RVEC, HOWMNY, SELECT, D, Z, LDZ, SIGMA, WORKEV, BMAT,
-c       N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR, WORKD,
-c       WORKL, LWORKL, RWORK, INFO )
-c
-c\Arguments:
-c  RVEC    LOGICAL  (INPUT)
-c          Specifies whether a basis for the invariant subspace corresponding
-c          to the converged Ritz value approximations for the eigenproblem
-c          A*z = lambda*B*z is computed.
-c
-c             RVEC = .FALSE.     Compute Ritz values only.
-c
-c             RVEC = .TRUE.      Compute Ritz vectors or Schur vectors.
-c                                See Remarks below.
-c
-c  HOWMNY  Character*1  (INPUT)
-c          Specifies the form of the basis for the invariant subspace
-c          corresponding to the converged Ritz values that is to be computed.
-c
-c          = 'A': Compute NEV Ritz vectors;
-c          = 'P': Compute NEV Schur vectors;
-c          = 'S': compute some of the Ritz vectors, specified
-c                 by the logical array SELECT.
-c
-c  SELECT  Logical array of dimension NCV.  (INPUT)
-c          If HOWMNY = 'S', SELECT specifies the Ritz vectors to be
-c          computed. To select the  Ritz vector corresponding to a
-c          Ritz value D(j), SELECT(j) must be set to .TRUE..
-c          If HOWMNY = 'A' or 'P', SELECT need not be initialized
-c          but it is used as internal workspace.
-c
-c  D       Complex*16 array of dimension NEV+1.  (OUTPUT)
-c          On exit, D contains the  Ritz  approximations
-c          to the eigenvalues lambda for A*z = lambda*B*z.
-c
-c  Z       Complex*16 N by NEV array    (OUTPUT)
-c          On exit, if RVEC = .TRUE. and HOWMNY = 'A', then the columns of
-c          Z represents approximate eigenvectors (Ritz vectors) corresponding
-c          to the NCONV=IPARAM(5) Ritz values for eigensystem
-c          A*z = lambda*B*z.
-c
-c          If RVEC = .FALSE. or HOWMNY = 'P', then Z is NOT REFERENCED.
-c
-c          NOTE: If if RVEC = .TRUE. and a Schur basis is not required,
-c          the array Z may be set equal to first NEV+1 columns of the Arnoldi
-c          basis array V computed by ZNAUPD.  In this case the Arnoldi basis
-c          will be destroyed and overwritten with the eigenvector basis.
-c
-c  LDZ     Integer.  (INPUT)
-c          The leading dimension of the array Z.  If Ritz vectors are
-c          desired, then  LDZ .ge.  max( 1, N ) is required.
-c          In any case,  LDZ .ge. 1 is required.
-c
-c  SIGMA   Complex*16  (INPUT)
-c          If IPARAM(7) = 3 then SIGMA represents the shift.
-c          Not referenced if IPARAM(7) = 1 or 2.
-c
-c  WORKEV  Complex*16 work array of dimension 2*NCV.  (WORKSPACE)
-c
-c  **** The remaining arguments MUST be the same as for the   ****
-c  **** call to ZNAUPD that was just completed.               ****
-c
-c  NOTE: The remaining arguments
-c
-c           BMAT, N, WHICH, NEV, TOL, RESID, NCV, V, LDV, IPARAM, IPNTR,
-c           WORKD, WORKL, LWORKL, RWORK, INFO
-c
-c         must be passed directly to ZNEUPD following the last call
-c         to ZNAUPD.  These arguments MUST NOT BE MODIFIED between
-c         the the last call to ZNAUPD and the call to ZNEUPD.
-c
-c  Three of these parameters (V, WORKL and INFO) are also output parameters:
-c
-c  V       Complex*16 N by NCV array.  (INPUT/OUTPUT)
-c
-c          Upon INPUT: the NCV columns of V contain the Arnoldi basis
-c                      vectors for OP as constructed by ZNAUPD .
-c
-c          Upon OUTPUT: If RVEC = .TRUE. the first NCONV=IPARAM(5) columns
-c                       contain approximate Schur vectors that span the
-c                       desired invariant subspace.
-c
-c          NOTE: If the array Z has been set equal to first NEV+1 columns
-c          of the array V and RVEC=.TRUE. and HOWMNY= 'A', then the
-c          Arnoldi basis held by V has been overwritten by the desired
-c          Ritz vectors.  If a separate array Z has been passed then
-c          the first NCONV=IPARAM(5) columns of V will contain approximate
-c          Schur vectors that span the desired invariant subspace.
-c
-c  WORKL   Double precision work array of length LWORKL.  (OUTPUT/WORKSPACE)
-c          WORKL(1:ncv*ncv+2*ncv) contains information obtained in
-c          znaupd.  They are not changed by zneupd.
-c          WORKL(ncv*ncv+2*ncv+1:3*ncv*ncv+4*ncv) holds the
-c          untransformed Ritz values, the untransformed error estimates of
-c          the Ritz values, the upper triangular matrix for H, and the
-c          associated matrix representation of the invariant subspace for H.
-c
-c          Note: IPNTR(9:13) contains the pointer into WORKL for addresses
-c          of the above information computed by zneupd.
-c          -------------------------------------------------------------
-c          IPNTR(9):  pointer to the NCV RITZ values of the
-c                     original system.
-c          IPNTR(10): Not used
-c          IPNTR(11): pointer to the NCV corresponding error estimates.
-c          IPNTR(12): pointer to the NCV by NCV upper triangular
-c                     Schur matrix for H.
-c          IPNTR(13): pointer to the NCV by NCV matrix of eigenvectors
-c                     of the upper Hessenberg matrix H. Only referenced by
-c                     zneupd if RVEC = .TRUE. See Remark 2 below.
-c          -------------------------------------------------------------
-c
-c  INFO    Integer.  (OUTPUT)
-c          Error flag on output.
-c          =  0: Normal exit.
-c
-c          =  1: The Schur form computed by LAPACK routine csheqr
-c                could not be reordered by LAPACK routine ztrsen.
-c                Re-enter subroutine zneupd with IPARAM(5)=NCV and
-c                increase the size of the array D to have
-c                dimension at least dimension NCV and allocate at least NCV
-c                columns for Z. NOTE: Not necessary if Z and V share
-c                the same space. Please notify the authors if this error
-c                occurs.
-c
-c          = -1: N must be positive.
-c          = -2: NEV must be positive.
-c          = -3: NCV-NEV >= 1 and less than or equal to N.
-c          = -5: WHICH must be one of 'LM', 'SM', 'LR', 'SR', 'LI', 'SI'
-c          = -6: BMAT must be one of 'I' or 'G'.
-c          = -7: Length of private work WORKL array is not sufficient.
-c          = -8: Error return from LAPACK eigenvalue calculation.
-c                This should never happened.
-c          = -9: Error return from calculation of eigenvectors.
-c                Informational error from LAPACK routine ztrevc.
-c          = -10: IPARAM(7) must be 1,2,3
-c          = -11: IPARAM(7) = 1 and BMAT = 'G' are incompatible.
-c          = -12: HOWMNY = 'S' not yet implemented
-c          = -13: HOWMNY must be one of 'A' or 'P' if RVEC = .true.
-c          = -14: ZNAUPD did not find any eigenvalues to sufficient
-c                 accuracy.
-c          = -15: ZNEUPD got a different count of the number of converged
-c                 Ritz values than ZNAUPD got.  This indicates the user
-c                 probably made an error in passing data from ZNAUPD to
-c                 ZNEUPD or that the data was modified before entering
-c                 ZNEUPD
-c
-c\BeginLib
-c
-c\References:
-c  1. D.C. Sorensen, "Implicit Application of Polynomial Filters in
-c     a k-Step Arnoldi Method", SIAM J. Matr. Anal. Apps., 13 (1992),
-c     pp 357-385.
-c  2. R.B. Lehoucq, "Analysis and Implementation of an Implicitly
-c     Restarted Arnoldi Iteration", Rice University Technical Report
-c     TR95-13, Department of Computational and Applied Mathematics.
-c  3. B. Nour-Omid, B. N. Parlett, T. Ericsson and P. S. Jensen,
-c     "How to Implement the Spectral Transformation", Math Comp.,
-c     Vol. 48, No. 178, April, 1987 pp. 664-673.
-c
-c\Routines called:
-c     ivout   ARPACK utility routine that prints integers.
-c     zmout   ARPACK utility routine that prints matrices
-c     zvout   ARPACK utility routine that prints vectors.
-c     zgeqr2  LAPACK routine that computes the QR factorization of
-c             a matrix.
-c     zlacpy  LAPACK matrix copy routine.
-c     zlahqr  LAPACK routine that computes the Schur form of a
-c             upper Hessenberg matrix.
-c     zlaset  LAPACK matrix initialization routine.
-c     ztrevc  LAPACK routine to compute the eigenvectors of a matrix
-c             in upper triangular form.
-c     ztrsen  LAPACK routine that re-orders the Schur form.
-c     zunm2r  LAPACK routine that applies an orthogonal matrix in
-c             factored form.
-c     dlamch  LAPACK routine that determines machine constants.
-c     ztrmm   Level 3 BLAS matrix times an upper triangular matrix.
-c     zgeru   Level 2 BLAS rank one update to a matrix.
-c     zcopy   Level 1 BLAS that copies one vector to another .
-c     zscal   Level 1 BLAS that scales a vector.
-c     zdscal  Level 1 BLAS that scales a complex vector by a real number.
-c     dznrm2  Level 1 BLAS that computes the norm of a complex vector.
-c
-c\Remarks
-c
-c  1. Currently only HOWMNY = 'A' and 'P' are implemented.
-c
-c  2. Schur vectors are an orthogonal representation for the basis of
-c     Ritz vectors. Thus, their numerical properties are often superior.
-c     If RVEC = .true. then the relationship
-c             A * V(:,1:IPARAM(5)) = V(:,1:IPARAM(5)) * T, and
-c       transpose( V(:,1:IPARAM(5)) ) * V(:,1:IPARAM(5)) = I
-c     are approximately satisfied.
-c     Here T is the leading submatrix of order IPARAM(5) of the
-c     upper triangular matrix stored workl(ipntr(12)).
-c
-c\Authors
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Chao Yang                    Houston, Texas
-c     Dept. of Computational &
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: neupd.F   SID: 2.8   DATE OF SID: 07/21/02   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-      subroutine zneupd(rvec , howmny, select, d     ,
-     &                   z    , ldz   , sigma , workev,
-     &                   bmat , n     , which , nev   ,
-     &                   tol  , resid , ncv   , v     ,
-     &                   ldv  , iparam, ipntr , workd ,
-     &                   workl, lworkl, rwork , info  )
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character  bmat, howmny, which*2
-      logical    rvec
-      integer    info, ldz, ldv, lworkl, n, ncv, nev
-      Complex*16
-     &           sigma
-      Double precision
-     &           tol
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      integer    iparam(11), ipntr(14)
-      logical    select(ncv)
-      Double precision
-     &           rwork(ncv)
-      Complex*16
-     &           d(nev)     , resid(n)     , v(ldv,ncv),
-     &           z(ldz, nev),
-     &           workd(3*n) , workl(lworkl), workev(2*ncv)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter  (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      character  type*6
-      integer    bounds, ierr  , ih    , ihbds, iheig , nconv ,
-     &           invsub, iuptri, iwev  , j    , ldh   , ldq   ,
-     &           mode  , msglvl, ritz  , wr   , k     , irz   ,
-     &           ibd   , outncv, iq    , np   , numcnv, jj    ,
-     &           ishift, nconv2
-      Complex*16
-     &           rnorm, temp, vl(1)
-      Double precision
-     &           conds, sep, rtemp, eps23
-      logical    reord
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zcopy , zgeru, zgeqr2, zlacpy, zmout,
-     &           zunm2r, ztrmm, zvout, ivout,
-     &           zlahqr
-c
-c     %--------------------%
-c     | External Functions |
-c     %--------------------%
-c
-      Double precision
-     &           dznrm2, dlamch, dlapy2
-      external   dznrm2, dlamch, dlapy2
-c
-      Complex*16
-     &           zzdotc
-      external   zzdotc
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %------------------------%
-c     | Set default parameters |
-c     %------------------------%
-c
-      msglvl = mceupd
-      mode = iparam(7)
-      nconv = iparam(5)
-      info = 0
-c
-c
-c     %---------------------------------%
-c     | Get machine dependent constant. |
-c     %---------------------------------%
-c
-      eps23 = dlamch('Epsilon-Machine')
-      eps23 = eps23**(2.0D+0 / 3.0D+0)
-c
-c     %-------------------------------%
-c     | Quick return                  |
-c     | Check for incompatible input  |
-c     %-------------------------------%
-c
-      ierr = 0
-c
-      if (nconv .le. 0) then
-         ierr = -14
-      else if (n .le. 0) then
-         ierr = -1
-      else if (nev .le. 0) then
-         ierr = -2
-      else if (ncv .le. nev+1 .or.  ncv .gt. n) then
-         ierr = -3
-      else if (which .ne. 'LM' .and.
-     &        which .ne. 'SM' .and.
-     &        which .ne. 'LR' .and.
-     &        which .ne. 'SR' .and.
-     &        which .ne. 'LI' .and.
-     &        which .ne. 'SI') then
-         ierr = -5
-      else if (bmat .ne. 'I' .and. bmat .ne. 'G') then
-         ierr = -6
-      else if (lworkl .lt. 3*ncv**2 + 4*ncv) then
-         ierr = -7
-      else if ( (howmny .ne. 'A' .and.
-     &           howmny .ne. 'P' .and.
-     &           howmny .ne. 'S') .and. rvec ) then
-         ierr = -13
-      else if (howmny .eq. 'S' ) then
-         ierr = -12
-      end if
-c
-      if (mode .eq. 1 .or. mode .eq. 2) then
-         type = 'REGULR'
-      else if (mode .eq. 3 ) then
-         type = 'SHIFTI'
-      else
-                                              ierr = -10
-      end if
-      if (mode .eq. 1 .and. bmat .eq. 'G')    ierr = -11
-c
-c     %------------%
-c     | Error Exit |
-c     %------------%
-c
-      if (ierr .ne. 0) then
-         info = ierr
-         go to 9000
-      end if
-c
-c     %--------------------------------------------------------%
-c     | Pointer into WORKL for address of H, RITZ, WORKEV, Q   |
-c     | etc... and the remaining workspace.                    |
-c     | Also update pointer to be used on output.              |
-c     | Memory is laid out as follows:                         |
-c     | workl(1:ncv*ncv) := generated Hessenberg matrix        |
-c     | workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values            |
-c     | workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds     |
-c     %--------------------------------------------------------%
-c
-c     %-----------------------------------------------------------%
-c     | The following is used and set by ZNEUPD.                 |
-c     | workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed |
-c     |                                      Ritz values.         |
-c     | workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed |
-c     |                                      error bounds of      |
-c     |                                      the Ritz values      |
-c     | workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper |
-c     |                                      triangular matrix    |
-c     |                                      for H.               |
-c     | workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the    |
-c     |                                      associated matrix    |
-c     |                                      representation of    |
-c     |                                      the invariant        |
-c     |                                      subspace for H.      |
-c     | GRAND total of NCV * ( 3 * NCV + 4 ) locations.           |
-c     %-----------------------------------------------------------%
-c
-      ih     = ipntr(5)
-      ritz   = ipntr(6)
-      iq     = ipntr(7)
-      bounds = ipntr(8)
-      ldh    = ncv
-      ldq    = ncv
-      iheig  = bounds + ldh
-      ihbds  = iheig  + ldh
-      iuptri = ihbds  + ldh
-      invsub = iuptri + ldh*ncv
-      ipntr(9)  = iheig
-      ipntr(11) = ihbds
-      ipntr(12) = iuptri
-      ipntr(13) = invsub
-      wr = 1
-      iwev = wr + ncv
-c
-c     %-----------------------------------------%
-c     | irz points to the Ritz values computed  |
-c     |     by _neigh before exiting _naup2.    |
-c     | ibd points to the Ritz estimates        |
-c     |     computed by _neigh before exiting   |
-c     |     _naup2.                             |
-c     %-----------------------------------------%
-c
-      irz = ipntr(14) + ncv*ncv
-      ibd = irz + ncv
-c
-c     %------------------------------------%
-c     | RNORM is B-norm of the RESID(1:N). |
-c     %------------------------------------%
-c
-      rnorm = workl(ih+2)
-      workl(ih+2) = zero
-c
-      if (msglvl .gt. 2) then
-         call zvout(logfil, ncv, workl(irz), ndigit,
-     &   '_neupd: Ritz values passed in from _NAUPD.')
-         call zvout(logfil, ncv, workl(ibd), ndigit,
-     &   '_neupd: Ritz estimates passed in from _NAUPD.')
-      end if
-c
-      if (rvec) then
-c
-         reord = .false.
-c
-c        %---------------------------------------------------%
-c        | Use the temporary bounds array to store indices   |
-c        | These will be used to mark the select array later |
-c        %---------------------------------------------------%
-c
-         do 10 j = 1,ncv
-            workl(bounds+j-1) = j
-            select(j) = .false.
-   10    continue
-c
-c        %-------------------------------------%
-c        | Select the wanted Ritz values.      |
-c        | Sort the Ritz values so that the    |
-c        | wanted ones appear at the tailing   |
-c        | NEV positions of workl(irr) and     |
-c        | workl(iri).  Move the corresponding |
-c        | error estimates in workl(ibd)       |
-c        | accordingly.                        |
-c        %-------------------------------------%
-c
-         np     = ncv - nev
-         ishift = 0
-         call zngets(ishift, which     , nev          ,
-     &                np    , workl(irz), workl(bounds))
-c
-         if (msglvl .gt. 2) then
-            call zvout (logfil, ncv, workl(irz), ndigit,
-     &      '_neupd: Ritz values after calling _NGETS.')
-            call zvout (logfil, ncv, workl(bounds), ndigit,
-     &      '_neupd: Ritz value indices after calling _NGETS.')
-         end if
-c
-c        %-----------------------------------------------------%
-c        | Record indices of the converged wanted Ritz values  |
-c        | Mark the select array for possible reordering       |
-c        %-----------------------------------------------------%
-c
-         numcnv = 0
-         do 11 j = 1,ncv
-            rtemp = max(eps23,
-     &                 dlapy2 ( dble(workl(irz+ncv-j)),
-     &                          aimag(workl(irz+ncv-j)) ))
-            jj = workl(bounds + ncv - j)
-            if (numcnv .lt. nconv .and.
-     &          dlapy2( dble(workl(ibd+jj-1)),
-     &          aimag(workl(ibd+jj-1)) )
-     &          .le. tol*rtemp) then
-               select(jj) = .true.
-               numcnv = numcnv + 1
-               if (jj .gt. nconv) reord = .true.
-            endif
-   11    continue
-c
-c        %-----------------------------------------------------------%
-c        | Check the count (numcnv) of converged Ritz values with    |
-c        | the number (nconv) reported by dnaupd.  If these two      |
-c        | are different then there has probably been an error       |
-c        | caused by incorrect passing of the dnaupd data.           |
-c        %-----------------------------------------------------------%
-c
-         if (msglvl .gt. 2) then
-             call ivout(logfil, 1, [numcnv], ndigit,
-     &            '_neupd: Number of specified eigenvalues')
-             call ivout(logfil, 1, [nconv], ndigit,
-     &            '_neupd: Number of "converged" eigenvalues')
-         end if
-c
-         if (numcnv .ne. nconv) then
-            info = -15
-            go to 9000
-         end if
-c
-c        %-------------------------------------------------------%
-c        | Call LAPACK routine zlahqr to compute the Schur form |
-c        | of the upper Hessenberg matrix returned by ZNAUPD.   |
-c        | Make a copy of the upper Hessenberg matrix.           |
-c        | Initialize the Schur vector matrix Q to the identity. |
-c        %-------------------------------------------------------%
-c
-         call zcopy(ldh*ncv, workl(ih), 1, workl(iuptri), 1)
-         call zlaset('All', ncv, ncv          ,
-     &                zero , one, workl(invsub),
-     &                ldq)
-         call zlahqr(.true., .true.       , ncv          ,
-     &                1     , ncv          , workl(iuptri),
-     &                ldh   , workl(iheig) , 1            ,
-     &                ncv   , workl(invsub), ldq          ,
-     &                ierr)
-         call zcopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-         if (ierr .ne. 0) then
-            info = -8
-            go to 9000
-         end if
-c
-         if (msglvl .gt. 1) then
-            call zvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H')
-            call zvout (logfil, ncv, workl(ihbds), ndigit,
-     &           '_neupd: Last row of the Schur vector matrix')
-            if (msglvl .gt. 3) then
-               call zmout (logfil       , ncv, ncv   ,
-     &                     workl(iuptri), ldh, ndigit,
-     &              '_neupd: The upper triangular matrix ')
-            end if
-         end if
-c
-         if (reord) then
-c
-c           %-----------------------------------------------%
-c           | Reorder the computed upper triangular matrix. |
-c           %-----------------------------------------------%
-c
-            call ztrsen('None'       , 'V'          , select      ,
-     &                   ncv          , workl(iuptri), ldh         ,
-     &                   workl(invsub), ldq          , workl(iheig),
-     &                   nconv2        , conds        , sep         ,
-     &                   workev       , ncv          , ierr)
-c
-            if (nconv2 .lt. nconv) then
-               nconv = nconv2
-            end if
-
-            if (ierr .eq. 1) then
-               info = 1
-               go to 9000
-            end if
-c
-            if (msglvl .gt. 2) then
-                call zvout (logfil, ncv, workl(iheig), ndigit,
-     &           '_neupd: Eigenvalues of H--reordered')
-                if (msglvl .gt. 3) then
-                   call zmout(logfil       , ncv, ncv   ,
-     &                         workl(iuptri), ldq, ndigit,
-     &              '_neupd: Triangular matrix after re-ordering')
-                end if
-            end if
-c
-         end if
-c
-c        %---------------------------------------------%
-c        | Copy the last row of the Schur basis matrix |
-c        | to workl(ihbds).  This vector will be used  |
-c        | to compute the Ritz estimates of converged  |
-c        | Ritz values.                                |
-c        %---------------------------------------------%
-c
-         call zcopy(ncv         , workl(invsub+ncv-1), ldq,
-     &               workl(ihbds), 1)
-c
-c        %--------------------------------------------%
-c        | Place the computed eigenvalues of H into D |
-c        | if a spectral transformation was not used. |
-c        %--------------------------------------------%
-c
-         if (type .eq. 'REGULR') then
-            call zcopy(nconv, workl(iheig), 1, d, 1)
-         end if
-c
-c        %----------------------------------------------------------%
-c        | Compute the QR factorization of the matrix representing  |
-c        | the wanted invariant subspace located in the first NCONV |
-c        | columns of workl(invsub,ldq).                            |
-c        %----------------------------------------------------------%
-c
-         call zgeqr2(ncv , nconv , workl(invsub),
-     &                ldq , workev, workev(ncv+1),
-     &                ierr)
-c
-c        %--------------------------------------------------------%
-c        | * Postmultiply V by Q using zunm2r.                    |
-c        | * Copy the first NCONV columns of VQ into Z.           |
-c        | * Postmultiply Z by R.                                 |
-c        | The N by NCONV matrix Z is now a matrix representation |
-c        | of the approximate invariant subspace associated with  |
-c        | the Ritz values in workl(iheig). The first NCONV       |
-c        | columns of V are now approximate Schur vectors         |
-c        | associated with the upper triangular matrix of order   |
-c        | NCONV in workl(iuptri).                                |
-c        %--------------------------------------------------------%
-c
-         call zunm2r('Right', 'Notranspose', n            ,
-     &                ncv    , nconv        , workl(invsub),
-     &                ldq    , workev       , v            ,
-     &                ldv    , workd(n+1)   , ierr)
-         call zlacpy('All', n, nconv, v, ldv, z, ldz)
-c
-         do 20 j=1, nconv
-c
-c           %---------------------------------------------------%
-c           | Perform both a column and row scaling if the      |
-c           | diagonal element of workl(invsub,ldq) is negative |
-c           | I'm lazy and don't take advantage of the upper    |
-c           | triangular form of workl(iuptri,ldq).             |
-c           | Note that since Q is orthogonal, R is a diagonal  |
-c           | matrix consisting of plus or minus ones.          |
-c           %---------------------------------------------------%
-c
-            if ( dble( workl(invsub+(j-1)*ldq+j-1) ) .lt.
-     &                  dble(zero) ) then
-               call zscal(nconv, -one, workl(iuptri+j-1), ldq)
-               call zscal(nconv, -one, workl(iuptri+(j-1)*ldq), 1)
-            end if
-c
- 20      continue
-c
-         if (howmny .eq. 'A') then
-c
-c           %--------------------------------------------%
-c           | Compute the NCONV wanted eigenvectors of T |
-c           | located in workl(iuptri,ldq).              |
-c           %--------------------------------------------%
-c
-            do 30 j=1, ncv
-               if (j .le. nconv) then
-                  select(j) = .true.
-               else
-                  select(j) = .false.
-               end if
- 30         continue
-c
-            call ztrevc('Right', 'Select'     , select       ,
-     &                   ncv    , workl(iuptri), ldq          ,
-     &                   vl     , 1            , workl(invsub),
-     &                   ldq    , ncv          , outncv       ,
-     &                   workev , rwork        , ierr)
-c
-            if (ierr .ne. 0) then
-                info = -9
-                go to 9000
-            end if
-c
-c           %------------------------------------------------%
-c           | Scale the returning eigenvectors so that their |
-c           | Euclidean norms are all one. LAPACK subroutine |
-c           | ztrevc returns each eigenvector normalized so  |
-c           | that the element of largest magnitude has      |
-c           | magnitude 1.                                   |
-c           %------------------------------------------------%
-c
-            do 40 j=1, nconv
-                  rtemp = dznrm2(ncv, workl(invsub+(j-1)*ldq), 1)
-                  rtemp = dble(one) / rtemp
-                  call zdscal ( ncv, rtemp,
-     &                 workl(invsub+(j-1)*ldq), 1 )
-c
-c                 %------------------------------------------%
-c                 | Ritz estimates can be obtained by taking |
-c                 | the inner product of the last row of the |
-c                 | Schur basis of H with eigenvectors of T. |
-c                 | Note that the eigenvector matrix of T is |
-c                 | upper triangular, thus the length of the |
-c                 | inner product can be set to j.           |
-c                 %------------------------------------------%
-c
-                  workev(j) = zzdotc(j, workl(ihbds), 1,
-     &                        workl(invsub+(j-1)*ldq), 1)
- 40         continue
-c
-            if (msglvl .gt. 2) then
-               call zcopy(nconv, workl(invsub+ncv-1), ldq,
-     &                    workl(ihbds), 1)
-               call zvout (logfil, nconv, workl(ihbds), ndigit,
-     &            '_neupd: Last row of the eigenvector matrix for T')
-               if (msglvl .gt. 3) then
-                  call zmout(logfil       , ncv, ncv   ,
-     &                        workl(invsub), ldq, ndigit,
-     &               '_neupd: The eigenvector matrix for T')
-               end if
-            end if
-c
-c           %---------------------------------------%
-c           | Copy Ritz estimates into workl(ihbds) |
-c           %---------------------------------------%
-c
-            call zcopy(nconv, workev, 1, workl(ihbds), 1)
-c
-c           %----------------------------------------------%
-c           | The eigenvector matrix Q of T is triangular. |
-c           | Form Z*Q.                                    |
-c           %----------------------------------------------%
-c
-            call ztrmm('Right'   , 'Upper'      , 'No transpose',
-     &                  'Non-unit', n            , nconv         ,
-     &                  one       , workl(invsub), ldq           ,
-     &                  z         , ldz)
-         end if
-c
-      else
-c
-c        %--------------------------------------------------%
-c        | An approximate invariant subspace is not needed. |
-c        | Place the Ritz values computed ZNAUPD into D.    |
-c        %--------------------------------------------------%
-c
-         call zcopy(nconv, workl(ritz), 1, d, 1)
-         call zcopy(nconv, workl(ritz), 1, workl(iheig), 1)
-         call zcopy(nconv, workl(bounds), 1, workl(ihbds), 1)
-c
-      end if
-c
-c     %------------------------------------------------%
-c     | Transform the Ritz values and possibly vectors |
-c     | and corresponding error bounds of OP to those  |
-c     | of A*x = lambda*B*x.                           |
-c     %------------------------------------------------%
-c
-      if (type .eq. 'REGULR') then
-c
-         if (rvec)
-     &      call zscal(ncv, rnorm, workl(ihbds), 1)
-c
-      else
-c
-c        %---------------------------------------%
-c        |   A spectral transformation was used. |
-c        | * Determine the Ritz estimates of the |
-c        |   Ritz values in the original system. |
-c        %---------------------------------------%
-c
-         if (rvec)
-     &      call zscal(ncv, rnorm, workl(ihbds), 1)
-c
-         do 50 k=1, ncv
-            temp = workl(iheig+k-1)
-            workl(ihbds+k-1) = workl(ihbds+k-1) / temp / temp
-  50     continue
-c
-      end if
-c
-c     %-----------------------------------------------------------%
-c     | *  Transform the Ritz values back to the original system. |
-c     |    For TYPE = 'SHIFTI' the transformation is              |
-c     |             lambda = 1/theta + sigma                      |
-c     | NOTES:                                                    |
-c     | *The Ritz vectors are not affected by the transformation. |
-c     %-----------------------------------------------------------%
-c
-      if (type .eq. 'SHIFTI') then
-         do 60 k=1, nconv
-            d(k) = one / workl(iheig+k-1) + sigma
-  60     continue
-      end if
-c
-      if (type .ne. 'REGULR' .and. msglvl .gt. 1) then
-         call zvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Untransformed Ritz values.')
-         call zvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Ritz estimates of the untransformed Ritz values.')
-      else if ( msglvl .gt. 1) then
-         call zvout (logfil, nconv, d, ndigit,
-     &     '_neupd: Converged Ritz values.')
-         call zvout (logfil, nconv, workl(ihbds), ndigit,
-     &     '_neupd: Associated Ritz estimates.')
-      end if
-c
-c     %-------------------------------------------------%
-c     | Eigenvector Purification step. Formally perform |
-c     | one of inverse subspace iteration. Only used    |
-c     | for MODE = 3. See reference 3.                  |
-c     %-------------------------------------------------%
-c
-      if (rvec .and. howmny .eq. 'A' .and. type .eq. 'SHIFTI') then
-c
-c        %------------------------------------------------%
-c        | Purify the computed Ritz vectors by adding a   |
-c        | little bit of the residual vector:             |
-c        |                      T                         |
-c        |          resid(:)*( e    s ) / theta           |
-c        |                      NCV                       |
-c        | where H s = s theta.                           |
-c        %------------------------------------------------%
-c
-         do 100 j=1, nconv
-            if (workl(iheig+j-1) .ne. zero) then
-               workev(j) =  workl(invsub+(j-1)*ldq+ncv-1) /
-     &                      workl(iheig+j-1)
-            endif
- 100     continue
-
-c        %---------------------------------------%
-c        | Perform a rank one update to Z and    |
-c        | purify all the Ritz vectors together. |
-c        %---------------------------------------%
-c
-         call zgeru (n, nconv, one, resid, 1, workev, 1, z, ldz)
-c
-      end if
-c
- 9000 continue
-c
-      return
-c
-c     %---------------%
-c     | End of zneupd|
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zngets.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zngets.f
deleted file mode 100644
index e7d2433492..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zngets.f
+++ /dev/null
@@ -1,178 +0,0 @@
-c\BeginDoc
-c
-c\Name: zngets
-c
-c\Description:
-c  Given the eigenvalues of the upper Hessenberg matrix H,
-c  computes the NP shifts AMU that are zeros of the polynomial of
-c  degree NP which filters out components of the unwanted eigenvectors
-c  corresponding to the AMU's based on some given criteria.
-c
-c  NOTE: call this even in the case of user specified shifts in order
-c  to sort the eigenvalues, and error bounds of H for later use.
-c
-c\Usage:
-c  call zngets
-c      ( ISHIFT, WHICH, KEV, NP, RITZ, BOUNDS )
-c
-c\Arguments
-c  ISHIFT  Integer.  (INPUT)
-c          Method for selecting the implicit shifts at each iteration.
-c          ISHIFT = 0: user specified shifts
-c          ISHIFT = 1: exact shift with respect to the matrix H.
-c
-c  WHICH   Character*2.  (INPUT)
-c          Shift selection criteria.
-c          'LM' -> want the KEV eigenvalues of largest magnitude.
-c          'SM' -> want the KEV eigenvalues of smallest magnitude.
-c          'LR' -> want the KEV eigenvalues of largest REAL part.
-c          'SR' -> want the KEV eigenvalues of smallest REAL part.
-c          'LI' -> want the KEV eigenvalues of largest imaginary part.
-c          'SI' -> want the KEV eigenvalues of smallest imaginary part.
-c
-c  KEV     Integer.  (INPUT)
-c          The number of desired eigenvalues.
-c
-c  NP      Integer.  (INPUT)
-c          The number of shifts to compute.
-c
-c  RITZ    Complex*16 array of length KEV+NP.  (INPUT/OUTPUT)
-c          On INPUT, RITZ contains the the eigenvalues of H.
-c          On OUTPUT, RITZ are sorted so that the unwanted
-c          eigenvalues are in the first NP locations and the wanted
-c          portion is in the last KEV locations.  When exact shifts are
-c          selected, the unwanted part corresponds to the shifts to
-c          be applied. Also, if ISHIFT .eq. 1, the unwanted eigenvalues
-c          are further sorted so that the ones with largest Ritz values
-c          are first.
-c
-c  BOUNDS  Complex*16 array of length KEV+NP.  (INPUT/OUTPUT)
-c          Error bounds corresponding to the ordering in RITZ.
-c
-c
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Local variables:
-c     xxxxxx  Complex*16
-c
-c\Routines called:
-c     zsortc  ARPACK sorting routine.
-c     ivout   ARPACK utility routine that prints integers.
-c     arscnd  ARPACK utility routine for timing.
-c     zvout   ARPACK utility routine that prints vectors.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c\SCCS Information: @(#)
-c FILE: ngets.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\Remarks
-c     1. This routine does not keep complex conjugate pairs of
-c        eigenvalues together.
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zngets ( ishift, which, kev, np, ritz, bounds)
-c
-c     %----------------------------------------------------%
-c     | Include files for debugging and timing information |
-c     %----------------------------------------------------%
-c
-      include   'debug.h'
-      include   'stat.h'
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      integer    ishift, kev, np
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           bounds(kev+np), ritz(kev+np)
-c
-c     %------------%
-c     | Parameters |
-c     %------------%
-c
-      Complex*16
-     &           one, zero
-      parameter (one = (1.0D+0, 0.0D+0), zero = (0.0D+0, 0.0D+0))
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    msglvl
-c
-c     %----------------------%
-c     | External Subroutines |
-c     %----------------------%
-c
-      external   zvout,  zsortc, arscnd
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-c     %-------------------------------%
-c     | Initialize timing statistics  |
-c     | & message level for debugging |
-c     %-------------------------------%
-c
-      call arscnd (t0)
-      msglvl = mcgets
-c
-      call zsortc (which, .true., kev+np, ritz, bounds)
-c
-      if ( ishift .eq. 1 ) then
-c
-c        %-------------------------------------------------------%
-c        | Sort the unwanted Ritz values used as shifts so that  |
-c        | the ones with largest Ritz estimates are first        |
-c        | This will tend to minimize the effects of the         |
-c        | forward instability of the iteration when the shifts  |
-c        | are applied in subroutine znapps.                     |
-c        | Be careful and use 'SM' since we want to sort BOUNDS! |
-c        %-------------------------------------------------------%
-c
-         call zsortc ( 'SM', .true., np, bounds, ritz )
-c
-      end if
-c
-      call arscnd (t1)
-      tcgets = tcgets + (t1 - t0)
-c
-      if (msglvl .gt. 0) then
-         call ivout (logfil, 1, [kev], ndigit, '_ngets: KEV is')
-         call ivout (logfil, 1, [np], ndigit, '_ngets: NP is')
-         call zvout (logfil, kev+np, ritz, ndigit,
-     &        '_ngets: Eigenvalues of current H matrix ')
-         call zvout (logfil, kev+np, bounds, ndigit,
-     &      '_ngets: Ritz estimates of the current KEV+NP Ritz values')
-      end if
-c
-      return
-c
-c     %---------------%
-c     | End of zngets |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zsortc.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zsortc.f
deleted file mode 100644
index 6ea37a42f7..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zsortc.f
+++ /dev/null
@@ -1,322 +0,0 @@
-c\BeginDoc
-c
-c\Name: zsortc
-c
-c\Description:
-c  Sorts the Complex*16 array in X into the order
-c  specified by WHICH and optionally applies the permutation to the
-c  Double precision  array Y.
-c
-c\Usage:
-c  call zsortc
-c     ( WHICH, APPLY, N, X, Y )
-c
-c\Arguments
-c  WHICH   Character*2.  (Input)
-c          'LM' -> sort X into increasing order of magnitude.
-c          'SM' -> sort X into decreasing order of magnitude.
-c          'LR' -> sort X with real(X) in increasing algebraic order
-c          'SR' -> sort X with real(X) in decreasing algebraic order
-c          'LI' -> sort X with imag(X) in increasing algebraic order
-c          'SI' -> sort X with imag(X) in decreasing algebraic order
-c
-c  APPLY   Logical.  (Input)
-c          APPLY = .TRUE.  -> apply the sorted order to array Y.
-c          APPLY = .FALSE. -> do not apply the sorted order to array Y.
-c
-c  N       Integer.  (INPUT)
-c          Size of the arrays.
-c
-c  X       Complex*16 array of length N.  (INPUT/OUTPUT)
-c          This is the array to be sorted.
-c
-c  Y       Complex*16 array of length N.  (INPUT/OUTPUT)
-c
-c\EndDoc
-c
-c-----------------------------------------------------------------------
-c
-c\BeginLib
-c
-c\Routines called:
-c     dlapy2  LAPACK routine to compute sqrt(x**2+y**2) carefully.
-c
-c\Author
-c     Danny Sorensen               Phuong Vu
-c     Richard Lehoucq              CRPC / Rice University
-c     Dept. of Computational &     Houston, Texas
-c     Applied Mathematics
-c     Rice University
-c     Houston, Texas
-c
-c     Adapted from the sort routine in LANSO.
-c
-c\SCCS Information: @(#)
-c FILE: sortc.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c\EndLib
-c
-c-----------------------------------------------------------------------
-c
-      subroutine zsortc (which, apply, n, x, y)
-c
-c     %------------------%
-c     | Scalar Arguments |
-c     %------------------%
-c
-      character*2 which
-      logical    apply
-      integer    n
-c
-c     %-----------------%
-c     | Array Arguments |
-c     %-----------------%
-c
-      Complex*16
-     &           x(0:n-1), y(0:n-1)
-c
-c     %---------------%
-c     | Local Scalars |
-c     %---------------%
-c
-      integer    i, igap, j
-      Complex*16
-     &           temp
-      Double precision
-     &           temp1, temp2
-c
-c     %--------------------%
-c     | External functions |
-c     %--------------------%
-c
-      Double precision
-     &           dlapy2
-c
-c     %--------------------%
-c     | Intrinsic Functions |
-c     %--------------------%
-       Intrinsic
-     &           dble, aimag
-c
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-c
-      igap = n / 2
-c
-      if (which .eq. 'LM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into increasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   10    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 30 i = igap, n-1
-            j = i-igap
-   20       continue
-c
-            if (j.lt.0) go to 30
-c
-            temp1 = dlapy2(dble(x(j)),aimag(x(j)))
-            temp2 = dlapy2(dble(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.gt.temp2) then
-                temp = x(j)
-                x(j) = x(j+igap)
-                x(j+igap) = temp
-c
-                if (apply) then
-                    temp = y(j)
-                    y(j) = y(j+igap)
-                    y(j+igap) = temp
-                end if
-            else
-                go to 30
-            end if
-            j = j-igap
-            go to 20
-   30    continue
-         igap = igap / 2
-         go to 10
-c
-      else if (which .eq. 'SM') then
-c
-c        %--------------------------------------------%
-c        | Sort X into decreasing order of magnitude. |
-c        %--------------------------------------------%
-c
-   40    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 60 i = igap, n-1
-            j = i-igap
-   50       continue
-c
-            if (j .lt. 0) go to 60
-c
-            temp1 = dlapy2(dble(x(j)),aimag(x(j)))
-            temp2 = dlapy2(dble(x(j+igap)),aimag(x(j+igap)))
-c
-            if (temp1.lt.temp2) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 60
-            endif
-            j = j-igap
-            go to 50
-   60    continue
-         igap = igap / 2
-         go to 40
-c
-      else if (which .eq. 'LR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into increasing order of algebraic. |
-c        %------------------------------------------------%
-c
-   70    continue
-         if (igap .eq. 0) go to 9000
-c
-         do 90 i = igap, n-1
-            j = i-igap
-   80       continue
-c
-            if (j.lt.0) go to 90
-c
-            if (dble(x(j)).gt.dble(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 90
-            endif
-            j = j-igap
-            go to 80
-   90    continue
-         igap = igap / 2
-         go to 70
-c
-      else if (which .eq. 'SR') then
-c
-c        %------------------------------------------------%
-c        | Sort XREAL into decreasing order of algebraic. |
-c        %------------------------------------------------%
-c
-  100    continue
-         if (igap .eq. 0) go to 9000
-         do 120 i = igap, n-1
-            j = i-igap
-  110       continue
-c
-            if (j.lt.0) go to 120
-c
-            if (dble(x(j)).lt.dble(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 120
-            endif
-            j = j-igap
-            go to 110
-  120    continue
-         igap = igap / 2
-         go to 100
-c
-      else if (which .eq. 'LI') then
-c
-c        %--------------------------------------------%
-c        | Sort XIMAG into increasing algebraic order |
-c        %--------------------------------------------%
-c
-  130    continue
-         if (igap .eq. 0) go to 9000
-         do 150 i = igap, n-1
-            j = i-igap
-  140       continue
-c
-            if (j.lt.0) go to 150
-c
-            if (aimag(x(j)).gt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 150
-            endif
-            j = j-igap
-            go to 140
-  150    continue
-         igap = igap / 2
-         go to 130
-c
-      else if (which .eq. 'SI') then
-c
-c        %---------------------------------------------%
-c        | Sort XIMAG into decreasing algebraic order  |
-c        %---------------------------------------------%
-c
-  160    continue
-         if (igap .eq. 0) go to 9000
-         do 180 i = igap, n-1
-            j = i-igap
-  170       continue
-c
-            if (j.lt.0) go to 180
-c
-            if (aimag(x(j)).lt.aimag(x(j+igap))) then
-               temp = x(j)
-               x(j) = x(j+igap)
-               x(j+igap) = temp
-c
-               if (apply) then
-                  temp = y(j)
-                  y(j) = y(j+igap)
-                  y(j+igap) = temp
-               end if
-            else
-               go to 180
-            endif
-            j = j-igap
-            go to 170
-  180    continue
-         igap = igap / 2
-         go to 160
-      end if
-c
- 9000 continue
-      return
-c
-c     %---------------%
-c     | End of zsortc |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zstatn.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zstatn.f
deleted file mode 100644
index ddc5240f3f..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zstatn.f
+++ /dev/null
@@ -1,51 +0,0 @@
-c
-c\SCCS Information: @(#)
-c FILE: statn.F   SID: 2.2   DATE OF SID: 4/20/96   RELEASE: 2
-c
-c     %---------------------------------------------%
-c     | Initialize statistic and timing information |
-c     | for complex nonsymmetric Arnoldi code.      |
-c     %---------------------------------------------%
-
-      subroutine zstatn
-c
-c     %--------------------------------%
-c     | See stat.doc for documentation |
-c     %--------------------------------%
-c
-      include   'stat.h'
-
-c     %-----------------------%
-c     | Executable Statements |
-c     %-----------------------%
-
-      nopx   = 0
-      nbx    = 0
-      nrorth = 0
-      nitref = 0
-      nrstrt = 0
-
-      tcaupd = 0.0D+0
-      tcaup2 = 0.0D+0
-      tcaitr = 0.0D+0
-      tceigh = 0.0D+0
-      tcgets = 0.0D+0
-      tcapps = 0.0D+0
-      tcconv = 0.0D+0
-      titref = 0.0D+0
-      tgetv0 = 0.0D+0
-      trvec  = 0.0D+0
-
-c     %----------------------------------------------------%
-c     | User time including reverse communication overhead |
-c     %----------------------------------------------------%
-      tmvopx = 0.0D+0
-      tmvbx  = 0.0D+0
-
-      return
-c
-c     %---------------%
-c     | End of zstatn |
-c     %---------------%
-c
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zzdotc.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zzdotc.f
deleted file mode 100644
index a98c34230c..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/SRC/zzdotc.f
+++ /dev/null
@@ -1,36 +0,0 @@
-      double complex function zzdotc(n,zx,incx,zy,incy)
-c
-c     forms the dot product of a vector.
-c     jack dongarra, 3/11/78.
-c     modified 12/3/93, array(1) declarations changed to array(*)
-c
-      double complex zx(*),zy(*),ztemp
-      integer i,incx,incy,ix,iy,n
-      ztemp = (0.0d0,0.0d0)
-      zzdotc = (0.0d0,0.0d0)
-      if(n.le.0)return
-      if(incx.eq.1.and.incy.eq.1)go to 20
-c
-c        code for unequal increments or equal increments
-c          not equal to 1
-c
-      ix = 1
-      iy = 1
-      if(incx.lt.0)ix = (-n+1)*incx + 1
-      if(incy.lt.0)iy = (-n+1)*incy + 1
-      do 10 i = 1,n
-        ztemp = ztemp + conjg(zx(ix))*zy(iy)
-        ix = ix + incx
-        iy = iy + incy
-   10 continue
-      zzdotc = ztemp
-      return
-c
-c        code for both increments equal to 1
-c
-   20 do 30 i = 1,n
-        ztemp = ztemp + conjg(zx(i))*zy(i)
-   30 continue
-      zzdotc = ztemp
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cmout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cmout.f
deleted file mode 100644
index ff04783099..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cmout.f
+++ /dev/null
@@ -1,250 +0,0 @@
-*
-*  Routine:    CMOUT
-*
-*  Purpose:    Complex matrix output routine.
-*
-*  Usage:      CALL CMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Complex M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*\SCCS Information: @(#)
-* FILE: cmout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE CMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      Complex
-     &                   A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9984 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9983 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 80 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9982 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N
-               WRITE( LOUT, 9995 ) ICOL, K1
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, A( I, K1 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  IF ((K1+3).LE.N) THEN
-                     WRITE( LOUT, 9974 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.1) THEN
-                     WRITE( LOUT, 9964 )I, ( A( I, J ), J = k1, K2 )
-                  ELSE IF ((K1+3-N).EQ.2) THEN
-                     WRITE( LOUT, 9954 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.3) THEN
-                     WRITE( LOUT, 9944 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 3
-               K2 = MIN0( N, K1+ 2)
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9973 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9963 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9953 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 160 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-                  WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9972 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9962 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9952 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  IF ((K1+1).LE.N) THEN
-                     WRITE( LOUT, 9971 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9961 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 11X, 4( 9X, 3A1, I4, 9X ) )
- 9997 FORMAT( 10X, 4( 11X, 3A1, I4, 11X ) )
- 9996 FORMAT( 10X, 3( 13X, 3A1, I4, 13X ) )
- 9995 FORMAT( 12X, 2( 18x, 3A1, I4, 18X ) )
-*
-*========================================================
-*              FORMAT FOR 72 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E10.3,',',E10.3,')  ') )
- 9984 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E12.5,',',E12.5,')  ') )
- 9983 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E14.7,',',E14.7,')  ') )
- 9982 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E20.13,',',E20.13,')') )
- 9990 FORMAT( 1X, ' ' )
-*
-*
-*========================================================
-*              FORMAT FOR 132 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGIT
-*
- 9974 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,4('(',E10.3,',',E10.3,')  ') )
- 9964 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E10.3,',',E10.3,')  ') )
- 9954 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E10.3,',',E10.3,')  ') )
- 9944 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGIT
-*
- 9973 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E12.5,',',E12.5,')  ') )
- 9963 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E12.5,',',E12.5,')  ') )
- 9953 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGIT
-*
- 9972 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',E14.7,',',E14.7,')  ') )
- 9962 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E14.7,',',E14.7,')  ') )
- 9952 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGIT
-*
- 9971 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',E20.13,',',E20.13,
-     &        ')  '))
- 9961 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',E20.13,',',E20.13,
-     &        ')  '))
-
-*
-*
-*
-*
-      RETURN
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cvout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cvout.f
deleted file mode 100644
index 1ee9afabf7..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/cvout.f
+++ /dev/null
@@ -1,240 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c\SCCS Information: @(#)
-c FILE: cvout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-c
-*-----------------------------------------------------------------------
-*  Routine:    CVOUT
-*
-*  Purpose:    Complex vector output routine.
-*
-*  Usage:      CALL CVOUT (LOUT, N, CX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array CX.  (Input)
-*     CX     - Complex array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array CX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE CVOUT( LOUT, N, CX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      Complex
-     &                   CX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9998 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9997 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9988 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9987 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 50 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9978 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9977 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N
-               WRITE( LOUT, 9968 )K1, K1, CX( I )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               IF ((K1+3).LE.N) THEN
-                  WRITE( LOUT, 9958 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9957 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9956 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9955 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9948 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9947 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9946 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 90 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9938 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9937 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9936 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9928 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9927 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
-*
-*=======================================================================
-*                   FORMAT FOR 72 COLUMNS
-*=======================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E10.3,',',E10.3,')  ') )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9988 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E12.5,',',E12.5,')  ') )
- 9987 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9978 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E14.7,',',E14.7,')  ') )
- 9977 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9968 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E20.13,',',E20.13,')  ') )
-*
-*=========================================================================
-*                   FORMAT FOR 132 COLUMNS
-*=========================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9958 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,4('(',E10.3,',',E10.3,')  ') )
- 9957 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E10.3,',',E10.3,')  ') )
- 9956 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E10.3,',',E10.3,')  ') )
- 9955 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E10.3,',',E10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9948 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E12.5,',',E12.5,')  ') )
- 9947 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E12.5,',',E12.5,')  ') )
- 9946 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E12.5,',',E12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9938 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',E14.7,',',E14.7,')  ') )
- 9937 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E14.7,',',E14.7,')  ') )
- 9936 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E14.7,',',E14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9928 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',E20.13,',',E20.13,')  ') )
- 9927 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',E20.13,',',E20.13,')  ') )
-*
-*
-*
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dmout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dmout.f
deleted file mode 100644
index 72edc042fa..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dmout.f
+++ /dev/null
@@ -1,167 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    DMOUT
-*
-*  Purpose:    Real matrix output routine.
-*
-*  Usage:      CALL DMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Real M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE DMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-*     .. Scalar Arguments ..
-      CHARACTER*( * )    IFMT
-      INTEGER            IDIGIT, LDA, LOUT, M, N
-*     ..
-*     .. Array Arguments ..
-      DOUBLE PRECISION   A( LDA, * )
-*     ..
-*     .. Local Scalars ..
-      CHARACTER*80       LINE
-      INTEGER            I, J, K1, K2, LLL, NDIGIT
-*     ..
-*     .. Local Arrays ..
-      CHARACTER          ICOL( 3 )
-*     ..
-*     .. Intrinsic Functions ..
-      INTRINSIC          LEN, MIN, MIN0
-*     ..
-*     .. Data statements ..
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ..
-*     .. Executable Statements ..
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, FMT = 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A, / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  WRITE( LOUT, FMT = 9994 )I, ( A( I, J ), J = K1, K2 )
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, FMT = 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  WRITE( LOUT, FMT = 9993 )I, ( A( I, J ), J = K1, K2 )
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, FMT = 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  WRITE( LOUT, FMT = 9992 )I, ( A( I, J ), J = K1, K2 )
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, FMT = 9995 )( ICOL, I, I = K1, K2 )
-               DO 90 I = 1, M
-                  WRITE( LOUT, FMT = 9991 )I, ( A( I, J ), J = K1, K2 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, FMT = 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  WRITE( LOUT, FMT = 9994 )I, ( A( I, J ), J = K1, K2 )
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, FMT = 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  WRITE( LOUT, FMT = 9993 )I, ( A( I, J ), J = K1, K2 )
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 160 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, FMT = 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  WRITE( LOUT, FMT = 9992 )I, ( A( I, J ), J = K1, K2 )
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  WRITE( LOUT, FMT = 9991 )I, ( A( I, J ), J = K1, K2 )
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, FMT = 9990 )
-*
- 9998 FORMAT( 10X, 10( 4X, 3A1, I4, 1X ) )
- 9997 FORMAT( 10X, 8( 5X, 3A1, I4, 2X ) )
- 9996 FORMAT( 10X, 6( 7X, 3A1, I4, 4X ) )
- 9995 FORMAT( 10X, 5( 9X, 3A1, I4, 6X ) )
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 10D12.3 )
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 8D14.5 )
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 6D18.9 )
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P, 5D22.13 )
- 9990 FORMAT( 1X, ' ' )
-*
-      RETURN
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dvout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dvout.f
deleted file mode 100644
index 4138e52c6f..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/dvout.f
+++ /dev/null
@@ -1,122 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    DVOUT
-*
-*  Purpose:    Real vector output routine.
-*
-*  Usage:      CALL DVOUT (LOUT, N, SX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array SX.  (Input)
-*     SX     - Real array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array SX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE DVOUT( LOUT, N, SX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-*     .. Scalar Arguments ..
-      CHARACTER*( * )    IFMT
-      INTEGER            IDIGIT, LOUT, N
-*     ..
-*     .. Array Arguments ..
-      DOUBLE PRECISION   SX( * )
-*     ..
-*     .. Local Scalars ..
-      CHARACTER*80       LINE
-      INTEGER            I, K1, K2, LLL, NDIGIT
-*     ..
-*     .. Intrinsic Functions ..
-      INTRINSIC          LEN, MIN, MIN0
-*     ..
-*     .. Executable Statements ..
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, FMT = 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A, / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, FMT = 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 50 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, FMT = 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, FMT = 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, FMT = 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, FMT = 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 90 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, FMT = 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, FMT = 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, FMT = 9994 )
-      RETURN
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1P, 10D12.3 )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 8D14.5 )
- 9996 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 6D18.9 )
- 9995 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P, 5D24.13 )
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icnteq.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icnteq.f
deleted file mode 100644
index dc345f9bad..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icnteq.f
+++ /dev/null
@@ -1,18 +0,0 @@
-c
-c-----------------------------------------------------------------------
-c
-c     Count the number of elements equal to a specified integer value.
-c
-      integer function icnteq (n, array, value)
-c
-      integer    n, value
-      integer    array(*)
-c
-      k = 0
-      do 10 i = 1, n
-         if (array(i) .eq. value) k = k + 1
-   10 continue
-      icnteq = k
-c
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icopy.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icopy.f
deleted file mode 100644
index f9e8c11003..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/icopy.f
+++ /dev/null
@@ -1,77 +0,0 @@
-*--------------------------------------------------------------------
-*\Documentation
-*
-*\Name: ICOPY
-*
-*\Description:
-*     ICOPY copies an integer vector lx to an integer vector ly.
-*
-*\Usage:
-*     call icopy ( n, lx, inc, ly, incy )
-*
-*\Arguments:
-*    n        integer (input)
-*             On entry, n is the number of elements of lx to be
-c             copied to ly.
-*
-*    lx       integer array (input)
-*             On entry, lx is the integer vector to be copied.
-*
-*    incx     integer (input)
-*             On entry, incx is the increment between elements of lx.
-*
-*    ly       integer array (input)
-*             On exit, ly is the integer vector that contains the
-*             copy of lx.
-*
-*    incy     integer (input)
-*             On entry, incy is the increment between elements of ly.
-*
-*\Enddoc
-*
-*--------------------------------------------------------------------
-*
-      subroutine icopy( n, lx, incx, ly, incy )
-*
-*     ----------------------------
-*     Specifications for arguments
-*     ----------------------------
-      integer    incx, incy, n
-      integer    lx( 1 ), ly( 1 )
-*
-*     ----------------------------------
-*     Specifications for local variables
-*     ----------------------------------
-      integer           i, ix, iy
-*
-*     --------------------------
-*     First executable statement
-*     --------------------------
-      if( n.le.0 )
-     $   return
-      if( incx.eq.1 .and. incy.eq.1 )
-     $   go to 20
-c
-c.....code for unequal increments or equal increments
-c     not equal to 1
-      ix = 1
-      iy = 1
-      if( incx.lt.0 )
-     $   ix = ( -n+1 )*incx + 1
-      if( incy.lt.0 )
-     $   iy = ( -n+1 )*incy + 1
-      do 10 i = 1, n
-         ly( iy ) = lx( ix )
-         ix = ix + incx
-         iy = iy + incy
-   10 continue
-      return
-c
-c.....code for both increments equal to 1
-c
-   20 continue
-      do 30 i = 1, n
-         ly( i ) = lx( i )
-   30 continue
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iset.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iset.f
deleted file mode 100644
index cb690bc3e9..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iset.f
+++ /dev/null
@@ -1,16 +0,0 @@
-c
-c-----------------------------------------------------------------------
-c
-c     Only work with increment equal to 1 right now.
-c
-      subroutine iset (n, value, array, inc)
-c
-      integer    n, value, inc
-      integer    array(*)
-c
-      do 10 i = 1, n
-         array(i) = value
-   10 continue
-c
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iswap.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iswap.f
deleted file mode 100644
index 088798d007..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/iswap.f
+++ /dev/null
@@ -1,55 +0,0 @@
-      subroutine iswap (n,sx,incx,sy,incy)
-c
-c     interchanges two vectors.
-c     uses unrolled loops for increments equal to 1.
-c     jack dongarra, linpack, 3/11/78.
-c
-      integer sx(1),sy(1),stemp
-      integer i,incx,incy,ix,iy,m,mp1,n
-c
-      if(n.le.0)return
-      if(incx.eq.1.and.incy.eq.1)go to 20
-c
-c       code for unequal increments or equal increments not equal
-c         to 1
-c
-      ix = 1
-      iy = 1
-      if(incx.lt.0)ix = (-n+1)*incx + 1
-      if(incy.lt.0)iy = (-n+1)*incy + 1
-      do 10 i = 1,n
-        stemp = sx(ix)
-        sx(ix) = sy(iy)
-        sy(iy) = stemp
-        ix = ix + incx
-        iy = iy + incy
-   10 continue
-      return
-c
-c       code for both increments equal to 1
-c
-c
-c       clean-up loop
-c
-   20 m = mod(n,3)
-      if( m .eq. 0 ) go to 40
-      do 30 i = 1,m
-        stemp = sx(i)
-        sx(i) = sy(i)
-        sy(i) = stemp
-   30 continue
-      if( n .lt. 3 ) return
-   40 mp1 = m + 1
-      do 50 i = mp1,n,3
-        stemp = sx(i)
-        sx(i) = sy(i)
-        sy(i) = stemp
-        stemp = sx(i + 1)
-        sx(i + 1) = sy(i + 1)
-        sy(i + 1) = stemp
-        stemp = sx(i + 2)
-        sx(i + 2) = sy(i + 2)
-        sy(i + 2) = stemp
-   50 continue
-      return
-      end
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/ivout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/ivout.f
deleted file mode 100644
index e97118a86b..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/ivout.f
+++ /dev/null
@@ -1,120 +0,0 @@
-C-----------------------------------------------------------------------
-C  Routine:    IVOUT
-C
-C  Purpose:    Integer vector output routine.
-C
-C  Usage:      CALL IVOUT (LOUT, N, IX, IDIGIT, IFMT)
-C
-C  Arguments
-C     N      - Length of array IX. (Input)
-C     IX     - Integer array to be printed. (Input)
-C     IFMT   - Format to be used in printing array IX. (Input)
-C     IDIGIT - Print up to ABS(IDIGIT) decimal digits / number. (Input)
-C              If IDIGIT .LT. 0, printing is done with 72 columns.
-C              If IDIGIT .GT. 0, printing is done with 132 columns.
-C
-C-----------------------------------------------------------------------
-C
-      SUBROUTINE IVOUT (LOUT, N, IX, IDIGIT, IFMT)
-C     ...
-C     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER    IX(*), N, IDIGIT, LOUT
-      CHARACTER  IFMT*(*)
-C     ...
-C     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER    I, NDIGIT, K1, K2, LLL
-      CHARACTER*80 LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-C
-      LLL = MIN ( LEN ( IFMT ), 80 )
-      DO 1 I = 1, LLL
-          LINE(I:I) = '-'
-    1 CONTINUE
-C
-      DO 2 I = LLL+1, 80
-          LINE(I:I) = ' '
-    2 CONTINUE
-C
-      WRITE ( LOUT, 2000 ) IFMT, LINE(1:LLL)
- 2000 FORMAT ( /1X, A  /1X, A )
-C
-      IF (N .LE. 0) RETURN
-      NDIGIT = IDIGIT
-      IF (IDIGIT .EQ. 0) NDIGIT = 4
-C
-C=======================================================================
-C             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-C=======================================================================
-C
-      IF (IDIGIT .LT. 0) THEN
-C
-      NDIGIT = -IDIGIT
-      IF (NDIGIT .LE. 4) THEN
-         DO 10 K1 = 1, N, 10
-            K2 = MIN0(N,K1+9)
-            WRITE(LOUT,1000) K1,K2,(IX(I),I=K1,K2)
-   10    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 6) THEN
-         DO 30 K1 = 1, N, 7
-            K2 = MIN0(N,K1+6)
-            WRITE(LOUT,1001) K1,K2,(IX(I),I=K1,K2)
-   30    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 10) THEN
-         DO 50 K1 = 1, N, 5
-            K2 = MIN0(N,K1+4)
-            WRITE(LOUT,1002) K1,K2,(IX(I),I=K1,K2)
-   50    CONTINUE
-C
-      ELSE
-         DO 70 K1 = 1, N, 3
-            K2 = MIN0(N,K1+2)
-            WRITE(LOUT,1003) K1,K2,(IX(I),I=K1,K2)
-   70    CONTINUE
-      END IF
-C
-C=======================================================================
-C             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-C=======================================================================
-C
-      ELSE
-C
-      IF (NDIGIT .LE. 4) THEN
-         DO 90 K1 = 1, N, 20
-            K2 = MIN0(N,K1+19)
-            WRITE(LOUT,1000) K1,K2,(IX(I),I=K1,K2)
-   90    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 6) THEN
-         DO 110 K1 = 1, N, 15
-            K2 = MIN0(N,K1+14)
-            WRITE(LOUT,1001) K1,K2,(IX(I),I=K1,K2)
-  110    CONTINUE
-C
-      ELSE IF (NDIGIT .LE. 10) THEN
-         DO 130 K1 = 1, N, 10
-            K2 = MIN0(N,K1+9)
-            WRITE(LOUT,1002) K1,K2,(IX(I),I=K1,K2)
-  130    CONTINUE
-C
-      ELSE
-         DO 150 K1 = 1, N, 7
-            K2 = MIN0(N,K1+6)
-            WRITE(LOUT,1003) K1,K2,(IX(I),I=K1,K2)
-  150    CONTINUE
-      END IF
-      END IF
-      WRITE (LOUT,1004)
-C
- 1000 FORMAT(1X,I4,' - ',I4,':',20(1X,I5))
- 1001 FORMAT(1X,I4,' - ',I4,':',15(1X,I7))
- 1002 FORMAT(1X,I4,' - ',I4,':',10(1X,I11))
- 1003 FORMAT(1X,I4,' - ',I4,':',7(1X,I15))
- 1004 FORMAT(1X,' ')
-C
-      RETURN
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/second_NONE.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/second_NONE.f
deleted file mode 100644
index 01fcc9dcf8..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/second_NONE.f
+++ /dev/null
@@ -1,36 +0,0 @@
-      SUBROUTINE ARSCND( T )
-*
-      REAL       T
-*
-*  -- LAPACK auxiliary routine (preliminary version) --
-*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
-*     Courant Institute, Argonne National Lab, and Rice University
-*     July 26, 1991
-*
-*  Purpose
-*  =======
-*
-*  SECOND returns the user time for a process in arscnds.
-*  This version gets the time from the system function ETIME.
-*
-*     .. Local Scalars ..
-      REAL               T1
-*     ..
-*     .. Local Arrays ..
-      REAL               TARRAY( 2 )
-*     ..
-*     .. External Functions ..
-      REAL               ETIME
-      EXTERNAL           ETIME
-*     ..
-*     .. Executable Statements ..
-*
-
-c      T1 = ETIME( TARRAY )
-c      T  = TARRAY( 1 )
-      T = 0
-      RETURN
-*
-*     End of ARSCND
-*
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/smout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/smout.f
deleted file mode 100644
index 8d90bf2099..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/smout.f
+++ /dev/null
@@ -1,157 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    SMOUT
-*
-*  Purpose:    Real matrix output routine.
-*
-*  Usage:      CALL SMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Real M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE SMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      REAL               A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, ( A( I, J ), J = K1, K2 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 160 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  WRITE( LOUT, 9991 )I, ( A( I, J ), J = K1, K2 )
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 10X, 10( 4X, 3A1, I4, 1X ) )
- 9997 FORMAT( 10X, 8( 5X, 3A1, I4, 2X ) )
- 9996 FORMAT( 10X, 6( 7X, 3A1, I4, 4X ) )
- 9995 FORMAT( 10X, 5( 9X, 3A1, I4, 6X ) )
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P10E12.3 )
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P8E14.5 )
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P6E18.9 )
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P5E22.13 )
- 9990 FORMAT( 1X, ' ' )
-*
-      RETURN
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/svout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/svout.f
deleted file mode 100644
index 4363b924b2..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/svout.f
+++ /dev/null
@@ -1,112 +0,0 @@
-*-----------------------------------------------------------------------
-*  Routine:    SVOUT
-*
-*  Purpose:    Real vector output routine.
-*
-*  Usage:      CALL SVOUT (LOUT, N, SX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array SX.  (Input)
-*     SX     - Real array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array SX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE SVOUT( LOUT, N, SX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      REAL               SX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 50 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               WRITE( LOUT, 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 10
-               K2 = MIN0( N, K1+9 )
-               WRITE( LOUT, 9998 )K1, K2, ( SX( I ), I = K1, K2 )
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 8
-               K2 = MIN0( N, K1+7 )
-               WRITE( LOUT, 9997 )K1, K2, ( SX( I ), I = K1, K2 )
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.10 ) THEN
-            DO 90 K1 = 1, N, 6
-               K2 = MIN0( N, K1+5 )
-               WRITE( LOUT, 9996 )K1, K2, ( SX( I ), I = K1, K2 )
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 5
-               K2 = MIN0( N, K1+4 )
-               WRITE( LOUT, 9995 )K1, K2, ( SX( I ), I = K1, K2 )
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1P10E12.3 )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P8E14.5 )
- 9996 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P6E18.9 )
- 9995 FORMAT( 1X, I4, ' - ', I4, ':', 1X, 1P5E24.13 )
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zmout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zmout.f
deleted file mode 100644
index c39f6defee..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zmout.f
+++ /dev/null
@@ -1,250 +0,0 @@
-*
-*  Routine:    ZMOUT
-*
-*  Purpose:    Complex*16 matrix output routine.
-*
-*  Usage:      CALL ZMOUT (LOUT, M, N, A, LDA, IDIGIT, IFMT)
-*
-*  Arguments
-*     M      - Number of rows of A.  (Input)
-*     N      - Number of columns of A.  (Input)
-*     A      - Complex*16 M by N matrix to be printed.  (Input)
-*     LDA    - Leading dimension of A exactly as specified in the
-*              dimension statement of the calling program.  (Input)
-*     IFMT   - Format to be used in printing matrix A.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*\SCCS Information: @(#)
-* FILE: zmout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE ZMOUT( LOUT, M, N, A, LDA, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            M, N, IDIGIT, LDA, LOUT
-      Complex*16
-     &                   A( LDA, * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, J, NDIGIT, K1, K2, LLL
-      CHARACTER*1        ICOL( 3 )
-      CHARACTER*80       LINE
-*     ...
-*     ... SPECIFICATIONS INTRINSICS
-      INTRINSIC          MIN
-*
-      DATA               ICOL( 1 ), ICOL( 2 ), ICOL( 3 ) / 'C', 'o',
-     $                   'l' /
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( M.LE.0 .OR. N.LE.0 .OR. LDA.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 30 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9994 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9984 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-   30          CONTINUE
-   40       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 60 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 50 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9993 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9983 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-   50          CONTINUE
-   60       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 80 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 70 I = 1, M
-                  IF (K1.NE.N) THEN
-                     WRITE( LOUT, 9992 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9982 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-   70          CONTINUE
-   80       CONTINUE
-*
-         ELSE
-            DO 100 K1 = 1, N
-               WRITE( LOUT, 9995 ) ICOL, K1
-               DO 90 I = 1, M
-                  WRITE( LOUT, 9991 )I, A( I, K1 )
-   90          CONTINUE
-  100       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 120 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               WRITE( LOUT, 9998 )( ICOL, I, I = K1, K2 )
-               DO 110 I = 1, M
-                  IF ((K1+3).LE.N) THEN
-                     WRITE( LOUT, 9974 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.1) THEN
-                     WRITE( LOUT, 9964 )I, ( A( I, J ), J = k1, K2 )
-                  ELSE IF ((K1+3-N).EQ.2) THEN
-                     WRITE( LOUT, 9954 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+3-N).EQ.3) THEN
-                     WRITE( LOUT, 9944 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  110          CONTINUE
-  120       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 140 K1 = 1, N, 3
-               K2 = MIN0( N, K1+ 2)
-               WRITE( LOUT, 9997 )( ICOL, I, I = K1, K2 )
-               DO 130 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9973 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9963 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9953 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  130          CONTINUE
-  140       CONTINUE
-*
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 160 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-                  WRITE( LOUT, 9996 )( ICOL, I, I = K1, K2 )
-               DO 150 I = 1, M
-                  IF ((K1+2).LE.N) THEN
-                     WRITE( LOUT, 9972 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.1) THEN
-                     WRITE( LOUT, 9962 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE IF ((K1+2-N).EQ.2) THEN
-                     WRITE( LOUT, 9952 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  150          CONTINUE
-  160       CONTINUE
-*
-         ELSE
-            DO 180 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               WRITE( LOUT, 9995 )( ICOL, I, I = K1, K2 )
-               DO 170 I = 1, M
-                  IF ((K1+1).LE.N) THEN
-                     WRITE( LOUT, 9971 )I, ( A( I, J ), J = K1, K2 )
-                  ELSE
-                     WRITE( LOUT, 9961 )I, ( A( I, J ), J = K1, K2 )
-                  END IF
-  170          CONTINUE
-  180       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9990 )
-*
- 9998 FORMAT( 11X, 4( 9X, 3A1, I4, 9X ) )
- 9997 FORMAT( 10X, 4( 11X, 3A1, I4, 11X ) )
- 9996 FORMAT( 10X, 3( 13X, 3A1, I4, 13X ) )
- 9995 FORMAT( 12X, 2( 18x, 3A1, I4, 18X ) )
-*
-*========================================================
-*              FORMAT FOR 72 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9994 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D10.3,',',D10.3,')  ') )
- 9984 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9993 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D12.5,',',D12.5,')  ') )
- 9983 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9992 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D14.7,',',D14.7,')  ') )
- 9982 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9991 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D20.13,',',D20.13,')') )
- 9990 FORMAT( 1X, ' ' )
-*
-*
-*========================================================
-*              FORMAT FOR 132 COLUMN
-*========================================================
-*
-*            DISPLAY 4 SIGNIFICANT DIGIT
-*
- 9974 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,4('(',D10.3,',',D10.3,')  ') )
- 9964 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D10.3,',',D10.3,')  ') )
- 9954 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D10.3,',',D10.3,')  ') )
- 9944 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*            DISPLAY 6 SIGNIFICANT DIGIT
-*
- 9973 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D12.5,',',D12.5,')  ') )
- 9963 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D12.5,',',D12.5,')  ') )
- 9953 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*            DISPLAY 8 SIGNIFICANT DIGIT
-*
- 9972 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,3('(',D14.7,',',D14.7,')  ') )
- 9962 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D14.7,',',D14.7,')  ') )
- 9952 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*            DISPLAY 13 SIGNIFICANT DIGIT
-*
- 9971 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,2('(',D20.13,',',D20.13,
-     &        ')  '))
- 9961 FORMAT( 1X, ' Row', I4, ':', 1X, 1P,1('(',D20.13,',',D20.13,
-     &        ')  '))
-
-*
-*
-*
-*
-      RETURN
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zvout.f b/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zvout.f
deleted file mode 100644
index 8c42eb8908..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/ARPACK/UTIL/zvout.f
+++ /dev/null
@@ -1,240 +0,0 @@
-c-----------------------------------------------------------------------
-c
-c\SCCS Information: @(#)
-c FILE: zvout.f   SID: 2.1   DATE OF SID: 11/16/95   RELEASE: 2
-c
-*-----------------------------------------------------------------------
-*  Routine:    ZVOUT
-*
-*  Purpose:    Complex*16 vector output routine.
-*
-*  Usage:      CALL ZVOUT (LOUT, N, CX, IDIGIT, IFMT)
-*
-*  Arguments
-*     N      - Length of array CX.  (Input)
-*     CX     - Complex*16 array to be printed.  (Input)
-*     IFMT   - Format to be used in printing array CX.  (Input)
-*     IDIGIT - Print up to IABS(IDIGIT) decimal digits per number.  (In)
-*              If IDIGIT .LT. 0, printing is done with 72 columns.
-*              If IDIGIT .GT. 0, printing is done with 132 columns.
-*
-*-----------------------------------------------------------------------
-*
-      SUBROUTINE ZVOUT( LOUT, N, CX, IDIGIT, IFMT )
-*     ...
-*     ... SPECIFICATIONS FOR ARGUMENTS
-      INTEGER            N, IDIGIT, LOUT
-      Complex*16
-     &                   CX( * )
-      CHARACTER          IFMT*( * )
-*     ...
-*     ... SPECIFICATIONS FOR LOCAL VARIABLES
-      INTEGER            I, NDIGIT, K1, K2, LLL
-      CHARACTER*80       LINE
-*     ...
-*     ... FIRST EXECUTABLE STATEMENT
-*
-*
-      LLL = MIN( LEN( IFMT ), 80 )
-      DO 10 I = 1, LLL
-         LINE( I: I ) = '-'
-   10 CONTINUE
-*
-      DO 20 I = LLL + 1, 80
-         LINE( I: I ) = ' '
-   20 CONTINUE
-*
-      WRITE( LOUT, 9999 )IFMT, LINE( 1: LLL )
- 9999 FORMAT( / 1X, A / 1X, A )
-*
-      IF( N.LE.0 )
-     $   RETURN
-      NDIGIT = IDIGIT
-      IF( IDIGIT.EQ.0 )
-     $   NDIGIT = 4
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 72 COLUMNS FORMAT
-*=======================================================================
-*
-      IF( IDIGIT.LT.0 ) THEN
-         NDIGIT = -IDIGIT
-         IF( NDIGIT.LE.4 ) THEN
-            DO 30 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9998 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9997 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   30       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 40 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9988 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9987 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   40       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 50 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF (K1.NE.N) THEN
-                  WRITE( LOUT, 9978 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE
-                  WRITE( LOUT, 9977 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   50       CONTINUE
-         ELSE
-            DO 60 K1 = 1, N
-               WRITE( LOUT, 9968 )K1, K1, CX( I )
-   60       CONTINUE
-         END IF
-*
-*=======================================================================
-*             CODE FOR OUTPUT USING 132 COLUMNS FORMAT
-*=======================================================================
-*
-      ELSE
-         IF( NDIGIT.LE.4 ) THEN
-            DO 70 K1 = 1, N, 4
-               K2 = MIN0( N, K1+3 )
-               IF ((K1+3).LE.N) THEN
-                  WRITE( LOUT, 9958 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9957 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9956 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+3-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9955 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   70       CONTINUE
-         ELSE IF( NDIGIT.LE.6 ) THEN
-            DO 80 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9948 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9947 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9946 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   80       CONTINUE
-         ELSE IF( NDIGIT.LE.8 ) THEN
-            DO 90 K1 = 1, N, 3
-               K2 = MIN0( N, K1+2 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9938 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9937 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 2) THEN
-                  WRITE( LOUT, 9936 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-   90       CONTINUE
-         ELSE
-            DO 100 K1 = 1, N, 2
-               K2 = MIN0( N, K1+1 )
-               IF ((K1+2).LE.N) THEN
-                  WRITE( LOUT, 9928 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               ELSE IF ((K1+2-N) .EQ. 1) THEN
-                  WRITE( LOUT, 9927 )K1, K2, ( CX( I ),
-     $                   I = K1, K2 )
-               END IF
-  100       CONTINUE
-         END IF
-      END IF
-      WRITE( LOUT, 9994 )
-      RETURN
-*
-*=======================================================================
-*                   FORMAT FOR 72 COLUMNS
-*=======================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9998 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D10.3,',',D10.3,')  ') )
- 9997 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9988 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D12.5,',',D12.5,')  ') )
- 9987 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9978 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D14.7,',',D14.7,')  ') )
- 9977 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9968 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D20.13,',',D20.13,')  ') )
-*
-*=========================================================================
-*                   FORMAT FOR 132 COLUMNS
-*=========================================================================
-*
-*                 DISPLAY 4 SIGNIFICANT DIGITS
-*
- 9958 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,4('(',D10.3,',',D10.3,')  ') )
- 9957 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D10.3,',',D10.3,')  ') )
- 9956 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D10.3,',',D10.3,')  ') )
- 9955 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D10.3,',',D10.3,')  ') )
-*
-*                 DISPLAY 6 SIGNIFICANT DIGITS
-*
- 9948 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D12.5,',',D12.5,')  ') )
- 9947 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D12.5,',',D12.5,')  ') )
- 9946 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D12.5,',',D12.5,')  ') )
-*
-*                 DISPLAY 8 SIGNIFICANT DIGITS
-*
- 9938 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,3('(',D14.7,',',D14.7,')  ') )
- 9937 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D14.7,',',D14.7,')  ') )
- 9936 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D14.7,',',D14.7,')  ') )
-*
-*                 DISPLAY 13 SIGNIFICANT DIGITS
-*
- 9928 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,2('(',D20.13,',',D20.13,')  ') )
- 9927 FORMAT( 1X, I4, ' - ', I4, ':', 1X,
-     $        1P,1('(',D20.13,',',D20.13,')  ') )
-*
-*
-*
- 9994 FORMAT( 1X, ' ' )
-      END
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack.h
new file mode 100644
index 0000000000..89c07e6557
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack.h
@@ -0,0 +1,266 @@
+/*
+
+ This is a C adaptation and rewrite of the well-known Fortran77 ARPACK large-scale
+ eigenvalue problem solver, which is widely used in scientific computing, authored
+ by Richard Lehoucq, Kristi Maschhoff, Danny Sorensen, and Chao Yang.
+
+ The source is based on the original Fortran77 and a few of the patches collected
+ over the years. The patched Fortran code can be found at arpack-ng repository
+ on GitHub, at the time of writing version 3.9.1:
+
+ https://github.com/opencollab/arpack-ng/
+
+ While the translation is done mostly, in a straightforward fashion, however,
+ still there are significant changes, namely, XYapps.f and Xstqrb.f are rewritten
+ to avoid the goto-based flow. This version also includes API breaking changes to
+ make it more flexible to be included in other projects.
+
+ ARPACK uses the so-called reverse-communication style that typically exits
+ the program with its in/out arguments to signal, in what stage the algorithm
+ is and what it needs. Then user modifies the arguments and calls again with
+ the necessary information. Thus the state of the whole program is sent back
+ and forth through in-place modified arguments. On top of this, ARPACK also
+ uses lots of variables through the Fortran's dreadful use of SAVE attribute
+ (similar to that of C language STATIC keyword inside a function body) that
+ persists the variable values across consecutive calls. Instead we move all
+ those variables into the reverse communication layer by a C-struct bridge and
+ for array arguments pointers that are provided by the user to make modifications
+ in-place without any alloc/free. This struct bridge also allows for reentrancy
+ and avoids the issues that come with thread safety.
+
+ Compared to the original Fortran code, random number generation is now delegated
+ to the user side to allow for seed control, custom generators and replicable runs.
+ Hence, the ido_RANDOM and ido_RANDOM_OPX codes are used to signal that the user
+ input is needed. In turn the ido mode -1 is removed.
+
+
+ ==============================================================================
+
+ Author: Ilhan Polat
+ Copyright (C) 2025 SciPy developers
+
+  Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+  a. Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+ b. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ c. Names of the SciPy Developers may not be used to endorse or promote
+    products derived from this software without specific prior written
+    permission.
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS
+ BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+ OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ THE POSSIBILITY OF SUCH DAMAGE.
+
+
+ Original Fortran77 ARPACK code license;
+
+-------------
+
+ The ARPACK license is the BSD 3-clause license ("New BSD License")
+
+ BSD Software License
+
+ Pertains to ARPACK and P_ARPACK
+
+ Copyright (c) 1996-2008 Rice University.
+ Developed by D.C. Sorensen, R.B. Lehoucq, C. Yang, and K. Maschhoff.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are
+ met:
+
+ - Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+
+ - Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer listed
+   in this license in the documentation and/or other materials
+   provided with the distribution.
+
+ - Neither the name of the copyright holders nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+
+
+#ifndef _ARPACK_H
+#define _ARPACK_H
+
+#include <math.h>
+#include <complex.h>
+
+#if defined(_MSC_VER)
+    // MSVC definitions
+    typedef _Dcomplex ARPACK_CPLX_TYPE;
+    typedef _Fcomplex ARPACK_CPLXF_TYPE;
+
+#else
+    // C99 compliant compilers
+    typedef double complex ARPACK_CPLX_TYPE;
+    typedef float complex ARPACK_CPLXF_TYPE;
+
+#endif
+
+
+enum ARPACK_which {
+    which_LM = 0,    // want the NEV eigenvalues of largest magnitude.
+    which_SM = 1,    // want the NEV eigenvalues of smallest magnitude.
+    which_LR = 2,    // want the NEV eigenvalues of largest real part.
+    which_SR = 3,    // want the NEV eigenvalues of smallest real part.
+    which_LI = 4,    // want the NEV eigenvalues of largest imaginary part.
+    which_SI = 5,    // want the NEV eigenvalues of smallest imaginary part.
+    which_LA = 6,    // compute the NEV largest (algebraic) eigenvalues. (sym)
+    which_SA = 7,    // compute the NEV smallest (algebraic) eigenvalues. (sym)
+    which_BE = 8     // compute NEV eigenvalues, half from each end of the spectrum. (sym)
+};
+
+enum ARPACK_ido {
+    ido_FIRST      = 0,  // First call
+    ido_OPX        = 1,  // OP*x needed
+    ido_BX         = 2,  // B*x needed
+    ido_USER_SHIFT = 3,  // User shifts are needed
+    ido_RANDOM     = 4,  // A random vector is needed to be written in resid
+    ido_RANDOM_OPX = 5,  // Force random vector to be in the range of OP
+    ido_DONE       = 99  // Done
+};
+
+/**
+ * With the following structs, we collect all "SAVE"d Fortran variables to track
+ * the problem and avoid reentry issues. It is not the cleanest and is laborious
+ * but otherwise reentrancy is compromised. There are additional variables in the
+ * original Fortran code that are also "SAVE"d however upon inspection, they
+ * are assigned and then used in the same call and thus used without saving.
+**/
+
+struct ARPACK_arnoldi_update_vars_s {
+    float tol;               // problem parameter                input parameter
+    float getv0_rnorm0;      // getv0 internal compute           internal
+    float aitr_betaj;        // naitr internal compute           internal
+    float aitr_rnorm1;       // naitr internal compute           internal
+    float aitr_wnorm;        // naitr internal compute           internal
+    float aup2_rnorm;        // naup2 internal compute           internal
+    enum ARPACK_which which; // naupd flow control               input
+    enum ARPACK_ido ido;     // naupd flow control               input/output
+    int info;                // problem outcome,                 input/output
+    int bmat;                // problem parameter, boolean       input
+    int mode;                // problem parameter,               input
+    int n;                   // problem parameter,               input
+    int ncv;                 // problem parameter,               input
+    int nev;                 // problem parameter,               input
+    int shift;               // problem parameter, boolean       input
+    int maxiter;             // problem parameter,               input
+    int nconv;               // problem outcome,                 output
+    int iter;                // problem intermediate,            internal
+    int np;                  // problem intermediate,            internal
+    int getv0_first;         // getv0 flow control               internal
+    int getv0_iter;          // getv0 flow control               internal
+    int getv0_itry;          // getv0 flow control               internal
+    int getv0_orth;          // getv0 flow control               internal
+    int aitr_iter;           // naitr flow control               internal
+    int aitr_j;              // naitr flow control               internal
+    int aitr_orth1;          // naitr flow control               internal
+    int aitr_orth2;          // naitr flow control               internal
+    int aitr_restart;        // naitr flow control               internal
+    int aitr_step3;          // naitr flow control               internal
+    int aitr_step4;          // naitr flow control               internal
+    int aitr_ierr;           // naitr flow control               internal
+    int aup2_initv;          // naupd2 flow control              internal
+    int aup2_iter;           // naupd2 flow control              internal
+    int aup2_getv0;          // naupd2 flow control              internal
+    int aup2_cnorm;          // naupd2 flow control              internal
+    int aup2_kplusp;         // naupd2 flow control              internal
+    int aup2_nev0;           // naupd2 internal compute          internal
+    int aup2_np0;            // naupd2 internal compute          internal
+    int aup2_numcnv;         // naupd2 internal compute          internal
+    int aup2_update;         // naupd2 flow control              internal
+    int aup2_ushift;         // naupd2 flow control              internal
+};
+
+
+struct ARPACK_arnoldi_update_vars_d {
+    double tol;              // problem parameter                input parameter
+    double getv0_rnorm0;     // getv0 internal compute           internal
+    double aitr_betaj;       // naitr internal compute           internal
+    double aitr_rnorm1;      // naitr internal compute           internal
+    double aitr_wnorm;       // naitr internal compute           internal
+    double aup2_rnorm;       // naup2 internal compute           internal
+    enum ARPACK_which which; // naupd flow control               input
+    enum ARPACK_ido ido;     // naupd flow control               input/output
+    int info;                // problem outcome,                 input/output
+    int bmat;                // problem parameter, boolean       input
+    int mode;                // problem parameter,               input
+    int n;                   // problem parameter,               input
+    int ncv;                 // problem parameter,               input
+    int nev;                 // problem parameter,               input
+    int shift;               // problem parameter, boolean       input
+    int maxiter;             // problem parameter,               input
+    int nconv;               // problem outcome,                 output
+    int iter;                // problem intermediate,            internal
+    int np;                  // problem intermediate,            internal
+    int getv0_first;         // getv0 flow control               internal
+    int getv0_iter;          // getv0 flow control               internal
+    int getv0_itry;          // getv0 flow control               internal
+    int getv0_orth;          // getv0 flow control               internal
+    int aitr_iter;           // naitr flow control               internal
+    int aitr_j;              // naitr flow control               internal
+    int aitr_orth1;          // naitr flow control               internal
+    int aitr_orth2;          // naitr flow control               internal
+    int aitr_restart;        // naitr flow control               internal
+    int aitr_step3;          // naitr flow control               internal
+    int aitr_step4;          // naitr flow control               internal
+    int aitr_ierr;           // naitr flow control               internal
+    int aup2_initv;          // naupd2 flow control              internal
+    int aup2_iter;           // naupd2 flow control              internal
+    int aup2_getv0;          // naupd2 flow control              internal
+    int aup2_cnorm;          // naupd2 flow control              internal
+    int aup2_kplusp;         // naupd2 flow control              internal
+    int aup2_nev0;           // naupd2 internal compute          internal
+    int aup2_np0;            // naupd2 internal compute          internal
+    int aup2_numcnv;         // naupd2 internal compute          internal
+    int aup2_update;         // naupd2 flow control              internal
+    int aup2_ushift;         // naupd2 flow control              internal
+};
+
+
+void ARPACK_snaupd(struct ARPACK_arnoldi_update_vars_s *V, float* resid, float* v, int ldv, int* ipntr, float* workd, float* workl);
+void ARPACK_dnaupd(struct ARPACK_arnoldi_update_vars_d *V, double* resid, double* v, int ldv, int* ipntr, double* workd, double* workl);
+void ARPACK_cnaupd(struct ARPACK_arnoldi_update_vars_s *V, ARPACK_CPLXF_TYPE* resid, ARPACK_CPLXF_TYPE* v, int ldv, int* ipntr, ARPACK_CPLXF_TYPE* workd, ARPACK_CPLXF_TYPE* workl, float* rwork);
+void ARPACK_znaupd(struct ARPACK_arnoldi_update_vars_d *V, ARPACK_CPLX_TYPE* resid, ARPACK_CPLX_TYPE* v, int ldv, int* ipntr, ARPACK_CPLX_TYPE* workd, ARPACK_CPLX_TYPE* workl, double* rwork);
+
+void ARPACK_sneupd(struct ARPACK_arnoldi_update_vars_s *V, int rvec, int howmny, int* select, float* dr, float* di, float* z, int ldz, float sigmar, float sigmai, float* workev, float* resid, float* v, int ldv, int* ipntr, float* workd, float* workl);
+void ARPACK_dneupd(struct ARPACK_arnoldi_update_vars_d *V, int rvec, int howmny, int* select, double* dr, double* di, double* z, int ldz, double sigmar, double sigmai, double* workev, double* resid, double* v, int ldv, int* ipntr, double* workd, double* workl);
+void ARPACK_cneupd(struct ARPACK_arnoldi_update_vars_s *V, int rvec, int howmny, int* select, ARPACK_CPLXF_TYPE* d, ARPACK_CPLXF_TYPE* z, int ldz, ARPACK_CPLXF_TYPE sigma, ARPACK_CPLXF_TYPE* workev, ARPACK_CPLXF_TYPE* resid, ARPACK_CPLXF_TYPE* v, int ldv, int* ipntr, ARPACK_CPLXF_TYPE* workd, ARPACK_CPLXF_TYPE* workl, float* rwork);
+void ARPACK_zneupd(struct ARPACK_arnoldi_update_vars_d *V, int rvec, int howmny, int* select, ARPACK_CPLX_TYPE* d, ARPACK_CPLX_TYPE* z, int ldz, ARPACK_CPLX_TYPE sigma, ARPACK_CPLX_TYPE* workev, ARPACK_CPLX_TYPE* resid, ARPACK_CPLX_TYPE* v, int ldv, int* ipntr, ARPACK_CPLX_TYPE* workd, ARPACK_CPLX_TYPE* workl, double* rwork);
+
+void ARPACK_ssaupd(struct ARPACK_arnoldi_update_vars_s *V, float* resid, float* v, int ldv, int* ipntr, float* workd, float* workl);
+void ARPACK_dsaupd(struct ARPACK_arnoldi_update_vars_d *V, double* resid, double* v, int ldv, int* ipntr, double* workd, double* workl);
+
+void ARPACK_sseupd(struct ARPACK_arnoldi_update_vars_s *V, int rvec, int howmny, int* select, float* d, float* z, int ldz, float sigma, float* resid, float* v, int ldv, int* ipntr, float* workd, float* workl);
+void ARPACK_dseupd(struct ARPACK_arnoldi_update_vars_d *V, int rvec, int howmny, int* select, double* d, double* z, int ldz, double sigma, double* resid, double* v, int ldv, int* ipntr, double* workd, double* workl);
+
+#endif /* ifndef */
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.c b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.c
new file mode 100644
index 0000000000..25c85b2602
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.c
@@ -0,0 +1,2101 @@
+#include "_arpack_n_double.h"
+
+typedef int ARPACK_compare_cfunc(const double, const double, const double, const double);
+
+static int sortc_LM(const double, const double, const double, const double);
+static int sortc_SM(const double, const double, const double, const double);
+static int sortc_LR(const double, const double, const double, const double);
+static int sortc_SR(const double, const double, const double, const double);
+static int sortc_LI(const double, const double, const double, const double);
+static int sortc_SI(const double, const double, const double, const double);
+
+static const double unfl = 2.2250738585072014e-308;
+// static const double ovfl = 1.0 / 2.2250738585072014e-308;
+static const double ulp = 2.220446049250313e-16;
+
+static void dnaup2(struct ARPACK_arnoldi_update_vars_d*, double*, double*, int, double*, int, double*, double*, double*, double*, int, double*, int*, double*);
+static void dnconv(int n, double* ritzr, double* ritzi, double* bounds, const double tol, int* nconv);
+static void dneigh(double*,int,double*,int,double*,double*,double*,double*,int,double*,int*);
+static void dnaitr(struct ARPACK_arnoldi_update_vars_d*,int,int,double*,double*,double*,int,double*,int,int*,double*);
+static void dnapps(int,int*,int,double*,double*,double*,int,double*,int,double*,double*,int,double*,double*);
+static void dngets(struct ARPACK_arnoldi_update_vars_d*,int*,int*,double*,double*,double*);
+static void dsortc(const enum ARPACK_which w, const int apply, const int n, double* xreal, double* ximag, double* y);
+static void dgetv0(struct ARPACK_arnoldi_update_vars_d *V, int initv, int n, int j, double* v, int ldv, double* resid, double* rnorm, int* ipntr, double* workd);
+
+enum ARPACK_neupd_type {
+    REGULAR = 0,
+    SHIFTI,
+    REALPART,
+    IMAGPART
+};
+
+
+void
+ARPACK_dneupd(struct ARPACK_arnoldi_update_vars_d *V, int rvec, int howmny, int* select,
+       double* dr, double* di, double* z, int ldz, double sigmar, double sigmai,
+       double* workev, double* resid, double* v, int ldv, int* ipntr, double* workd,
+       double* workl)
+{
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    int ibd, iconj, ih, iheigr, iheigi, ihbds, iuptri, invsub, iri, irr, j, jj;
+    int bounds, k, ldh, ldq, np, numcnv, reord, ritzr, ritzi;
+    int iwork[1] = { 0 };
+    int ierr = 0, int1 = 1, tmp_int = 0, nconv2 = 0, outncv;
+    double conds, rnorm, sep, temp, temp1, dbl0 = 0.0, dbl1 = 1.0, dblm1 = -1.0;
+    double vl[1] = { 0.0 };
+    enum ARPACK_neupd_type TYP;
+
+    if (V->nconv <= 0) {
+        ierr = -14;
+    } else if (V->n <= 0) {
+        ierr = -1;
+    } else if (V->nev <= 0) {
+        ierr = -2;
+    } else if ((V->ncv <= V->nev + 1) || (V->ncv > V->n)) {
+        ierr = -3;
+    } else if ((V->which > 5) || (V->which < 0)) {
+        ierr = -5;
+    } else if ((V->bmat != 0) && (V->bmat != 1)) {
+        ierr = -6;
+    } else if ((rvec) && ((howmny < 0) || (howmny > 2))) {
+        ierr = -13;
+    } else if (howmny == 2) {
+        ierr = -12;  // NotImplementedError
+    }
+
+    if ((V->mode == 1) || (V->mode == 2)) {
+        TYP = REGULAR;
+    } else if ((V->mode == 3) && (sigmai == 0.0)) {
+        TYP = SHIFTI;
+    } else if (V->mode == 3) {
+        TYP = REALPART;
+    } else if (V->mode == 4) {
+        TYP = IMAGPART;
+    } else {
+        ierr = -10;
+    }
+
+    if ((V->mode == 1) && (V->bmat)) { ierr = -11; }
+
+    if (ierr != 0) {
+        V->info = ierr;
+        return;
+    }
+
+    //  Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //  workl(1:ncv*ncv) := generated Hessenberg matrix
+    //  workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary parts of ritz values
+    //  workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds
+
+    //  The following is used and set by DNEUPD .
+    //  workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed real part of the Ritz values.
+    //  workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed imaginary part of the Ritz values.
+    //  workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed error bounds of the Ritz values
+    //  workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper quasi-triangular matrix for H
+    //  workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the associated matrix representation of the invariant subspace for H.
+    //  GRAND total of NCV * ( 3 * NCV + 6 ) locations.
+
+    ih     = ipntr[4];
+    ritzr  = ipntr[5];
+    ritzi  = ipntr[6];
+    bounds = ipntr[7];
+    ldh = V->ncv;
+    ldq = V->ncv;
+    iheigr = bounds + ldh;
+    iheigi = iheigr + ldh;
+    ihbds  = iheigi + ldh;
+    iuptri = ihbds  + ldh;
+    invsub = iuptri + ldh*V->ncv;
+    ipntr[8]  = iheigr;
+    ipntr[9]  = iheigi;
+    ipntr[10] = ihbds;
+    ipntr[11] = iuptri;
+    ipntr[12] = invsub;
+
+    //  irr points to the REAL part of the Ritz
+    //      values computed by _neigh before
+    //      exiting _naup2.
+    //  iri points to the IMAGINARY part of the
+    //      Ritz values computed by _neigh
+    //      before exiting _naup2.
+    //  ibd points to the Ritz estimates
+    //      computed by _neigh before exiting
+    //      _naup2.
+
+    irr = ipntr[13] + (V->ncv)*(V->ncv);
+    iri = irr + V->ncv;
+    ibd = iri + V->ncv;
+
+    //  RNORM is B-norm of the RESID(1:N).
+    rnorm = workl[ih+2];
+    workl[ih+2] = 0.0;
+
+    if (rvec) {
+        reord = 0;
+
+        //  Use the temporary bounds array to store indices
+        //  These will be used to mark the select array later
+
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[bounds + j] = j;
+            select[j] = 0;
+        }
+        // 10
+
+        //  Select the wanted Ritz values.
+        //  Sort the Ritz values so that the
+        //  wanted ones appear at the tailing
+        //  NEV positions of workl(irr) and
+        //  workl(iri).  Move the corresponding
+        //  error estimates in workl(bound)
+        //  accordingly.
+
+        np = V->ncv - V->nev;
+        dngets(V, &V->nev, &np, &workl[irr], &workl[iri], &workl[bounds]);
+
+        //  Record indices of the converged wanted Ritz values
+        //  Mark the select array for possible reordering
+
+        numcnv = 0;
+        for (j = 1; j <= V->ncv; j++)
+        {
+            temp1 = fmax(eps23, hypot(workl[irr + V->ncv - j], workl[iri + V->ncv - j]));
+
+            jj = (int)workl[bounds + V->ncv - j];
+
+            if ((numcnv < V->nconv) && (workl[ibd + jj] <= V->tol*temp1))
+            {
+                select[jj] = 1;
+                numcnv += 1;
+                if (jj > V->nconv - 1) { reord = 1; }
+            }
+        }
+        // 11
+
+        //  Check the count (numcnv) of converged Ritz values with
+        //  the number (nconv) reported by dnaupd.  If these two
+        //  are different then there has probably been an error
+        //  caused by incorrect passing of the dnaupd data.
+
+        if (numcnv != V->nconv)
+        {
+            V->info = -15;
+            return;
+        }
+
+        //  Call LAPACK routine dlahqr  to compute the real Schur form
+        //  of the upper Hessenberg matrix returned by DNAUPD .
+        //  Make a copy of the upper Hessenberg matrix.
+        //  Initialize the Schur vector matrix Q to the identity.
+
+        tmp_int = ldh*V->ncv;
+        dcopy_(&tmp_int, &workl[ih], &int1, &workl[iuptri], &int1);
+        dlaset_("A", &V->ncv, &V->ncv, &dbl0, &dbl1, &workl[invsub], &ldq);
+        dlahqr_(&int1, &int1, &V->ncv, &int1, &V->ncv, &workl[iuptri], &ldh,
+                &workl[iheigr], &workl[iheigi], &int1, &V->ncv, &workl[invsub],
+                &ldq, &ierr);
+        dcopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        if (ierr != 0)
+        {
+            V->info = -8;
+            return;
+        }
+
+        if (reord)
+        {
+            dtrsen_("N", "V", select, &V->ncv, &workl[iuptri], &ldh, &workl[invsub], &ldq,
+                    &workl[iheigr], &workl[iheigi], &nconv2, &conds, &sep, &workl[ihbds],
+                    &V->ncv, iwork, &int1, &ierr);
+
+            if (nconv2 < V->nconv) { V->nconv = nconv2; }
+            if (ierr == 1) {
+                V->info = 1;
+                return;
+            }
+        }
+
+        //  Copy the last row of the Schur vector
+        //  into workl(ihbds).  This will be used
+        //  to compute the Ritz estimates of
+        //  converged Ritz values.
+
+        dcopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        //  Place the computed eigenvalues of H into DR and DI
+        //  if a spectral transformation was not used.
+
+        if (TYP == REGULAR) {
+            dcopy_(&V->nconv, &workl[iheigr], &int1, dr, &int1);
+            dcopy_(&V->nconv, &workl[iheigi], &int1, di, &int1);
+        }
+
+        //  Compute the QR factorization of the matrix representing
+        //  the wanted invariant subspace located in the first NCONV
+        //  columns of workl(invsub,ldq).
+
+        dgeqr2_(&V->ncv, &V->nconv, &workl[invsub], &ldq, workev, &workev[V->ncv], &ierr);
+
+        //  * Postmultiply V by Q using dorm2r .
+        //  * Copy the first NCONV columns of VQ into Z.
+        //  * Postmultiply Z by R.
+        //  The N by NCONV matrix Z is now a matrix representation
+        //  of the approximate invariant subspace associated with
+        //  the Ritz values in workl(iheigr) and workl(iheigi)
+        //  The first NCONV columns of V are now approximate Schur
+        //  vectors associated with the real upper quasi-triangular
+        //  matrix of order NCONV in workl(iuptri)
+
+        dorm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[invsub], &ldq, workev,
+                v, &ldv, &workd[V->n], &ierr);
+
+        dlacpy_("A", &V->n, &V->nconv, v, &ldv, z, &ldz);
+
+        //  Perform both a column and row scaling if the
+        //  diagonal element of workl(invsub,ldq) is negative
+        //  I'm lazy and don't take advantage of the upper
+        //  quasi-triangular form of workl(iuptri,ldq)
+        //  Note that since Q is orthogonal, R is a diagonal
+        //  matrix consisting of plus or minus ones
+
+        for (j = 0; j < V->nconv; j++)
+        {
+            if (workl[invsub + j*ldq + j] < 0.0)
+            {
+                dscal_(&V->nconv, &dblm1, &workl[iuptri + j], &ldq);
+                dscal_(&V->nconv, &dblm1, &workl[iuptri + j*ldq], &int1);
+            }
+        }
+        // 20
+
+        if (howmny == 0)
+        {
+
+            //  Compute the NCONV wanted eigenvectors of T
+            //  located in workl(iuptri,ldq).
+
+            for (j = 0; j < V->ncv; j++)
+            {
+                if (j < V->nconv)
+                {
+                    select[j] = 1;
+                } else {
+                    select[j] = 0;
+                }
+            }
+            // 30
+
+            dtrevc_("R", "S", select, &V->ncv, &workl[iuptri], &ldq, vl, &int1,
+                    &workl[invsub], &ldq, &V->ncv, &outncv, workev, &ierr);
+
+            if (ierr != 0)
+            {
+                V->info = -9;
+                return;
+            }
+
+            //  Scale the returning eigenvectors so that their
+            //  Euclidean norms are all one. LAPACK subroutine
+            //  dtrevc  returns each eigenvector normalized so
+            //  that the element of largest magnitude has
+            //  magnitude 1;
+
+            iconj = 0;
+            for (j = 0; j < V->nconv; j++)
+            {
+                if (workl[iheigi + j] == 0.0)
+                {
+
+                    //  real eigenvalue case
+
+                    temp = 1.0 / dnrm2_(&V->ncv, &workl[invsub + j*ldq], &int1);
+                    dscal_(&V->ncv, &temp, &workl[invsub + j*ldq], &int1);
+
+                } else {
+
+                    //  Complex conjugate pair case. Note that
+                    //  since the real and imaginary part of
+                    //  the eigenvector are stored in consecutive
+                    //  columns, we further normalize by the
+                    //  square root of two.
+
+                    if (iconj == 0)
+                    {
+                        temp = 1.0 / hypot(dnrm2_(&V->ncv, &workl[invsub + j*ldq], &int1),
+                                           dnrm2_(&V->ncv, &workl[invsub + (j+1)*ldq], &int1));
+                        dscal_(&V->ncv, &temp, &workl[invsub + j*ldq], &int1);
+                        dscal_(&V->ncv, &temp, &workl[invsub + (j+1)*ldq], &int1);
+                        iconj = 1;
+                    } else {
+                        iconj = 0;
+                    }
+                }
+            }
+            // 40
+
+            dgemv_("T", &V->ncv, &V->nconv, &dbl1, &workl[invsub], &ldq, &workl[ihbds], &int1, &dbl0, workev, &int1);
+
+            iconj = 0;
+            for (j = 0; j < V->nconv; j++)
+            {
+                if (workl[iheigi + j] != 0.0)
+                {
+
+                    //  Complex conjugate pair case. Note that
+                    //  since the real and imaginary part of
+                    //  the eigenvector are stored in consecutive
+
+                    if (iconj == 0)
+                    {
+                        workev[j] = hypot(workev[j], workev[j+1]);
+                        workev[j+1] = workev[j];
+                        iconj = 1;
+                    } else {
+                        iconj = 0;
+                    }
+                }
+            }
+            // 45
+
+            //  Copy Ritz estimates into workl(ihbds)
+
+            dcopy_(&V->nconv, workev, &int1, &workl[ihbds], &int1);
+
+            //  Compute the QR factorization of the eigenvector matrix
+            //  associated with leading portion of T in the first NCONV
+            //  columns of workl(invsub,ldq).
+
+            dgeqr2_(&V->ncv, &V->nconv, &workl[invsub], &ldq, workev, &workev[V->ncv], &ierr);
+
+            //  * Postmultiply Z by Q.
+            //  * Postmultiply Z by R.
+            //  The N by NCONV matrix Z is now contains the
+            //  Ritz vectors associated with the Ritz values
+            //  in workl(iheigr) and workl(iheigi).
+
+            dorm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[invsub], &ldq,
+                    workev, z, &ldz, &workd[V->n], &ierr);
+
+            dtrmm_("R", "U", "N", "N", &V->n, &V->nconv, &dbl1, &workl[invsub], &ldq, z, &ldz);
+
+        }
+
+    } else {
+
+        //  An approximate invariant subspace is not needed.
+        //  Place the Ritz values computed DNAUPD  into DR and DI
+
+        dcopy_(&V->nconv, &workl[ritzr], &int1, dr, &int1);
+        dcopy_(&V->nconv, &workl[ritzi], &int1, di, &int1);
+        dcopy_(&V->nconv, &workl[ritzr], &int1, &workl[iheigr], &int1);
+        dcopy_(&V->nconv, &workl[ritzi], &int1, &workl[iheigi], &int1);
+        dcopy_(&V->nconv, &workl[bounds], &int1, &workl[ihbds], &int1);
+    }
+
+    //  Transform the Ritz values and possibly vectors
+    //  and corresponding error bounds of OP to those
+    //  of A*x = lambda*B*x.
+
+    if (TYP == REGULAR)
+    {
+        if (rvec)
+        {
+            dscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+        }
+    } else {
+
+        //    A spectral transformation was used.
+        //  * Determine the Ritz estimates of the
+        //    Ritz values in the original system.
+
+        if (TYP == SHIFTI)
+        {
+            if (rvec)
+            {
+                dscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+            }
+
+            for (k = 0; k < V->ncv; k++)
+            {
+                temp = hypot(workl[iheigr+k], workl[iheigi+k]);
+                workl[ihbds+k] = fabs(workl[ihbds+k]) / temp / temp;
+            }
+            // 50
+
+        }
+
+        //  *  Transform the Ritz values back to the original system.
+        //     For TYPE = 'SHIFTI' the transformation is
+        //              lambda = 1/theta + sigma
+        //     For TYPE = 'REALPT' or 'IMAGPT' the user must from
+        //     Rayleigh quotients or a projection. See remark 3 above.
+        //  NOTES:
+        //  *The Ritz vectors are not affected by the transformation.
+
+        if (TYP == SHIFTI)
+        {
+            for (k = 0; k < V->ncv; k++)
+            {
+                temp = hypot(workl[iheigr+k], workl[iheigi+k]);
+                workl[iheigr+k] =  workl[iheigr+k] / temp / temp + sigmar;
+                workl[iheigi+k] = -workl[iheigi+k] / temp / temp + sigmai;
+            }
+            // 80
+
+            dcopy_(&V->nconv, &workl[iheigr], &int1, dr, &int1);
+            dcopy_(&V->nconv, &workl[iheigi], &int1, di, &int1);
+
+        } else if ((TYP == REALPART) || (TYP == IMAGPART)) {
+            dcopy_(&V->nconv, &workl[iheigr], &int1, dr, &int1);
+            dcopy_(&V->nconv, &workl[iheigi], &int1, di, &int1);
+        }
+    }
+
+    //  Eigenvector Purification step. Formally perform
+    //  one of inverse subspace iteration. Only used
+    //  for MODE = 2.
+
+    if ((rvec) && (howmny == 0) && (TYP == SHIFTI))
+    {
+
+        //  Purify the computed Ritz vectors by adding a
+        //  little bit of the residual vector:
+        //                       T
+        //           resid(:)*( e    s ) / theta
+        //                       NCV
+        //  where H s = s theta. Remember that when theta
+        //  has nonzero imaginary part, the corresponding
+        //  Ritz vector is stored across two columns of Z.
+
+        iconj = 0;
+        for (j = 0; j < V->nconv; j++)
+        {
+            if ((workl[iheigi+j] == 0.0) && (workl[iheigr+j] != 0.0))
+            {
+                workev[j] = workl[invsub + j*ldq + V->ncv] / workl[iheigr+j];
+            } else if (iconj == 0) {
+
+                temp = hypot(workl[iheigr+j], workl[iheigi+j]);
+                if (temp != 0.0)
+                {
+                    workev[j] = (workl[invsub + j*ldq + V->ncv]*workl[iheigr+j] +
+                                 workl[invsub + (j+1)*ldq + V->ncv]*workl[iheigi+j]
+                                ) / temp / temp;
+                    workev[j+1] = (workl[invsub + (j+1)*ldq + V->ncv]*workl[iheigr+j] -
+                                 workl[invsub + j*ldq + V->ncv]*workl[iheigi+j]
+                                ) / temp / temp;
+                }
+                iconj = 1;
+            } else {
+                iconj = 0;
+            }
+        }
+        // 110
+
+        //  Perform a rank one update to Z and
+        //  purify all the Ritz vectors together.
+
+        dger_(&V->n, &V->nconv, &dbl1, resid, &int1, workev, &int1, z, &ldz);
+    }
+
+    return;
+}
+
+void
+ARPACK_dnaupd(struct ARPACK_arnoldi_update_vars_d *V, double* resid, double* v,
+              int ldv, int* ipntr, double* workd, double* workl)
+{
+    int bounds, ih, iq, iw, j, ldh, ldq, next, iritzi, iritzr;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        // perform basic checks
+        if (V->n <= 0) {
+            V->info = -1;
+        } else if (V->nev <= 0) {
+            V->info = -2;
+        } else if ((V->ncv < V->nev + 1) || (V->ncv > V->n)) {
+            V->info = -3;
+        } else if (V->maxiter <= 0) {
+            V->info = -4;
+        } else if ((V->which < 0) || (V->which > 5)) {
+            V->info = -5;
+        } else if ((V->bmat != 0) && (V->bmat != 1)) {
+            V->info = -6;
+        } else if ((V->mode < 1) || (V->mode > 4)) {
+            V->info = -10;
+        } else if ((V->mode == 1) && (V->bmat == 1)) {
+            V->info = -11;
+        } else if ((V->shift != 0) && (V->shift != 1)) {
+            V->info = -12;
+        }
+
+        if (V->info < 0) {
+            V->ido = ido_DONE;
+            return;
+        }
+
+        if (V->tol <= 0.0) {
+            V->tol = ulp;
+        }
+        V->np = V->ncv - V->nev;
+
+        for (j = 0; j < 3 * (V->ncv)*(V->ncv) + 6*(V->ncv); j++)
+        {
+            workl[j] = 0.0;
+        }
+    }
+
+    //  Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //
+    //  workl[0:ncv*ncv] := generated Hessenberg matrix
+    //  workl[ncv**2:ncv**2+2*ncv] := ritz.real and ritz.imag values
+    //  workl[ncv**2+2*ncv:ncv*ncv+3*ncv] := error bounds
+    //  workl[ncv**2+3*ncv+1:2*ncv*ncv+3*ncv] := rotation matrix Q
+    //  workl[2*ncv**2+3*ncv:3*ncv*ncv+6*ncv] := workspace
+    //
+    //  The final workspace is needed by subroutine dneigh  called
+    //  by dnaup2 . Subroutine dneigh  calls LAPACK routines for
+    //  calculating eigenvalues and the last row of the eigenvector
+    //  matrix.
+
+    ldh    = V->ncv;
+    ldq    = V->ncv;
+    ih     = 0;
+    iritzr = ih     + ldh*V->ncv;
+    iritzi = iritzr + V->ncv;
+    bounds = iritzi + V->ncv;
+    iq     = bounds + V->ncv;
+    iw     = iq     + ldq*V->ncv;
+    next   = iw     + (V->ncv*V->ncv) + 3*V->ncv;
+
+    ipntr[3] = next;
+    ipntr[4] = ih;
+    ipntr[5] = iritzr;
+    ipntr[6] = iritzi;
+    ipntr[7] = bounds;
+    ipntr[13]  = iw;
+
+    //  Carry out the Implicitly restarted Arnoldi Iteration.
+
+    dnaup2(V, resid, v, ldv, &workl[ih], ldh, &workl[iritzr], &workl[iritzi], &workl[bounds], &workl[iq], ldq, &workl[iw], ipntr, workd);
+
+    //  ido != DONE implies use of reverse communication
+    //  to compute operations involving OP or shifts.
+
+    if (V->ido != ido_DONE) { return; }
+
+    V->nconv = V->np;
+    // iparam(9) = nopx
+    // iparam(10) = nbx
+    // iparam(11) = nrorth
+
+    if (V->info < 0) { return; }
+    if (V->info == 2) { V->info = 3; }
+
+    return;
+}
+
+void
+dnaup2(struct ARPACK_arnoldi_update_vars_d *V, double* resid, double* v, int ldv,
+       double* h, int ldh, double* ritzr, double* ritzi, double* bounds,
+       double* q, int ldq, double* workl, int* ipntr, double* workd)
+{
+    enum ARPACK_which temp_which;
+    int int1 = 1, j, tmp_int;
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    double temp = 0.0;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->aup2_nev0 = V->nev;
+        V->aup2_np0 = V->np;
+
+        //  kplusp is the bound on the largest
+        //         Lanczos factorization built.
+        //  nconv is the current number of
+        //         "converged" eigenvlues.
+        //  iter is the counter on the current
+        //       iteration step.
+
+        V->aup2_kplusp = V->nev + V->np;
+        V->nconv = 0;
+        V->aup2_iter = 0;
+
+        //  Set flags for computing the first NEV
+        //  steps of the Arnoldi factorization.
+
+        V->aup2_getv0 = 1;
+        V->aup2_update = 0;
+        V->aup2_ushift = 0;
+        V->aup2_cnorm = 0;
+
+        if (V->info != 0)
+        {
+
+            //  User provides the initial residual vector.
+
+            V->aup2_initv = 1;
+            V->info = 0;
+        } else {
+            V->aup2_initv = 0;
+        }
+    }
+
+    //  Get a possibly random starting vector and
+    //  force it into the range of the operator OP.
+
+    if (V->aup2_getv0)
+    {
+        V->getv0_itry = 1;
+        dgetv0(V, V->aup2_initv, V->n, 0, v, ldv, resid, &V->aup2_rnorm, ipntr, workd);
+        if (V->ido != ido_DONE) { return; }
+        if (V->aup2_rnorm == 0.0)
+        {
+            V->info = -9;
+            V->ido = ido_DONE;
+            return;
+        }
+        V->aup2_getv0 = 0;
+        V->ido = ido_FIRST;
+    }
+
+    //  Back from reverse communication :
+    //  continue with update step
+
+    if (V->aup2_update) { goto LINE20; }
+
+    //  Back from computing user specified shifts
+
+    if (V->aup2_ushift) { goto LINE50; }
+
+    //  Back from computing residual norm
+    //  at the end of the current iteration
+
+    if (V->aup2_cnorm) { goto LINE100; }
+
+    //  Compute the first NEV steps of the Arnoldi factorization
+
+    dnaitr(V, 0, V->nev, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //
+    //            M A I N  ARNOLDI  I T E R A T I O N  L O O P
+    //            Each iteration implicitly restarts the Arnoldi
+    //            factorization in place.
+    //
+
+LINE1000:
+    V->aup2_iter += 1;
+
+    //  Compute NP additional steps of the Arnoldi factorization.
+    //  Adjust NP since NEV might have been updated by last call
+    //  to the shift application routine dnapps .
+
+    V->np = V->aup2_kplusp - V->nev;
+
+    //  Compute NP additional steps of the Arnoldi factorization.
+
+    V->ido = ido_FIRST;
+
+LINE20:
+    V->aup2_update = 1;
+
+    dnaitr(V, V->nev, V->np, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0) {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+    V->aup2_update = 0;
+
+    //  Compute the eigenvalues and corresponding error bounds
+    //  of the current upper Hessenberg matrix.
+
+    dneigh(&V->aup2_rnorm, V->aup2_kplusp, h, ldh, ritzr, ritzi, bounds, q, ldq, workl, &V->info);
+
+    if (V->info != 0)
+    {
+       V->info = -8;
+       V->ido = ido_DONE;
+       return;
+    }
+
+    //  Make a copy of eigenvalues and corresponding error
+    //  bounds obtained from dneigh.
+
+    tmp_int = V->aup2_kplusp * V->aup2_kplusp;
+    dcopy_(&V->aup2_kplusp, ritzr, &int1, &workl[tmp_int], &int1);
+    tmp_int += V->aup2_kplusp;
+    dcopy_(&V->aup2_kplusp, ritzi, &int1, &workl[tmp_int], &int1);
+    tmp_int += V->aup2_kplusp;
+    dcopy_(&V->aup2_kplusp, bounds, &int1, &workl[tmp_int], &int1);
+
+    //  Select the wanted Ritz values and their bounds
+    //  to be used in the convergence test.
+    //  The wanted part of the spectrum and corresponding
+    //  error bounds are in the last NEV loc. of RITZR,
+    //  RITZI and BOUNDS respectively. The variables NEV
+    //  and NP may be updated if the NEV-th wanted Ritz
+    //  value has a non zero imaginary part. In this case
+    //  NEV is increased by one and NP decreased by one.
+    //  NOTE: The last two arguments of dngets  are no
+    //  longer used as of version 2.1.
+
+    V->nev = V->aup2_nev0;
+    V->np = V->aup2_np0;
+    V->aup2_numcnv = V->nev;
+
+    dngets(V, &V->nev, &V->np, ritzr, ritzi, bounds);
+
+    if (V->nev == V->aup2_nev0 + 1) { V->aup2_numcnv = V->aup2_nev0 + 1;}
+
+    //  Convergence test.
+
+    dcopy_(&V->nev, &bounds[V->np], &int1, &workl[2*V->np], &int1);
+    dnconv(V->nev, &ritzr[V->np], &ritzi[V->np], &workl[2*V->np], V->tol, &V->nconv);
+
+    //  Count the number of unwanted Ritz values that have zero
+    //  Ritz estimates. If any Ritz estimates are equal to zero
+    //  then a leading block of H of order equal to at least
+    //  the number of Ritz values with zero Ritz estimates has
+    //  split off. None of these Ritz values may be removed by
+    //  shifting. Decrease NP the number of shifts to apply. If
+    //  no shifts may be applied, then prepare to exit
+
+    // We are modifying V->np hence the temporary variable.
+    int nptemp = V->np;
+
+    for (j = 0; j < nptemp; j++)
+    {
+        if (bounds[j] == 0.0)
+        {
+            V->np -= 1;
+            V->nev += 1;
+        }
+    }
+    // 30
+
+    if ((V->nconv >= V->aup2_numcnv) || (V->aup2_iter > V->maxiter) || (V->np == 0))
+    {
+
+        //  Prepare to exit. Put the converged Ritz values
+        //  and corresponding bounds in RITZ(1:NCONV) and
+        //  BOUNDS(1:NCONV) respectively. Then sort. Be
+        //  careful when NCONV > NP
+
+        //   Use h( 3,1 ) as storage to communicate
+        //   rnorm to _neupd if needed
+
+         h[2] = V->aup2_rnorm;
+
+        //  To be consistent with dngets , we first do a
+        //  pre-processing sort in order to keep complex
+        //  conjugate pairs together.  This is similar
+        //  to the pre-processing sort used in dngets
+        //  except that the sort is done in the opposite
+        //  order.
+
+        // Translation note: Is this all because ARPACK did not have complex sort?
+
+        if (V->which == which_LM) { temp_which = which_SR; }
+        if (V->which == which_SM) { temp_which = which_LR; }
+        if (V->which == which_LR) { temp_which = which_SM; }
+        if (V->which == which_SR) { temp_which = which_LM; }
+        if (V->which == which_LI) { temp_which = which_SM; }
+        if (V->which == which_SI) { temp_which = which_LM; }
+
+        dsortc(temp_which, 1, V->aup2_kplusp, ritzr, ritzi, bounds);
+
+        if (V->which == which_LM) { temp_which = which_SM; }
+        if (V->which == which_SM) { temp_which = which_LM; }
+        if (V->which == which_LR) { temp_which = which_SR; }
+        if (V->which == which_SR) { temp_which = which_LR; }
+        if (V->which == which_LI) { temp_which = which_SI; }
+        if (V->which == which_SI) { temp_which = which_LI; }
+
+        dsortc(temp_which, 1, V->aup2_kplusp, ritzr, ritzi, bounds);
+
+        //  Scale the Ritz estimate of each Ritz value
+        //  by 1 / max(eps23,magnitude of the Ritz value).
+
+        for (j = 0; j < V->aup2_numcnv; j++)
+        {
+            temp = fmax(eps23, hypot(ritzr[j], ritzi[j]));
+            bounds[j] = bounds[j] / temp;
+        }
+        // 35
+
+        //  Sort the Ritz values according to the scaled Ritz
+        //  estimates.  This will push all the converged ones
+        //  towards the front of ritzr, ritzi, bounds
+        //  (in the case when NCONV < NEV.)
+
+        temp_which = which_LR;
+        dsortc(temp_which, 1, V->aup2_numcnv, bounds, ritzr, ritzi);
+
+        //  Scale the Ritz estimate back to its original
+        //  value.
+
+        for (j = 0; j < V->aup2_numcnv; j++)
+        {
+            temp = fmax(eps23, hypot(ritzr[j], ritzi[j]));
+            bounds[j] = bounds[j] * temp;
+        }
+        // 40
+
+        //  Sort the converged Ritz values again so that
+        //  the "threshold" value appears at the front of
+        //  ritzr, ritzi and bound.
+
+        dsortc(V->which, 1, V->nconv, ritzr, ritzi, bounds);
+
+        if ((V->aup2_iter > V->maxiter) && (V->nconv < V->aup2_numcnv))
+        {
+
+            //  Max iterations have been exceeded.
+
+            V->info = 1;
+        }
+
+        if ((V->np == 0) && (V->nconv < V->aup2_numcnv))
+        {
+
+            //  No shifts to apply.
+
+            V->info = 2;
+        }
+
+        V->np = V->nconv;
+        V->iter = V->aup2_iter;
+        V->nev = V->aup2_numcnv;
+        V->ido = ido_DONE;
+        return;
+
+    } else if ((V->nconv < V->aup2_numcnv) && (V->shift)) {
+
+        //  Do not have all the requested eigenvalues yet.
+        //  To prevent possible stagnation, adjust the size
+        //  of NEV.
+
+        int nevbef = V->nev;
+        V->nev += (V->nconv > (V->np / 2) ? (V->np / 2) : V->nconv);
+        if ((V->nev == 1) && (V->aup2_kplusp >= 6)) {
+            V->nev = V->aup2_kplusp / 2;
+        } else if ((V->nev == 1) && (V->aup2_kplusp > 3)) {
+            V->nev = 2;
+        }
+
+        //  SciPy Fix
+        //  We must keep nev below this value, as otherwise we can get
+        //  np == 0 (note that dngets below can bump nev by 1). If np == 0,
+        // the next call to `dnaitr` will write out-of-bounds.
+
+        if (V->nev > (V->aup2_kplusp - 2)) {
+            V->nev = V->aup2_kplusp - 2;
+        }
+        //  SciPy Fix End
+
+        V->np = V->aup2_kplusp - V->nev;
+
+        if (nevbef < V->nev) {
+            dngets(V, &V->nev, &V->np, ritzr, ritzi, bounds);
+        }
+
+    }
+
+    if (V->shift == 0)
+    {
+
+        //  User specified shifts: reverse communication to
+        //  compute the shifts. They are returned in the first
+        //  2*NP locations of WORKL.
+
+        V->aup2_ushift = 1;
+        V->ido = ido_USER_SHIFT;
+        return;
+    }
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  User specified shifts are returned
+    //  in WORKL(1:2*NP)
+
+    V->aup2_ushift = 0;
+
+    if (V->shift == 0)
+    {
+
+        //  Move the NP shifts from WORKL to
+        //  RITZR, RITZI to free up WORKL
+        //  for non-exact shift case.
+
+        dcopy_(&V->np, workl, &int1, ritzr, &int1);
+        dcopy_(&V->np, &workl[V->np], &int1, ritzi, &int1);
+    }
+
+    //  Apply the NP implicit shifts by QR bulge chasing.
+    //  Each shift is applied to the whole upper Hessenberg
+    //  matrix H.
+    //  The first 2*N locations of WORKD are used as workspace.
+
+    dnapps(V->n, &V->nev, V->np, ritzr, ritzi, v, ldv, h, ldh, resid, q, ldq, workl, workd);
+
+    //  Compute the B-norm of the updated residual.
+    //  Keep B*RESID in WORKD(1:N) to be used in
+    //  the first step of the next call to dnaitr .
+
+    V->aup2_cnorm = 1;
+    if (V->bmat)
+    {
+        dcopy_(&V->n, resid, &int1, &workd[V->n], &int1);
+        ipntr[0] = V->n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*RESID
+
+        return;
+    } else {
+        dcopy_(&V->n, resid, &int1, workd, &int1);
+    }
+
+LINE100:
+
+    //  Back from reverse communication;
+    //  WORKD(1:N) := B*RESID
+
+    if (V->bmat)
+    {
+        V->aup2_rnorm = ddot_(&V->n, resid, &int1, workd, &int1);
+        V->aup2_rnorm = sqrt(fabs(V->aup2_rnorm));
+    } else {
+        V->aup2_rnorm = dnrm2_(&V->n, resid, &int1);
+    }
+    V->aup2_cnorm = 0;
+
+    goto LINE1000;
+
+    //
+    //   E N D     O F     M A I N     I T E R A T I O N     L O O P
+    //
+
+}
+
+void
+dnconv(int n, double* ritzr, double* ritzi, double* bounds, const double tol, int* nconv)
+{
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    double temp;
+
+    *nconv = 0;
+    for (int i = 0; i < n; i++)
+    {
+        temp = fmax(eps23, hypot(ritzr[i], ritzi[i]));
+        if (bounds[i] <= tol*temp)
+        {
+            *nconv += 1;
+        }
+    }
+
+    return;
+}
+
+void
+dneigh(double* rnorm, int n, double* h, int ldh, double* ritzr, double* ritzi,
+       double* bounds, double* q, int ldq, double* workl, int* ierr)
+{
+    int select[1] = { 0 };
+    int i, iconj, int1 = 1, j;
+    double dbl1 = 1.0, dbl0 = 0.0, temp, tmp_dbl, vl[1] = { 0.0 };
+
+    //  1. Compute the eigenvalues, the last components of the
+    //     corresponding Schur vectors and the full Schur form T
+    //     of the current upper Hessenberg matrix H.
+    //  dlahqr returns the full Schur form of H in WORKL(1:N**2)
+    //  and the last components of the Schur vectors in BOUNDS.
+
+    dlacpy_("A", &n, &n, h, &ldh, workl, &n);
+    for (j = 0; j < n-1; j++)
+    {
+        bounds[j] = 0.0;
+    }
+    bounds[n-1] = 1.0;
+    dlahqr_(&int1, &int1, &n, &int1, &n, workl, &n, ritzr, ritzi, &int1, &int1, bounds, &int1, ierr);
+
+    if (*ierr != 0) { return; }
+
+    //  2. Compute the eigenvectors of the full Schur form T and
+    //     apply the last components of the Schur vectors to get
+    //     the last components of the corresponding eigenvectors.
+    //  Remember that if the i-th and (i+1)-st eigenvalues are
+    //  complex conjugate pairs, then the real & imaginary part
+    //  of the eigenvector components are split across adjacent
+    //  columns of Q.
+
+    dtrevc_("R", "A", select, &n, workl, &n, vl, &n, q, &ldq, &n, &n, &workl[n*n], ierr);
+    if (*ierr != 0) { return; }
+
+    //  Scale the returning eigenvectors so that their
+    //  euclidean norms are all one. LAPACK subroutine
+    //  dtrevc returns each eigenvector normalized so
+    //  that the element of largest magnitude has
+    //  magnitude 1; here the magnitude of a complex
+    //  number (x,y) is taken to be |x| + |y|.
+
+    iconj = 0;
+    for (i = 0; i < n; i++)
+    {
+        if (fabs(ritzi[i]) == 0.0)
+        {
+
+            //  Real eigenvalue case
+
+            temp = dnrm2_(&n, &q[ldq*i], &int1);
+            tmp_dbl = 1.0 / temp;
+            dscal_(&n, &tmp_dbl, &q[ldq*i], &int1);
+
+        } else {
+
+            //  Complex conjugate pair case. Note that
+            //  since the real and imaginary part of
+            //  the eigenvector are stored in consecutive
+            //  columns, we further normalize by the
+            //  square root of two.
+
+            if (iconj == 0)
+            {
+                temp = hypot(dnrm2_(&n, &q[ldq*i], &int1),
+                             dnrm2_(&n, &q[ldq*(i+1)], &int1));
+                tmp_dbl = 1.0 / temp;
+                dscal_(&n, &tmp_dbl, &q[ldq*i], &int1);
+                dscal_(&n, &tmp_dbl, &q[ldq*(i+1)], &int1);
+                iconj = 1;
+            } else {
+                iconj = 0;
+            }
+        }
+    }
+    // 10
+
+    dgemv_("T", &n, &n, &dbl1, q, &ldq, bounds, &int1, &dbl0, workl, &int1);
+
+    //  Compute the Ritz estimates
+
+    iconj = 0;
+    for (i = 0; i < n; i++)
+    {
+        if (fabs(ritzi[i]) == 0.0)
+        {
+
+            //  Real eigenvalue case
+
+            bounds[i] = *rnorm * fabs(workl[i]);
+
+        } else {
+
+            //  Complex conjugate pair case. Note that
+            //  since the real and imaginary part of
+            //  the eigenvector are stored in consecutive
+            //  columns, we need to take the magnitude
+            //  of the last components of the two vectors
+
+            if (iconj == 0)
+            {
+                bounds[i] = *rnorm * hypot(workl[i], workl[i+1]);
+                bounds[i+1] = bounds[i];
+                iconj = 1;
+            } else {
+                iconj = 0;
+            }
+        }
+    }
+    // 20
+
+    return;
+}
+
+void
+dnaitr(struct ARPACK_arnoldi_update_vars_d *V, int k, int np, double* resid, double* rnorm,
+       double* v, int ldv, double* h, int ldh, int* ipntr, double* workd)
+{
+    int i = 0, infol, ipj, irj, ivj, jj, n, tmp_int;
+    double smlnum = unfl * ( V->n / ulp);
+    const double sq2o2 = sqrt(2.0) / 2.0;
+
+    int int1 = 1;
+    double dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0, temp1, tst1;
+
+    n = V->n;  // n is constant, this is just for typing convenience
+    ipj = 0;
+    irj = ipj + n;
+    ivj = irj + n;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        //  Initial call to this routine
+
+        V->aitr_j = k;
+        V->info = 0;
+        V->aitr_step3 = 0;
+        V->aitr_step4 = 0;
+        V->aitr_orth1 = 0;
+        V->aitr_orth2 = 0;
+        V->aitr_restart = 0;
+    }
+
+    //  When in reverse communication mode one of:
+    //  STEP3, STEP4, ORTH1, ORTH2, RSTART
+    //  will be .true. when ....
+    //  STEP3: return from computing OP*v_{j}.
+    //  STEP4: return from computing B-norm of OP*v_{j}
+    //  ORTH1: return from computing B-norm of r_{j+1}
+    //  ORTH2: return from computing B-norm of correction to the residual vector.
+    //  RSTART: return from OP computations needed by dgetv0.
+
+    if (V->aitr_step3) { goto LINE50; }
+    if (V->aitr_step4) { goto LINE60; }
+    if (V->aitr_orth1) { goto LINE70; }
+    if (V->aitr_orth2) { goto LINE90; }
+    if (V->aitr_restart) { goto LINE30; }
+
+    //  Else this is the first step
+
+    //
+    //         A R N O L D I     I T E R A T I O N     L O O P
+    //
+    //  Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1)
+
+LINE1000:
+
+    //  STEP 1: Check if the B norm of j-th residual
+    //  vector is zero. Equivalent to determining whether
+    //  an exact j-step Arnoldi factorization is present.
+
+    V->aitr_betaj = *rnorm;
+
+    if (*rnorm > 0.0) { goto LINE40; }
+
+    //  Invariant subspace found, generate a new starting
+    //  vector which is orthogonal to the current Arnoldi
+    //  basis and continue the iteration.
+
+    V->aitr_betaj = 0.0;
+    V->getv0_itry = 1;
+
+LINE20:
+    V->aitr_restart = 1;
+    V->ido = ido_FIRST;
+
+LINE30:
+
+    // If in reverse communication mode and aitr_restart = 1, flow returns here.
+
+    dgetv0(V, 0, n, V->aitr_j, v, ldv, resid, rnorm, ipntr, workd);
+
+    if (V->ido != ido_DONE) { return; }
+    V->aitr_ierr = V->info;
+    if (V->aitr_ierr < 0)
+    {
+        V->getv0_itry += 1;
+        if (V->getv0_itry <= 3) { goto LINE20; }
+
+        //  Give up after several restart attempts.
+        //  Set INFO to the size of the invariant subspace
+        //  which spans OP and exit.
+
+        V->info = V->aitr_j;
+        V->ido = ido_DONE;
+        return;
+    }
+
+LINE40:
+
+    //  STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm
+    //  Note that p_{j} = B*r_{j-1}. In order to avoid overflow
+    //  when reciprocating a small RNORM, test against lower
+    //  machine bound.
+
+    dcopy_(&n, resid, &int1, &v[ldv*(V->aitr_j)], &int1);
+    if (*rnorm >= unfl)
+    {
+        temp1 = 1.0 / *rnorm;
+        dscal_(&n, &temp1, &v[ldv*(V->aitr_j)], &int1);
+        dscal_(&n, &temp1, &workd[ipj], &int1);
+    } else {
+        dlascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &v[ldv*(V->aitr_j)], &n, &infol);
+        dlascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &workd[ipj], &n, &infol);
+    }
+
+    //  STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j}
+    //  Note that this is not quite yet r_{j}. See STEP 4
+
+    V->aitr_step3 = 1;
+    dcopy_(&n, &v[ldv*(V->aitr_j)], &int1, &workd[ivj], &int1);
+    ipntr[0] = ivj;
+    ipntr[1] = irj;
+    ipntr[2] = ipj;
+    V->ido = ido_OPX;
+
+    //  Exit in order to compute OP*v_{j}
+
+    return;
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  WORKD(IRJ:IRJ+N-1) := OP*v_{j}
+    //  if step3 = .true.
+
+    V->aitr_step3 = 0;
+
+    //  Put another copy of OP*v_{j} into RESID.
+
+    dcopy_(&n, &workd[irj], &int1, resid, &int1);
+
+    //  STEP 4:  Finish extending the Arnoldi
+    //           factorization to length j.
+
+    if (V->bmat)
+    {
+        V->aitr_step4 = 1;
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*OP*v_{j}
+
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE60:
+
+    //  Back from reverse communication;
+    //  WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}
+    //  if step4 = .true.
+
+    V->aitr_step4 = 0;
+
+    //  The following is needed for STEP 5.
+    //  Compute the B-norm of OP*v_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_wnorm = ddot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_wnorm = sqrt(fabs(V->aitr_wnorm));
+    } else {
+        V->aitr_wnorm = dnrm2_(&n, resid, &int1);
+    }
+
+    //  Compute the j-th residual corresponding
+    //  to the j step factorization.
+    //  Use Classical Gram Schmidt and compute:
+    //  w_{j} <-  V_{j}^T * B * OP * v_{j}
+    //  r_{j} <-  OP*v_{j} - V_{j} * w_{j}
+
+    //  Compute the j Fourier coefficients w_{j}
+    //  WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.
+    tmp_int = V->aitr_j + 1;
+    dgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &h[ldh*(V->aitr_j)], &int1);
+
+    //  Orthogonalize r_{j} against V_{j}.
+    //  RESID contains OP*v_{j}. See STEP 3.
+
+    dgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &h[ldh*(V->aitr_j)], &int1, &dbl1, resid, &int1);
+
+    if (V->aitr_j > 0) { h[V->aitr_j + ldh*(V->aitr_j-1)] = V->aitr_betaj; }
+
+    V->aitr_orth1 = 1;
+    if (V->bmat)
+    {
+        dcopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}
+
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE70:
+
+    //  Back from reverse communication if ORTH1 = .true.
+    //  WORKD(IPJ:IPJ+N-1) := B*r_{j}.
+
+    V->aitr_orth1 = 0;
+
+    //  Compute the B-norm of r_{j}.
+
+    if (V->bmat)
+    {
+        *rnorm = ddot_(&n, resid, &int1, &workd[ipj], &int1);
+        *rnorm = sqrt(fabs(*rnorm));
+    } else {
+        *rnorm = dnrm2_(&n, resid, &int1);
+    }
+
+    //  STEP 5: Re-orthogonalization / Iterative refinement phase
+    //  Maximum NITER_ITREF tries.
+    //
+    //           s      = V_{j}^T * B * r_{j}
+    //           r_{j}  = r_{j} - V_{j}*s
+    //           alphaj = alphaj + s_{j}
+    //
+    //  The stopping criteria used for iterative refinement is
+    //  discussed in Parlett's book SEP, page 107 and in Gragg &
+    //  Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.
+    //  Determine if we need to correct the residual. The goal is
+    //  to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||
+    //  The following test determines whether the sine of the
+    //  angle between  OP*x and the computed residual is less
+    //  than or equal to 0.7071.
+
+    if (*rnorm > sq2o2*V->aitr_wnorm) { goto LINE100; }
+    V->aitr_iter = 0;
+
+    //  Enter the Iterative refinement phase. If further
+    //  refinement is necessary, loop back here. The loop
+    //  variable is ITER. Perform a step of Classical
+    //  Gram-Schmidt using all the Arnoldi vectors V_{j}
+
+LINE80:
+
+    //  Compute V_{j}^T * B * r_{j}.
+    //  WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1).
+    tmp_int = V->aitr_j + 1;
+    dgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &workd[irj], &int1);
+
+    //  Compute the correction to the residual:
+    //  r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).
+    //  The correction to H is v(:,1:J)*H(1:J,1:J)
+    //  + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.
+
+    dgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &workd[irj], &int1, &dbl1, resid, &int1);
+    daxpy_(&tmp_int, &dbl1, &workd[irj], &int1, &h[ldh*(V->aitr_j)], &int1);
+
+    V->aitr_orth2 = 1;
+
+    if (V->bmat)
+    {
+        dcopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}.
+        //  r_{j} is the corrected residual.
+
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE90:
+
+    //  Back from reverse communication if ORTH2 = .true.
+
+    //  Compute the B-norm of the corrected residual r_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_rnorm1 = ddot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_rnorm1 = sqrt(fabs(V->aitr_rnorm1));
+    } else {
+        V->aitr_rnorm1 = dnrm2_(&n, resid, &int1);
+    }
+
+    //  Determine if we need to perform another
+    //  step of re-orthogonalization.
+
+    if (V->aitr_rnorm1 > sq2o2*(*rnorm))
+    {
+
+        //  No need for further refinement.
+        //  The cosine of the angle between the
+        //  corrected residual vector and the old
+        //  residual vector is greater than 0.717
+        //  In other words the corrected residual
+        //  and the old residual vector share an
+        //  angle of less than arcCOS(0.717)
+
+        *rnorm = V->aitr_rnorm1;
+
+    } else {
+
+        //  Another step of iterative refinement step
+        //  is required.
+
+        *rnorm = V->aitr_rnorm1;
+        V->aitr_iter += 1;
+        if (V->aitr_iter < 2) { goto LINE80; }
+
+        //  Otherwise RESID is numerically in the span of V
+
+        for (jj = 0; jj < n; jj++)
+        {
+            resid[jj] = 0.0;
+        }
+        *rnorm = 0.0;
+    }
+
+    // Branch here directly if iterative refinement
+    // wasn't necessary or after at most NITER_REF
+    // steps of iterative refinement.
+
+LINE100:
+
+    V->aitr_restart = 0;
+    V->aitr_orth2 = 0;
+
+    //  STEP 6: Update  j = j+1;  Continue
+
+    V->aitr_j += 1;
+    if (V->aitr_j >= k + np)
+    {
+        V->ido = ido_DONE;
+        for (i = (k > 0 ? k-1 : k); i < k + np - 1; i++)
+        {
+
+            //  Check for splitting and deflation.
+            //  Use a standard test as in the QR algorithm
+            //  REFERENCE: LAPACK subroutine dlahqr
+
+            tst1 = fabs(h[i + ldh*i]) + fabs(h[i+1 + ldh*(i+1)]);
+            if (tst1 == 0.0)
+            {
+                tmp_int = k + np;
+                tst1 = dlanhs_("1", &tmp_int, h, &ldh, &workd[n]);
+            }
+            if (fabs(h[i+1 + ldh*i]) <= fmax(ulp*tst1, smlnum))
+            {
+                h[i+1 + ldh*i] = 0.0;
+            }
+        }
+        // 110
+        return;
+    }
+    goto LINE1000;
+
+}
+
+
+void
+dnapps(int n, int* kev, int np, double* shiftr, double* shifti, double* v,
+       int ldv, double* h, int ldh, double* resid, double* q, int ldq, double* workl,
+       double* workd)
+{
+    int cconj;
+    int i, ir, j, jj, int1 = 1, istart, iend = 0, nr, tmp_int;
+    int kplusp = *kev + np;
+    double smlnum = unfl * ( n / ulp);
+    double c, f, g, h11, h21, h12, h22, h32, s, sigmar, sigmai, r, t, tau, tst1;
+    double dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0;
+    double u[3] = { 0.0 };
+
+    //  Initialize Q to the identity to accumulate
+    //  the rotations and reflections
+    dlaset_("A", &kplusp, &kplusp, &dbl0, &dbl1, q, &ldq);
+
+    //  Quick return if there are no shifts to apply
+
+    if (np == 0) { return; }
+
+    //  Chase the bulge with the application of each
+    //  implicit shift. Each shift is applied to the
+    //  whole matrix including each block.
+
+    cconj = 0;
+
+    // Loop over the shifts
+
+    for (jj = 0; jj < np; jj++)
+    {
+        sigmar = shiftr[jj];
+        sigmai = shifti[jj];
+
+        if (cconj)
+        {
+
+            // Skip flag is on; turn it off and proceed to the next shift.
+
+            cconj = 0;
+            continue;
+
+        } else if ((jj < np - 1) && fabs(sigmai) != 0.0) {
+
+            // This shift has nonzero imaginary part, so we will apply
+            // together with the next one; turn on the skip flag.
+
+            cconj = 1;
+
+        } else if ((jj == np - 1) && (fabs(sigmai) != 0.0)) {
+
+            // We have one block left but the shift has nonzero imaginary part.
+            // Don't apply it and reduce the number of shifts by incrementing
+            // kev by one.
+
+            *kev += 1;
+            continue;
+        }
+
+        // if sigmai = 0 then
+        //    Apply the jj-th shift ...
+        // else
+        //    Apply the jj-th and (jj+1)-th together ...
+        //    (Note that jj < np at this point in the code)
+        // end
+        // to the current block of H
+
+        istart = 0;
+        while (istart < kplusp - 1)
+        {
+            for (iend = istart; iend < kplusp - 1; iend++)
+            {
+                tst1 = fabs(h[iend + (iend * ldh)]) + fabs(h[iend + 1 + (iend + 1) * ldh]);
+                if (tst1 == 0.0)
+                {
+                    tmp_int = kplusp - jj;
+                    tst1 = dlanhs_("1", &tmp_int, h, &ldh, workl);
+                }
+                if (fabs(h[iend+1 + (iend * ldh)]) <= fmax(smlnum, ulp * tst1))
+                {
+                    break;
+                }
+            }
+            if (istart == iend)
+            {
+                istart += 1;
+                continue;
+            } else if  ((istart + 1 == iend) && fabs(sigmai) > 0.0) {
+                istart += 2;
+                continue;
+            } else {
+                h[iend+1 + (iend * ldh)] = 0.0;
+            }
+
+            // We have a block [istart, iend] inclusive.
+            h11 = h[istart + istart * ldh];
+            h21 = h[istart + 1 + istart * ldh];
+
+            if (fabs(sigmai) == 0.0)
+            {
+
+                f = h11 - sigmar;
+                g = h21;
+                for (i = istart; i < iend; i++)
+                {
+                    dlartgp_(&f, &g, &c, &s, &r);
+                    if (i > istart)
+                    {
+                        h[i + (i - 1) * ldh] = r;
+                        h[i + 1 + (i - 1) * ldh] = 0.0;
+                    }
+                    tmp_int = kplusp - i;
+                    drot_(&tmp_int, &h[i + ldh*i], &ldh, &h[i + 1 + ldh*i], &ldh, &c, &s);
+                    tmp_int = (i+2 > iend ? iend : i + 2) + 1;
+                    drot_(&tmp_int, &h[ldh*i], &int1, &h[ldh*(i+1)], &int1, &c, &s);
+                    tmp_int = (i+jj+2 > kplusp ? kplusp : i + jj + 2);
+                    drot_(&tmp_int, &q[ldq*i], &int1, &q[ldq*(i+1)], &int1, &c, &s);
+
+                    if (i < iend - 1)
+                    {
+                        f = h[i+1 + i * ldh];
+                        g = h[i+2 + i * ldh];
+                    }
+                }
+            } else {
+
+                h12 = h[istart + ldh*(istart + 1)];
+                h22 = h[istart + 1 + ldh*(istart + 1)];
+                h32 = h[istart + 2 + ldh*(istart + 1)];
+
+                s = 2.0*sigmar;
+                t = hypot(sigmar, sigmai);
+                u[0] = (h11*(h11 - s) + t*t) / h21 + h12;
+                u[1] = h11 + h22 - s;
+                u[2] = h32;
+
+                for (i = istart; i < iend; i++)
+                {
+                    nr = iend - i + 1;
+                    nr = (nr > 3? 3 : nr);
+                    dlarfg_(&nr, &u[0], &u[1], &int1, &tau);
+                    if (i > istart)
+                    {
+                        h[i + (i - 1) * ldh] = u[0];
+                        h[i + 1 + (i - 1) * ldh] = 0.0;
+                        if (i < iend - 1) { h[i + 2 + (i - 1) * ldh] = 0.0; }
+                    }
+                    u[0] = 1.0;
+
+                    tmp_int = kplusp - i;
+                    dlarf_("L", &nr, &tmp_int, u, &int1, &tau, &h[i + ldh*i], &ldh, workl);
+                    ir = (i + 3 > iend ? iend : i + 3) + 1;
+                    dlarf_("R", &ir, &nr, u, &int1, &tau, &h[ldh*i], &ldh, workl);
+                    dlarf_("R", &kplusp, &nr, u, &int1, &tau, &q[ldq*i], &ldq, workl);
+                    if (i < iend - 1)
+                    {
+                        u[0] = h[i+1 + i * ldh];
+                        u[1] = h[i+2 + i * ldh];
+                        if (i < iend-2) { u[2] = h[i+3 + i * ldh]; }
+                    }
+                }
+            }
+            istart = iend + 1;
+        }
+    }
+    //  Perform a similarity transformation that makes
+    //  sure that H will have non negative sub diagonals
+
+    for (j = 0; j < *kev; j++)
+    {
+        if (h[j+1 + ldh*j] < 0.0)
+        {
+            tmp_int = kplusp - j;
+            dscal_(&tmp_int, &dblm1, &h[j+1 + ldh*j], &ldh);
+            tmp_int = (j+3 > kplusp ? kplusp : j+3);
+            dscal_(&tmp_int, &dblm1, &h[ldh*(j+1)], &int1);
+            tmp_int = (j+np+2 > kplusp ? kplusp : j+np+2);
+            dscal_(&tmp_int, &dblm1, &q[ldq*(j+1)], &int1);
+        }
+    }
+    // 120
+
+    for (i = 0; i < *kev; i++)
+    {
+
+        //  Final check for splitting and deflation.
+        //  Use a standard test as in the QR algorithm
+        //  REFERENCE: LAPACK subroutine dlahqr
+
+        tst1 = fabs(h[i + ldh*i]) + fabs(h[i+1 + ldh*(i+1)]);
+        if (tst1 == 0.0)
+        {
+            tst1 = dlanhs_("1", kev, h, &ldh, workl);
+        }
+        if (h[i+1 + ldh*i] <= fmax(ulp*tst1, smlnum))
+        {
+            h[i+1 + ldh*i] = 0.0;
+        }
+    }
+    // 130
+
+    //  Compute the (kev+1)-st column of (V*Q) and
+    //  temporarily store the result in WORKD(N+1:2*N).
+    //  This is needed in the residual update since we
+    //  cannot GUARANTEE that the corresponding entry
+    //  of H would be zero as in exact arithmetic.
+
+    if (h[*kev + ldh*(*kev-1)] > 0.0)
+    {
+        dgemv_("N", &n, &kplusp, &dbl1, v, &ldv, &q[(*kev)*ldq], &int1, &dbl0, &workd[n], &int1);
+    }
+
+    //  Compute column 1 to kev of (V*Q) in backward order
+    //  taking advantage of the upper Hessenberg structure of Q.
+
+    for (i = 0; i < *kev; i++)
+    {
+        tmp_int = kplusp - i;
+        dgemv_("N", &n, &tmp_int, &dbl1, v, &ldv, &q[(*kev-i-1)*ldq], &int1, &dbl0, workd, &int1);
+        dcopy_(&n, workd, &int1, &v[(kplusp-i-1)*ldv], &int1);
+    }
+
+    //   Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev).
+
+    for (i = 0; i < *kev; i++)
+    {
+        dcopy_(&n, &v[(kplusp-*kev+i)*ldv], &int1, &v[i*ldv], &int1);
+    }
+
+    //  Copy the (kev+1)-st column of (V*Q) in the appropriate place
+
+    if (h[*kev + ldh*(*kev-1)] > 0.0){
+        dcopy_(&n, &workd[n], &int1, &v[ldv*(*kev)], &int1);
+    }
+
+    //  Update the residual vector:
+    //     r <- sigmak*r + betak*v(:,kev+1)
+    //  where
+    //     sigmak = (e_{kplusp}'*Q)*e_{kev}
+    //     betak = e_{kev+1}'*H*e_{kev}
+
+    dscal_(&n, &q[kplusp-1 + ldq*(*kev-1)], resid, &int1);
+
+    if (h[*kev + ldh*(*kev-1)] > 0.0)
+    {
+        daxpy_(&n, &h[*kev + ldh*(*kev-1)], &v[ldv*(*kev)], &int1, resid, &int1);
+    }
+
+    return;
+
+}
+
+
+void
+dngets(struct ARPACK_arnoldi_update_vars_d *V, int* kev, int* np,
+       double* ritzr, double* ritzi, double* bounds)
+{
+
+    //  LM, SM, LR, SR, LI, SI case.
+    //  Sort the eigenvalues of H into the desired order
+    //  and apply the resulting order to BOUNDS.
+    //  The eigenvalues are sorted so that the wanted part
+    //  are always in the last KEV locations.
+    //  We first do a pre-processing sort in order to keep
+    //  complex conjugate pairs together
+
+    switch (V->which)
+    {
+        case which_LM:
+            dsortc(which_LR, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_SM:
+            dsortc(which_SR, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_LR:
+            dsortc(which_LM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_SR:
+            dsortc(which_SM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_LI:
+            dsortc(which_LM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_SI:
+            dsortc(which_SM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        default:
+            dsortc(which_LR, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+    }
+    dsortc(V->which, 1, *kev + *np, ritzr, ritzi, bounds);
+
+    //  Increase KEV by one if the ( ritzr(np),ritzi(np) )
+    //  = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero
+    //  Accordingly decrease NP by one. In other words keep
+    //  complex conjugate pairs together.
+
+    if ((ritzr[*np] - ritzr[*np-1] == 0.0) && (ritzi[*np] + ritzi[*np-1] == 0.0))
+    {
+        *np -= 1;
+        *kev += 1;
+    }
+
+    if (V->shift == 1)
+    {
+
+        //  Sort the unwanted Ritz values used as shifts so that
+        //  the ones with largest Ritz estimates are first
+        //  This will tend to minimize the effects of the
+        //  forward instability of the iteration when they shifts
+        //  are applied in subroutine dnapps.
+        //  Be careful and use 'SR' since we want to sort BOUNDS!
+
+        dsortc(which_SR, 1, *np, bounds, ritzr, ritzi);
+    }
+
+    return;
+}
+
+void
+dgetv0(struct ARPACK_arnoldi_update_vars_d *V, int initv, int n, int j,
+       double* v, int ldv, double* resid, double* rnorm, int* ipntr, double* workd)
+{
+    int jj, int1 = 1;
+    const double sq2o2 = sqrt(2.0) / 2.0;
+    double dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->info = 0;
+        V->getv0_iter = 0;
+        V->getv0_first = 0;
+        V->getv0_orth = 0;
+
+        //  Possibly generate a random starting vector in RESID
+        //  Skip if this the return of ido_RANDOM.
+
+        if (!(initv))
+        {
+            // Request a random vector from the user into resid
+            V->ido = ido_RANDOM;
+            return;
+        } else {
+            V->ido = ido_RANDOM;
+        }
+    }
+
+    // Back from random vector generation
+    if (V->ido == ido_RANDOM)
+    {
+        //  Force the starting vector into the range of OP to handle
+        //  the generalized problem when B is possibly (singular).
+
+        if (V->getv0_itry == 1)
+        {
+            ipntr[0] = 0;
+            ipntr[1] = n;
+            dcopy_(&n, resid, &int1, workd, &int1);
+            V->ido = ido_RANDOM_OPX;
+            return;
+        } else if ((V->getv0_itry > 1) && (V->bmat == 1))
+        {
+            dcopy_(&n, resid, &int1, &workd[n], &int1);
+        }
+    }
+
+    //  Back from computing OP*(initial-vector)
+
+    if (V->getv0_first) { goto LINE20; }
+
+    //  Back from computing OP*(orthogonalized-vector)
+
+    if (V->getv0_orth) { goto LINE40; }
+
+    //  Starting vector is now in the range of OP; r = OP*r;
+    //  Compute B-norm of starting vector.
+
+    V->getv0_first = 1;
+    if (V->getv0_itry == 1)
+    {
+        dcopy_(&n, &workd[n], &int1, resid, &int1);
+    }
+    if (V->bmat)
+    {
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE20:
+
+    V->getv0_first = 0;
+    if (V->bmat)
+    {
+        V->getv0_rnorm0 = ddot_(&n, resid, &int1, workd, &int1);
+        V->getv0_rnorm0 = sqrt(fabs(V->getv0_rnorm0));
+    } else {
+        V->getv0_rnorm0 = dnrm2_(&n, resid, &int1);
+    }
+    *rnorm = V->getv0_rnorm0;
+
+    //  Exit if this is the very first Arnoldi step
+
+    if (j == 0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //  Otherwise need to B-orthogonalize the starting vector against
+    //  the current Arnoldi basis using Gram-Schmidt with iter. ref.
+    //  This is the case where an invariant subspace is encountered
+    //  in the middle of the Arnoldi factorization.
+    //
+    //        s = V^{T}*B*r;   r = r - V*s;
+    //
+    //  Stopping criteria used for iter. ref. is discussed in
+    //  Parlett's book, page 107 and in Gragg & Reichel TOMS paper.
+
+    V->getv0_orth = 1;
+
+LINE30:
+
+    dgemv_("T", &n, &j, &dbl1, v, &ldv, workd, &int1, &dbl0, &workd[n], &int1);
+    dgemv_("N", &n, &j, &dblm1, v, &ldv, &workd[n], &int1, &dbl1, resid, &int1);
+
+    //  Compute the B-norm of the orthogonalized starting vector
+
+    if (V->bmat)
+    {
+        dcopy_(&n, resid, &int1, &workd[n], &int1);
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE40:
+    if (V->bmat)
+    {
+        *rnorm = ddot_(&n, resid, &int1, workd, &int1);
+        *rnorm = sqrt(fabs(*rnorm));
+    } else {
+        *rnorm = dnrm2_(&n, resid, &int1);
+    }
+
+    //  Check for further orthogonalization.
+
+    if (*rnorm > sq2o2*V->getv0_rnorm0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->getv0_iter += 1;
+    if (V->getv0_iter < 5)
+    {
+
+        //  Perform iterative refinement step
+
+        V->getv0_rnorm0 = *rnorm;
+        goto LINE30;
+    } else {
+
+        //  Iterative refinement step "failed"
+
+        for (jj = 0; jj < n; jj++) { resid[jj] = 0.0; }
+        *rnorm = 0.0;
+        V->info = -1;
+    }
+
+    V->ido = ido_DONE;
+
+    return;
+}
+
+void
+dsortc(const enum ARPACK_which w, const int apply, const int n, double* xreal, double* ximag, double* y)
+{
+    int i, igap, j;
+    double temp;
+    ARPACK_compare_cfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortc_LM;
+            break;
+        case which_SM:
+            f = sortc_SM;
+            break;
+        case which_LR:
+            f = sortc_LR;
+            break;
+        case which_LI:
+            f = sortc_LI;
+            break;
+        case which_SR:
+            f = sortc_SR;
+            break;
+        case which_SI:
+            f = sortc_SI;
+            break;
+        default:
+            f = sortc_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(xreal[j], ximag[j], xreal[j+igap], ximag[j+igap]))
+            {
+                if (j < 0) { break; }
+                temp = xreal[j];
+                xreal[j] = xreal[j+igap];
+                xreal[j+igap] = temp;
+                temp = ximag[j];
+                ximag[j] = ximag[j+igap];
+                ximag[j+igap] = temp;
+
+                if (apply)
+                {
+                    temp = y[j];
+                    y[j] = y[j+igap];
+                    y[j+igap] = temp;
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+}
+
+// The void casts are to avoid compiler warnings for unused parameters
+int
+sortc_LM(const double xre, const double xim, const double xreigap, const double ximigap)
+{
+    return (hypot(xre, xim) > hypot(xreigap, ximigap));
+}
+
+int
+sortc_SM(const double xre, const double xim, const double xreigap, const double ximigap)
+{
+    return (hypot(xre, xim) < hypot(xreigap, ximigap));
+}
+
+int
+sortc_LR(const double xre, const double xim, const double xreigap, const double ximigap)
+{
+    (void)xim; (void)ximigap;
+    return (xre > xreigap);
+}
+
+int
+sortc_SR(const double xre, const double xim, const double xreigap, const double ximigap)
+{
+    (void)xim; (void)ximigap;
+    return (xre < xreigap);
+}
+
+int
+sortc_LI(const double xre, const double xim, const double xreigap, const double ximigap)
+{
+    (void)xre; (void)xreigap;
+    return (fabs(xim) > fabs(ximigap));
+}
+
+int
+sortc_SI(const double xre, const double xim, const double xreigap, const double ximigap)
+{
+    (void)xre; (void)xreigap;
+    return (fabs(xim) < fabs(ximigap));
+}
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.h
new file mode 100644
index 0000000000..e22bec06a6
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double.h
@@ -0,0 +1,32 @@
+#ifndef _ARPACK_N_DOUBLE_H
+#define _ARPACK_N_DOUBLE_H
+
+#include "_arpack.h"
+
+// BLAS Routines used
+void daxpy_(int* n, double* alpha, double* x, int* incx, double* y, int* incy);
+void dcopy_(int* n, double* x, int* incx, double* y, int* incy);
+double ddot_(int* n, double* x, int* incx, double* y, int* incy);
+void dger_(int* m, int* n, double* alpha, double* x, int* incx, double* y, int* incy, double* a, int* lda);
+double dnrm2_(int* n, double* x, int* incx);
+void dscal_(int* n, double* alpha, double* x, int* incx);
+void dgemv_(char* trans, int* m, int* n, double* alpha, double* a, int* lda, double* x, int* incx, double* beta, double* y, int* incy);
+void drot_(int* n, double* x, int* incx, double* y, int* incy, double* c, double* s);
+void dtrmm_(char* side, char* uplo, char* transa, char* diag, int* m, int* n, double* alpha, double* a, int* lda, double* b, int* ldb);
+
+// LAPACK Routines used
+void dgeqr2_(int* m, int* n, double* a, int* lda, double* tau, double* work, int* info);
+void dlacpy_(char* uplo, int* m, int* n, double* a, int* lda, double* b, int* ldb);
+void dlahqr_(int* wantt, int* wantz, int* n, int* ilo, int* ihi, double* h, int* ldh, double* wr, double* wi, int* iloz, int* ihiz, double* z, int* ldz, int* info );
+double dlanhs_(char* norm, int* n, double* a, int* lda, double* work);
+void dlaset_(char* uplo, int* m, int* n, double* alpha, double* beta, double* a, int* lda);
+void dlarf_(char* side, int* m, int* n, double* v, int* incv, double* tau, double* c, int* ldc, double* work);
+void dlarfg_(int* n, double* alpha, double* x, int* incx, double* tau);
+void dlartg_(double* f, double* g, double* c, double* s, double* r);
+void dlartgp_(double* f, double* g, double* c, double* s, double* r);
+void dlascl_(char* mtype, int* kl, int* ku, double* cfrom, double* cto, int* m, int* n, double* a, int* lda, int* info);
+void dorm2r_(char* side, char* trans, int* m, int* n, int* k, double* a, int* lda, double* tau, double* c, int* ldc, double* work, int* info);
+void dtrevc_(char* side, char* howmny, int* select, int* n, double* t, int* ldt, double* vl, int* ldvl, double* vr, int* ldvr, int* mm, int* m, double* work, int* info);
+void dtrsen_(char* job, char* compq, int* select, int* n, double* t, int* ldt, double* q, int* ldq, double* wr, double* wi, int* m, double* s, double* sep, double* work, int* lwork, int* iwork, int* liwork, int* info);
+
+#endif
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.c b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.c
new file mode 100644
index 0000000000..ff85aa3417
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.c
@@ -0,0 +1,1861 @@
+#include "_arpack_n_double_complex.h"
+
+typedef int ARPACK_compare_cfunc(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+typedef int ARPACK_compare_rfunc(const double, const double);
+
+static const double unfl = 2.2250738585072014e-308;
+// static const double ovfl = 1.0 / 2.2250738585072014e-308;
+static const double ulp = 2.220446049250313e-16;
+
+static ARPACK_CPLX_TYPE zdotc_(const int* n, const ARPACK_CPLX_TYPE* restrict x, const int* incx, const ARPACK_CPLX_TYPE* restrict y, const int* incy);
+static void zgetv0(struct ARPACK_arnoldi_update_vars_d*, int, int, int, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, double*, int*, ARPACK_CPLX_TYPE*);
+static void znaup2(struct ARPACK_arnoldi_update_vars_d*, ARPACK_CPLX_TYPE* , ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, int*, ARPACK_CPLX_TYPE*, double*);
+static void znaitr(struct ARPACK_arnoldi_update_vars_d*, int, int, ARPACK_CPLX_TYPE*, double*, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, int, int*, ARPACK_CPLX_TYPE*);
+static void znapps(int, int*, int, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*);
+static void zneigh(double*, int, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*, int, ARPACK_CPLX_TYPE*, double*, int*);
+static void zngets(struct ARPACK_arnoldi_update_vars_d*, int*, int*, ARPACK_CPLX_TYPE*, ARPACK_CPLX_TYPE*);
+static void zsortc(const enum ARPACK_which w, const int apply, const int n, ARPACK_CPLX_TYPE* x, ARPACK_CPLX_TYPE* y);
+static int sortc_LM(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+static int sortc_SM(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+static int sortc_LR(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+static int sortc_SR(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+static int sortc_LI(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+static int sortc_SI(const ARPACK_CPLX_TYPE, const ARPACK_CPLX_TYPE);
+
+enum ARPACK_neupd_type {
+    REGULAR,
+    SHIFTI,
+    REALPART,
+    IMAGPART
+};
+
+
+void
+ARPACK_zneupd(struct ARPACK_arnoldi_update_vars_d *V, int rvec, int howmny, int* select,
+       ARPACK_CPLX_TYPE* d, ARPACK_CPLX_TYPE* z, int ldz, ARPACK_CPLX_TYPE sigma,
+       ARPACK_CPLX_TYPE* workev, ARPACK_CPLX_TYPE* resid, ARPACK_CPLX_TYPE* v, int ldv,
+       int* ipntr, ARPACK_CPLX_TYPE* workd, ARPACK_CPLX_TYPE* workl, double* rwork)
+{
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    int ibd, ih, iheig, ihbds, iuptri, invsub, irz, iwev, j, jj;
+    int bounds, k, ldh, ldq, np, numcnv, outncv, reord, ritz, wr;
+    int ierr = 0, int1 = 1, tmp_int = 0, nconv2 = 0;
+    double conds, sep, temp1, rtemp;
+    ARPACK_CPLX_TYPE rnorm, temp;
+    ARPACK_CPLX_TYPE cdbl0 = ARPACK_cplx(0.0, 0.0);
+    ARPACK_CPLX_TYPE cdbl1 = ARPACK_cplx(1.0, 0.0);
+    ARPACK_CPLX_TYPE cdblm1 = ARPACK_cplx(-1.0, 0.0);
+    ARPACK_CPLX_TYPE vl[1] = { cdbl0 };
+    enum ARPACK_neupd_type TYP;
+
+    if (V->nconv <= 0) {
+        ierr = -14;
+    } else if (V->n <= 0) {
+        ierr = -1;
+    } else if (V->nev <= 0) {
+        ierr = -2;
+    } else if ((V->ncv <= V->nev + 1) || (V->ncv > V->n)) {
+        ierr = -3;
+    } else if ((V->which > 5) || (V->which < 0)) {
+        ierr = -5;
+    } else if ((V->bmat != 0) && (V->bmat != 1)) {
+        ierr = -6;
+    } else if ((rvec) && ((howmny < 0) || (howmny > 2))) {
+        ierr = -13;
+    } else if (howmny == 2) {
+        ierr = -12;  // NotImplementedError
+    }
+
+    if ((V->mode == 1) || (V->mode == 2)) {
+        TYP = REGULAR;
+    } else if (V->mode == 3) {
+        TYP = SHIFTI;
+    } else {
+        ierr = -10;
+    }
+
+    if ((V->mode == 1) && (V->bmat)) { ierr = -11; }
+
+    if (ierr != 0) {
+        V->info = ierr;
+        return;
+    }
+
+    //  Pointer into WORKL for address of H, RITZ, WORKEV, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //  workl(1:ncv*ncv) := generated Hessenberg matrix
+    //  workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values
+    //  workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds
+
+    //  The following is used and set by ZNEUPD.
+    //  workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed
+    //                                       Ritz values.
+    //  workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed
+    //                                       error bounds of
+    //                                       the Ritz values
+    //  workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper
+    //                                       triangular matrix
+    //                                       for H.
+    //  workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the
+    //                                       associated matrix
+    //                                       representation of
+    //                                       the invariant
+    //                                       subspace for H.
+    //  GRAND total of NCV * ( 3 * NCV + 4 ) locations.
+
+    ih     = ipntr[4];
+    ritz   = ipntr[5];
+    bounds = ipntr[7];
+    ldh = V->ncv;
+    ldq = V->ncv;
+    iheig  = bounds + ldh;
+    ihbds  = iheig  + ldh;
+    iuptri = ihbds  + ldh;
+    invsub = iuptri + ldh*V->ncv;
+    ipntr[8]  = iheig;
+    ipntr[10] = ihbds;
+    ipntr[11] = iuptri;
+    ipntr[12] = invsub;
+    wr = 0;
+    iwev = wr + V->ncv;
+
+    //  irz points to the Ritz values computed
+    //      by _neigh before exiting _naup2.
+    //  ibd points to the Ritz estimates
+    //      computed by _neigh before exiting
+    //      _naup2.
+
+    irz = ipntr[13] + (V->ncv)*(V->ncv);
+    ibd = irz + V->ncv;
+
+    //  RNORM is B-norm of the RESID(1:N).
+
+    rnorm = workl[ih+2];
+    workl[ih+2] = ARPACK_cplx(0.0, 0.0);
+
+    if (rvec) {
+        reord = 0;
+
+        //  Use the temporary bounds array to store indices
+        //  These will be used to mark the select array later
+
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[bounds + j] = ARPACK_cplx(j, 0.0);
+            select[j] = 0;
+        }
+        // 10
+
+        //  Select the wanted Ritz values.
+        //  Sort the Ritz values so that the
+        //  wanted ones appear at the tailing
+        //  NEV positions of workl(irr) and
+        //  workl(iri).  Move the corresponding
+        //  error estimates in workl(ibd)
+        //  accordingly.
+
+        np = V->ncv - V->nev;
+        zngets(V, &V->nev, &np, &workl[irz], &workl[bounds]);
+
+        //  Record indices of the converged wanted Ritz values
+        //  Mark the select array for possible reordering
+
+        numcnv = 0;
+        for (j = 1; j <= V->ncv; j++)
+        {
+            temp1 = fmax(eps23, cabs(workl[irz + V->ncv - j]));
+            jj = (int)creal(workl[bounds + V->ncv - j]);
+
+            if ((numcnv < V->nconv) && (cabs(workl[ibd + jj]) <= V->tol*temp1))
+            {
+                select[jj] = 1;
+                numcnv += 1;
+                if (jj > V->nconv - 1) { reord = 1; }
+            }
+        }
+        // 11
+
+        //  Check the count (numcnv) of converged Ritz values with
+        //  the number (nconv) reported by znaupd.  If these two
+        //  are different then there has probably been an error
+        //  caused by incorrect passing of the znaupd data.
+
+        if (numcnv != V->nconv)
+        {
+            V->info = -15;
+            return;
+        }
+
+        //  Call LAPACK routine zlahqr  to compute the Schur form
+        //  of the upper Hessenberg matrix returned by ZNAUPD .
+        //  Make a copy of the upper Hessenberg matrix.
+        //  Initialize the Schur vector matrix Q to the identity.
+
+        tmp_int = ldh*V->ncv;
+        zcopy_(&tmp_int, &workl[ih], &int1, &workl[iuptri], &int1);
+        zlaset_("A", &V->ncv, &V->ncv, &cdbl0, &cdbl1, &workl[invsub], &ldq);
+        zlahqr_(&int1, &int1, &V->ncv, &int1, &V->ncv, &workl[iuptri], &ldh,
+                &workl[iheig], &int1, &V->ncv, &workl[invsub], &ldq, &ierr);
+        zcopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        if (ierr != 0)
+        {
+            V->info = -8;
+            return;
+        }
+
+        if (reord)
+        {
+
+            //  Reorder the computed upper triangular matrix.
+
+            ztrsen_("N", "V", select, &V->ncv, &workl[iuptri], &ldh, &workl[invsub], &ldq,
+                    &workl[iheig], &nconv2, &conds, &sep, workev, &V->ncv, &ierr);
+
+            if (nconv2 < V->nconv) { V->nconv = nconv2; }
+            if (ierr == 1) {
+                V->info = 1;
+                return;
+            }
+        }
+
+        //  Copy the last row of the Schur basis matrix
+        //  to workl(ihbds).  This vector will be used
+        //  to compute the Ritz estimates of converged
+        //  Ritz values.
+
+        zcopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        //  Place the computed eigenvalues of H into D
+        //  if a spectral transformation was not used.
+
+        if (TYP == REGULAR)
+        {
+            zcopy_(&V->nconv, &workl[iheig], &int1, d, &int1);
+        }
+
+        //  Compute the QR factorization of the matrix representing
+        //  the wanted invariant subspace located in the first NCONV
+        //  columns of workl(invsub,ldq).
+
+        zgeqr2_(&V->ncv, &V->nconv, &workl[invsub], &ldq, workev, &workev[V->ncv], &ierr);
+
+        //  * Postmultiply V by Q using zunm2r.
+        //  * Copy the first NCONV columns of VQ into Z.
+        //  * Postmultiply Z by R.
+        //  The N by NCONV matrix Z is now a matrix representation
+        //  of the approximate invariant subspace associated with
+        //  the Ritz values in workl(iheig). The first NCONV
+        //  columns of V are now approximate Schur vectors
+        //  associated with the upper triangular matrix of order
+        //  NCONV in workl(iuptri).
+
+        zunm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[invsub], &ldq, workev, v, &ldv, &workd[V->n], &ierr);
+        zlacpy_("A", &V->n, &V->nconv, v, &ldv, z, &ldz);
+
+        for (int j = 0; j < V->nconv; j++)
+        {
+
+            //  Perform both a column and row scaling if the
+            //  diagonal element of workl(invsub,ldq) is negative
+            //  I'm lazy and don't take advantage of the upper
+            //  triangular form of workl(iuptri,ldq).
+            //  Note that since Q is orthogonal, R is a diagonal
+            //  matrix consisting of plus or minus ones.
+
+            if (creal(workl[invsub + j*ldq + j]) < 0.0)
+            {
+                zscal_(&V->nconv, &cdblm1, &workl[iuptri + j], &ldq);
+                zscal_(&V->nconv, &cdblm1, &workl[iuptri + j*ldq], &int1);
+            }
+        }
+        // 20
+
+        if (howmny == 0)
+        {
+
+            //  Compute the NCONV wanted eigenvectors of T
+            //  located in workl(iuptri,ldq).
+
+            for (int j = 0; j < V->ncv; j++)
+            {
+                if (j < V->nconv)
+                {
+                    select[j] = 1;
+                } else {
+                    select[j] = 0;
+                }
+            }
+            // 30
+
+            ztrevc_("R", "S", select, &V->ncv, &workl[iuptri], &ldq, vl, &int1,
+                    &workl[invsub], &ldq, &V->ncv, &outncv, workev, rwork, &ierr);
+            if (ierr != 0)
+            {
+                V->info = -9;
+                return;
+            }
+
+            //  Scale the returning eigenvectors so that their
+            //  Euclidean norms are all one. LAPACK subroutine
+            //  ztrevc returns each eigenvector normalized so
+            //  that the element of largest magnitude has
+            //  magnitude 1.
+
+            for (j = 0; j < V->nconv; j++)
+            {
+                rtemp = 1.0 / dznrm2_(&V->ncv, &workl[invsub + j*ldq], &int1);
+                zdscal_(&V->ncv, &rtemp, &workl[invsub + j*ldq], &int1);
+
+                //  Ritz estimates can be obtained by taking
+                //  the inner product of the last row of the
+                //  Schur basis of H with eigenvectors of T.
+                //  Note that the eigenvector matrix of T is
+                //  upper triangular, thus the length of the
+                //  inner product can be set to j.
+                tmp_int = j + 1;
+                workev[j] = zdotc_(&tmp_int, &workl[ihbds], &int1, &workl[invsub + j*ldq], &int1);
+            }
+            // 40
+
+            //  Copy Ritz estimates into workl(ihbds)
+
+            zcopy_(&V->nconv, workev, &int1, &workl[ihbds], &int1);
+
+            //  The eigenvector mactirx Q of T is triangular. Form Z*Q
+
+            ztrmm_("R", "U", "N", "N", &V->n, &V->nconv, &cdbl1, &workl[invsub], &ldq, z, &ldz);
+
+        }
+
+    } else {
+
+        // An approximate invariant subspace is not needed.
+        // Place the Ritz values computed ZNAUPD into D.
+
+        zcopy_(&V->nconv, &workl[ritz], &int1, d, &int1);
+        zcopy_(&V->nconv, &workl[ritz], &int1, &workl[iheig], &int1);
+        zcopy_(&V->nconv, &workl[bounds], &int1, &workl[ihbds], &int1);
+
+    }
+
+    //  Transform the Ritz values and possibly vectors
+    //  and corresponding error bounds of OP to those
+    //  of A*x = lambda*B*x.
+
+    if (TYP == REGULAR)
+    {
+        if (rvec)
+        {
+            zscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+        }
+    } else {
+
+        //    A spectral transformation was used.
+        //  * Determine the Ritz estimates of the
+        //    Ritz values in the original system.
+
+        if (rvec)
+        {
+            zscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+        }
+        for (k = 0; k < V->ncv; k++)
+        {
+#if defined(_MSC_VER)
+            // Complex division is not supported in MSVC, multiply with reciprocal
+            temp = _Cmulcr(conj(workl[iheig + k]), 1.0 / cabs(workl[iheig + k]));
+            workl[ihbds + k] = _Cmulcc(_Cmulcc(workl[ihbds + k], temp), temp);
+#else
+            temp = workl[iheig + k];
+            workl[ihbds + k] = workl[ihbds + k] / temp / temp;
+#endif
+        }
+        // 50
+    }
+
+    //  *  Transform the Ritz values back to the original system.
+    //     For TYPE = 'SHIFTI' the transformation is
+    //              lambda = 1/theta + sigma
+    //  NOTES:
+    //  *The Ritz vectors are not affected by the transformation.
+
+    if (TYP == SHIFTI)
+    {
+        for (k = 0; k < V->nconv; k++)
+        {
+#if defined(_MSC_VER)
+            // Complex division is not supported in MSVC
+            temp = _Cmulcr(conj(workl[iheig + k]), 1.0 / cabs(workl[iheig + k]));
+            d[k] = ARPACK_cplx(creal(temp) + creal(sigma), cimag(temp) + cimag(sigma));
+#else
+            d[k] = 1.0 / workl[iheig + k] + sigma;
+#endif
+        }
+        // 60
+    }
+
+    //  Eigenvector Purification step. Formally perform
+    //  one of inverse subspace iteration. Only used
+    //  for MODE = 3. See reference 3.
+
+    if ((rvec) && (howmny == 0) && (TYP == SHIFTI))
+    {
+
+        //  Purify the computed Ritz vectors by adding a
+        //  little bit of the residual vector:
+        //                       T
+        //           resid(:)*( e    s ) / theta
+        //                       NCV
+        //  where H s = s theta.
+
+        for (j = 0; j < V->nconv; j++)
+        {
+            if ((creal(workl[iheig+j]) != 0.0) || (cimag(workl[iheig+j]) != 0.0))
+            {
+#if defined(_MSC_VER)
+                // Complex division is not supported in MSVC
+                temp = _Cmulcr(conj(workl[iheig + j]), 1.0 / cabs(workl[iheig + j]));
+                workev[j] = _Cmulcc(workl[invsub + j*ldq + V->ncv], temp);
+#else
+                workev[j] = workl[invsub + j*ldq + V->ncv] / workl[iheig+j];
+#endif
+            }
+        }
+        // 100
+
+        //  Perform a rank one update to Z and
+        //  purify all the Ritz vectors together.
+
+        zgeru_(&V->n, &V->nconv, &cdbl1, resid, &int1, workev, &int1, z, &ldz);
+    }
+
+    return;
+}
+
+
+void
+ARPACK_znaupd(struct ARPACK_arnoldi_update_vars_d *V, ARPACK_CPLX_TYPE* resid,
+       ARPACK_CPLX_TYPE* v, int ldv, int* ipntr, ARPACK_CPLX_TYPE* workd,
+       ARPACK_CPLX_TYPE* workl, double* rwork)
+{
+    int bounds, ierr = 0, ih, iq, iw, ldh, ldq, next, iritz;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        // perform basic checks
+        if (V->n <= 0) {
+            ierr = -1;
+        } else if (V->nev <= 0) {
+            ierr = -2;
+        } else if ((V->ncv < V->nev + 1) || (V->ncv > V->n)) {
+            ierr = -3;
+        } else if (V->maxiter <= 0) {
+            ierr = -4;
+        } else if ((V->which < 0) || (V->which > 5)) {
+            ierr = -5;
+        } else if ((V->bmat != 0) && (V->bmat != 1)) {
+            ierr = -6;
+        } else if ((V->mode < 1) || (V->mode > 3)) {
+            ierr = -10;
+        } else if ((V->mode == 1) && (V->bmat == 1)) {
+            ierr = -11;
+        }
+
+        if (ierr != 0) {
+            V->info = ierr;
+            V->ido = 99;
+            return;
+        }
+
+        if (V->tol <= 0.0) {
+            V-> tol = ulp;
+        }
+
+        if ((V->shift != 0) && (V->shift != 1) && (V->shift != 2))
+        {
+            V->shift = 1;
+        }
+
+        //  NP is the number of additional steps to
+        //  extend the length NEV Lanczos factorization.
+        //  NEV0 is the local variable designating the
+        //  size of the invariant subspace desired.
+
+        V->np = V->ncv - V->nev;
+
+        for (int j = 0; j < 3 * (V->ncv*V->ncv) + 6*V->ncv; j++)
+        {
+            workl[j] = ARPACK_cplx(0.0, 0.0);
+        }
+    }
+    //  Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //  workl(1:ncv*ncv) := generated Hessenberg matrix
+    //  workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values
+    //  workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds
+    //  workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q
+    //  workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace
+    //  The final workspace is needed by subroutine zneigh  called
+    //  by znaup2 . Subroutine zneigh  calls LAPACK routines for
+    //  calculating eigenvalues and the last row of the eigenvector
+    //  matrix.
+
+    ldh    = V->ncv;
+    ldq    = V->ncv;
+    ih     = 0;
+    iritz  = ih     + ldh*V->ncv;
+    bounds = iritz  + V->ncv;
+    iq     = bounds + V->ncv;
+    iw     = iq     + ldq*V->ncv;
+    next   = iw     + (V->ncv*V->ncv) + 3*V->ncv;
+
+    ipntr[3] = next;
+    ipntr[4] = ih;
+    ipntr[5] = iritz;
+    ipntr[6] = iq;
+    ipntr[7] = bounds;
+    ipntr[13]  = iw;
+
+    znaup2(V, resid, v, ldv, &workl[ih], ldh, &workl[iritz], &workl[bounds],
+           &workl[iq], ldq, &workl[iw], ipntr, workd, rwork);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP or shifts.
+
+    if (V->ido != ido_DONE) { return; }
+
+    V->nconv = V->np;
+
+    if (V->info < 0) { return; }
+    if (V->info == 2) { V->info = 3; }
+
+    return;
+}
+
+
+void
+znaup2(struct ARPACK_arnoldi_update_vars_d *V, ARPACK_CPLX_TYPE* resid,
+       ARPACK_CPLX_TYPE* v, int ldv, ARPACK_CPLX_TYPE* h, int ldh,
+       ARPACK_CPLX_TYPE* ritz, ARPACK_CPLX_TYPE* bounds,
+       ARPACK_CPLX_TYPE* q, int ldq, ARPACK_CPLX_TYPE* workl, int* ipntr,
+       ARPACK_CPLX_TYPE* workd, double* rwork)
+{
+    enum ARPACK_which temp_which;
+    int i, int1 = 1, j, tmp_int;
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    double temp = 0.0, rtemp;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->aup2_nev0 = V->nev;
+        V->aup2_np0 = V->np;
+
+        //  kplusp is the bound on the largest
+        //         Lanczos factorization built.
+        //  nconv is the current number of
+        //         "converged" eigenvlues.
+        //  iter is the counter on the current
+        //       iteration step.
+
+        V->aup2_kplusp = V->nev + V->np;
+        V->nconv = 0;
+        V->aup2_iter = 0;
+
+        //  Set flags for computing the first NEV
+        //  steps of the Arnoldi factorization.
+
+        V->aup2_getv0 = 1;
+        V->aup2_update = 0;
+        V->aup2_ushift = 0;
+        V->aup2_cnorm = 0;
+
+        if (V->info != 0)
+        {
+
+            //  User provides the initial residual vector.
+
+            V->aup2_initv = 1;
+            V->info = 0;
+        } else {
+            V->aup2_initv = 0;
+        }
+    }
+
+    //  Get a possibly random starting vector and
+    //  force it into the range of the operator OP.
+
+    if (V->aup2_getv0)
+    {
+        V->getv0_itry = 1;
+        zgetv0(V, V->aup2_initv, V->n, 0, v, ldv, resid, &V->aup2_rnorm, ipntr, workd);
+        if (V->ido != ido_DONE) { return; }
+        if (V->aup2_rnorm == 0.0)
+        {
+            V->info = -9;
+            V->ido = ido_DONE;
+            return;
+        }
+        V->aup2_getv0 = 0;
+        V->ido = ido_FIRST;
+    }
+
+    //  Back from reverse communication :
+    //  continue with update step
+
+    if (V->aup2_update) { goto LINE20; }
+
+    //  Back from computing user specified shifts
+
+    if (V->aup2_ushift) { goto LINE50; }
+
+    //  Back from computing residual norm
+    //  at the end of the current iteration
+
+    if (V->aup2_cnorm) { goto LINE100; }
+
+    //  Compute the first NEV steps of the Arnoldi factorization
+
+    znaitr(V, 0, V->nev, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //
+    //            M A I N  ARNOLDI  I T E R A T I O N  L O O P
+    //            Each iteration implicitly restarts the Arnoldi
+    //            factorization in place.
+    //
+
+LINE1000:
+    V->aup2_iter += 1;
+
+    //  Compute NP additional steps of the Arnoldi factorization.
+    //  Adjust NP since NEV might have been updated by last call
+    //  to the shift application routine dnapps .
+
+    V->np = V->aup2_kplusp - V->nev;
+    V->ido = ido_FIRST;
+
+LINE20:
+    V->aup2_update = 1;
+
+    znaitr(V, V->nev, V->np, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0) {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+    V->aup2_update = 0;
+
+    //  Compute the eigenvalues and corresponding error bounds
+    //  of the current upper Hessenberg matrix.
+
+    zneigh(&V->aup2_rnorm, V->aup2_kplusp, h, ldh, ritz, bounds, q, ldq, workl, rwork, &V->info);
+
+    if (V->info != 0)
+    {
+       V->info = -8;
+       V->ido = ido_DONE;
+       return;
+    }
+
+    //  Select the wanted Ritz values and their bounds
+    //  to be used in the convergence test.
+    //  The wanted part of the spectrum and corresponding
+    //  error bounds are in the last NEV loc. of RITZ,
+    //  and BOUNDS respectively.
+
+    V->nev = V->aup2_nev0;
+    V->np = V->aup2_np0;
+
+    //  Make a copy of Ritz values and the corresponding
+    //  Ritz estimates obtained from zneigh .
+    tmp_int = V->aup2_kplusp * V->aup2_kplusp;
+    zcopy_(&V->aup2_kplusp, ritz, &int1, &workl[tmp_int], &int1);
+    tmp_int += V->aup2_kplusp;
+    zcopy_(&V->aup2_kplusp, bounds, &int1, &workl[tmp_int], &int1);
+
+    //  Select the wanted Ritz values and their bounds
+    //  to be used in the convergence test.
+    //  The wanted part of the spectrum and corresponding
+    //  bounds are in the last NEV loc. of RITZ
+    //  BOUNDS respectively.
+
+    zngets(V, &V->nev, &V->np, ritz, bounds);
+
+    //  Convergence test: currently we use the following criteria.
+    //  The relative accuracy of a Ritz value is considered
+    //  acceptable if:
+    //
+    //  error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)).
+    //
+    V->nconv = 0;
+    for (i = 0; i < V->nev; i++)
+    {
+        rtemp = fmax(eps23, cabs(ritz[V->np + i]));
+        if (cabs(bounds[V->np + i]) <= V->tol*rtemp)
+        {
+            V->nconv += 1;
+        }
+    }
+    // 25
+
+    //  Count the number of unwanted Ritz values that have zero
+    //  Ritz estimates. If any Ritz estimates are equal to zero
+    //  then a leading block of H of order equal to at least
+    //  the number of Ritz values with zero Ritz estimates has
+    //  split off. None of these Ritz values may be removed by
+    //  shifting. Decrease NP the number of shifts to apply. If
+    //  no shifts may be applied, then prepare to exit
+
+    // We are modifying V->np hence the temporary variable.
+    int nptemp = V->np;
+
+    for (j = 0; j < nptemp; j++)
+    {
+        if ((creal(bounds[j]) == 0.0) && (cimag(bounds[j]) == 0.0))
+        {
+            V->np -= 1;
+            V->nev += 1;
+        }
+    }
+    // 30
+
+    if ((V->nconv >= V->aup2_nev0) || (V->aup2_iter > V->maxiter) || (V->np == 0))
+    {
+
+        //  Prepare to exit. Put the converged Ritz values
+        //  and corresponding bounds in RITZ(1:NCONV) and
+        //  BOUNDS(1:NCONV) respectively. Then sort. Be
+        //  careful when NCONV > NP
+
+        //   Use h( 3,1 ) as storage to communicate
+        //   rnorm to _neupd if needed
+
+         h[2] = ARPACK_cplx(V->aup2_rnorm, 0.0);
+
+        // Sort Ritz values so that converged Ritz
+        // values appear within the first NEV locations
+        // of ritz and bounds, and the most desired one
+        // appears at the front.
+
+        // Translation note: Is this all because ARPACK did not have complex sort?
+
+        if (V->which == which_LM) { temp_which = which_SM; }
+        if (V->which == which_SM) { temp_which = which_LM; }
+        if (V->which == which_LR) { temp_which = which_SR; }
+        if (V->which == which_SR) { temp_which = which_LR; }
+        if (V->which == which_LI) { temp_which = which_SI; }
+        if (V->which == which_SI) { temp_which = which_LI; }
+
+        zsortc(temp_which, 1, V->aup2_kplusp, ritz, bounds);
+
+        //  Scale the Ritz estimate of each Ritz value
+        //  by 1 / max(eps23,magnitude of the Ritz value).
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmax(eps23, cabs(ritz[j]));
+            bounds[j] = ARPACK_cplx(creal(bounds[j]) / temp, cimag(bounds[j]) / temp);
+        }
+        // 35
+
+        //  Sort the Ritz values according to the scaled Ritz
+        //  estimates.  This will push all the converged ones
+        //  towards the front of ritzr, ritzi, bounds
+        //  (in the case when NCONV < NEV.)
+
+        temp_which = which_LM;
+        zsortc(temp_which, 1, V->aup2_nev0, bounds, ritz);
+
+        //  Scale the Ritz estimate back to its original
+        //  value.
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmax(eps23, cabs(ritz[j]));
+            bounds[j] = ARPACK_cplx(creal(bounds[j]) * temp, cimag(bounds[j]) * temp);
+        }
+        // 40
+
+        //  Sort the converged Ritz values again so that
+        //  the "threshold" value appears at the front of
+        //  ritzr, ritzi and bound.
+
+        zsortc(V->which, 1, V->nconv, ritz, bounds);
+
+        if ((V->aup2_iter > V->maxiter) && (V->nconv < V->aup2_nev0))
+        {
+
+            //  Max iterations have been exceeded.
+
+            V->info = 1;
+        }
+
+        if ((V->np == 0) && (V->nconv < V->aup2_nev0))
+        {
+
+            //  No shifts to apply.
+
+            V->info = 2;
+        }
+
+        V->np = V->nconv;
+        V->iter = V->aup2_iter;
+        V->nev = V->nconv;
+        V->ido = ido_DONE;
+        return;
+
+    } else if ((V->nconv < V->aup2_nev0) && (V->shift)) {
+
+        //  Do not have all the requested eigenvalues yet.
+        //  To prevent possible stagnation, adjust the size
+        //  of NEV.
+
+        int nevbef = V->nev;
+        V->nev += (V->nconv > (V->np / 2) ? (V->np / 2) : V->nconv);
+        if ((V->nev == 1) && (V->aup2_kplusp >= 6)) {
+            V->nev = V->aup2_kplusp / 2;
+        } else if ((V->nev == 1) && (V->aup2_kplusp > 3)) {
+            V->nev = 2;
+        }
+
+        V->np = V->aup2_kplusp - V->nev;
+
+        // If the size of NEV was just increased
+        // resort the eigenvalues.
+
+        if (nevbef < V->nev) {
+            zngets(V, &V->nev, &V->np, ritz, bounds);
+        }
+    }
+
+    if (V->shift == 0)
+    {
+
+        //  User specified shifts: pop back out to get the shifts
+        //  and return them in the first 2*NP locations of WORKL.
+
+        V->aup2_ushift = 1;
+        V->ido = ido_USER_SHIFT;
+        return;
+    }
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  User specified shifts are returned
+    //  in WORKL(1:2*NP)
+
+    V->aup2_ushift = 0;
+
+    if (V->shift != 1)
+    {
+
+        //  Move the NP shifts from WORKL to
+        //  RITZR, RITZI to free up WORKL
+        //  for non-exact shift case.
+
+        zcopy_(&V->np, workl, &int1, ritz, &int1);
+    }
+
+    //  Apply the NP implicit shifts by QR bulge chasing.
+    //  Each shift is applied to the whole upper Hessenberg
+    //  matrix H.
+    //  The first 2*N locations of WORKD are used as workspace.
+
+    znapps(V->n, &V->nev, V->np, ritz, v, ldv, h, ldh, resid, q, ldq, workl, workd);
+
+    //  Compute the B-norm of the updated residual.
+    //  Keep B*RESID in WORKD(1:N) to be used in
+    //  the first step of the next call to dnaitr .
+
+    V->aup2_cnorm = 1;
+    if (V->bmat)
+    {
+        zcopy_(&V->n, resid, &int1, &workd[V->n], &int1);
+        ipntr[0] = V->n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*RESID
+
+        return;
+    } else {
+        zcopy_(&V->n, resid, &int1, workd, &int1);
+    }
+
+LINE100:
+
+    //  Back from reverse communication;
+    //  WORKD(1:N) := B*RESID
+
+    if (V->bmat)
+    {
+        V->aup2_rnorm = sqrt(cabs(zdotc_(&V->n, resid, &int1, workd, &int1)));
+    } else {
+        V->aup2_rnorm = dznrm2_(&V->n, resid, &int1);
+    }
+    V->aup2_cnorm = 0;
+
+    goto LINE1000;
+
+    //
+    //   E N D     O F     M A I N     I T E R A T I O N     L O O P
+    //
+
+}
+
+
+static void
+znaitr(struct ARPACK_arnoldi_update_vars_d *V, int k, int np, ARPACK_CPLX_TYPE* resid,
+       double* rnorm, ARPACK_CPLX_TYPE* v, int ldv, ARPACK_CPLX_TYPE* h, int ldh,
+       int* ipntr, ARPACK_CPLX_TYPE* workd)
+{
+    int i, infol, ipj, irj, ivj, jj, n, tmp_int;
+    double smlnum = unfl * ( V->n / ulp);
+    const double sq2o2 = sqrt(2.0) / 2.0;
+
+    int int1 = 1;
+    double dbl1 = 1.0, temp1, tst1;
+    ARPACK_CPLX_TYPE cdbl1 = ARPACK_cplx(1.0, 0.0);
+    ARPACK_CPLX_TYPE cdblm1 = ARPACK_cplx(-1.0, 0.0);
+    ARPACK_CPLX_TYPE cdbl0 = ARPACK_cplx(0.0, 0.0);
+
+    n = V->n;  // n is constant, this is just for typing convenience
+    ipj = 0;
+    irj = ipj + n;
+    ivj = irj + n;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        //  Initial call to this routine
+        V->aitr_j = k;
+        V->info = 0;
+        V->aitr_step3 = 0;
+        V->aitr_step4 = 0;
+        V->aitr_orth1 = 0;
+        V->aitr_orth2 = 0;
+        V->aitr_restart = 0;
+    }
+
+    //  When in reverse communication mode one of:
+    //  STEP3, STEP4, ORTH1, ORTH2, RSTART
+    //  will be .true. when ....
+    //  STEP3: return from computing OP*v_{j}.
+    //  STEP4: return from computing B-norm of OP*v_{j}
+    //  ORTH1: return from computing B-norm of r_{j+1}
+    //  ORTH2: return from computing B-norm of
+    //         correction to the residual vector.
+    //  RSTART: return from OP computations needed by
+    //          dgetv0.
+
+    if (V->aitr_step3) { goto LINE50; }
+    if (V->aitr_step4) { goto LINE60; }
+    if (V->aitr_orth1) { goto LINE70; }
+    if (V->aitr_orth2) { goto LINE90; }
+    if (V->aitr_restart) { goto LINE30; }
+
+    //  Else this is the first step
+
+    //
+    //         A R N O L D I     I T E R A T I O N     L O O P
+    //
+    //  Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1)
+
+LINE1000:
+
+    //  STEP 1: Check if the B norm of j-th residual
+    //  vector is zero. Equivalent to determining whether
+    //  an exact j-step Arnoldi factorization is present.
+
+    V->aitr_betaj = *rnorm;
+    if (*rnorm > 0.0) { goto LINE40; }
+
+    //  Invariant subspace found, generate a new starting
+    //  vector which is orthogonal to the current Arnoldi
+    //  basis and continue the iteration.
+
+    V->aitr_betaj = 0.0;
+    V->getv0_itry = 1;
+
+LINE20:
+    V->aitr_restart = 1;
+    V->ido = ido_FIRST;
+
+LINE30:
+
+    // If in reverse communication mode and aitr_restart = 1, flow returns here.
+
+    zgetv0(V, 0, n, V->aitr_j, v, ldv, resid, rnorm, ipntr, workd);
+
+    if (V->ido != ido_DONE) { return; }
+    V->aitr_ierr = V->info;
+    if (V->aitr_ierr < 0)
+    {
+        V->getv0_itry += 1;
+        if (V->getv0_itry <= 3) { goto LINE20; }
+
+        //  Give up after several restart attempts.
+        //  Set INFO to the size of the invariant subspace
+        //  which spans OP and exit.
+
+        V->info = V->aitr_j;
+        V->ido = ido_DONE;
+        return;
+    }
+
+LINE40:
+
+    //  STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm
+    //  Note that p_{j} = B*r_{j-1}. In order to avoid overflow
+    //  when reciprocating a small RNORM, test against lower
+    //  machine bound.
+
+    zcopy_(&n, resid, &int1, &v[ldv*V->aitr_j], &int1);
+
+    if (*rnorm >= unfl)
+    {
+        temp1 = 1.0 / *rnorm;
+        zdscal_(&n, &temp1, &v[ldv*V->aitr_j], &int1);
+        zdscal_(&n, &temp1, &workd[ipj], &int1);
+    } else {
+        zlascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &v[ldv*V->aitr_j], &n, &infol);
+        zlascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &workd[ipj], &n, &infol);
+    }
+
+    //  STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j}
+    //  Note that this is not quite yet r_{j}. See STEP 4
+
+    V->aitr_step3 = 1;
+    zcopy_(&n, &v[ldv*(V->aitr_j)], &int1, &workd[ivj], &int1);
+    ipntr[0] = ivj;
+    ipntr[1] = irj;
+    ipntr[2] = ipj;
+    V->ido = ido_OPX;
+
+    //  Exit in order to compute OP*v_{j}
+
+    return;
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  WORKD(IRJ:IRJ+N-1) := OP*v_{j}
+    //  if step3 = .true.
+
+    V->aitr_step3 = 0;
+
+    //  Put another copy of OP*v_{j} into RESID.
+
+    zcopy_(&n, &workd[irj], &int1, resid, &int1);
+
+    //  STEP 4:  Finish extending the Arnoldi
+    //           factorization to length j.
+
+    if (V->bmat)
+    {
+        V->aitr_step4 = 1;
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*OP*v_{j}
+
+        return;
+    } else {
+        zcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE60:
+
+    //  Back from reverse communication;
+    //  WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}
+    //  if step4 = .true.
+
+    V->aitr_step4 = 0;
+
+    //  The following is needed for STEP 5.
+    //  Compute the B-norm of OP*v_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_wnorm = sqrt(cabs(zdotc_(&n, resid, &int1, &workd[ipj], &int1)));
+    } else {
+        V->aitr_wnorm = dznrm2_(&n, resid, &int1);
+    }
+
+    //  Compute the j-th residual corresponding
+    //  to the j step factorization.
+    //  Use Classical Gram Schmidt and compute:
+    //  w_{j} <-  V_{j}^T * B * OP * v_{j}
+    //  r_{j} <-  OP*v_{j} - V_{j} * w_{j}
+
+    //  Compute the j Fourier coefficients w_{j}
+    //  WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.
+    tmp_int = V->aitr_j + 1;
+    zgemv_("C", &n, &tmp_int, &cdbl1, v, &ldv, &workd[ipj], &int1, &cdbl0, &h[ldh*(V->aitr_j)], &int1);
+
+    //  Orthogonalize r_{j} against V_{j}.
+    //  RESID contains OP*v_{j}. See STEP 3.
+
+    zgemv_("N", &n, &tmp_int, &cdblm1, v, &ldv, &h[ldh*(V->aitr_j)], &int1, &cdbl1, resid, &int1);
+
+    if (V->aitr_j > 0) { h[V->aitr_j + ldh*(V->aitr_j-1)] = ARPACK_cplx(V->aitr_betaj, 0.0); }
+
+    V->aitr_orth1 = 1;
+    if (V->bmat)
+    {
+        zcopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}
+
+        return;
+    } else {
+        zcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE70:
+
+    //  Back from reverse communication if ORTH1 = .true.
+    //  WORKD(IPJ:IPJ+N-1) := B*r_{j}.
+
+    V->aitr_orth1 = 0;
+
+    //  Compute the B-norm of r_{j}.
+
+    if (V->bmat)
+    {
+        *rnorm = sqrt(cabs(zdotc_(&n, resid, &int1, &workd[ipj], &int1)));
+    } else {
+        *rnorm = dznrm2_(&n, resid, &int1);
+    }
+
+    //  STEP 5: Re-orthogonalization / Iterative refinement phase
+    //  Maximum NITER_ITREF tries.
+    //
+    //           s      = V_{j}^T * B * r_{j}
+    //           r_{j}  = r_{j} - V_{j}*s
+    //           alphaj = alphaj + s_{j}
+    //
+    //  The stopping criteria used for iterative refinement is
+    //  discussed in Parlett's book SEP, page 107 and in Gragg &
+    //  Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.
+    //  Determine if we need to correct the residual. The goal is
+    //  to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||
+    //  The following test determines whether the sine of the
+    //  angle between  OP*x and the computed residual is less
+    //  than or equal to 0.7071.
+
+    if (*rnorm > sq2o2*V->aitr_wnorm) { goto LINE100; }
+    V->aitr_iter = 0;
+
+    //  Enter the Iterative refinement phase. If further
+    //  refinement is necessary, loop back here. The loop
+    //  variable is ITER. Perform a step of Classical
+    //  Gram-Schmidt using all the Arnoldi vectors V_{j}
+
+LINE80:
+
+    //  Compute V_{j}^T * B * r_{j}.
+    //  WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1).
+    tmp_int = V->aitr_j + 1;
+    zgemv_("C", &n, &tmp_int, &cdbl1, v, &ldv, &workd[ipj], &int1, &cdbl0, &workd[irj], &int1);
+
+    //  Compute the correction to the residual:
+    //  r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).
+    //  The correction to H is v(:,1:J)*H(1:J,1:J)
+    //  + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.
+
+    zgemv_("N", &n, &tmp_int, &cdblm1, v, &ldv, &workd[irj], &int1, &cdbl1, resid, &int1);
+    zaxpy_(&tmp_int, &cdbl1, &workd[irj], &int1, &h[ldh*(V->aitr_j)], &int1);
+
+    V->aitr_orth2 = 1;
+
+    if (V->bmat)
+    {
+        zcopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}.
+        //  r_{j} is the corrected residual.
+
+        return;
+    } else {
+        zcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE90:
+
+    //  Back from reverse communication if ORTH2 = .true.
+    //  Compute the B-norm of the corrected residual r_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_rnorm1 = sqrt(cabs(zdotc_(&n, resid, &int1, &workd[ipj], &int1)));
+    } else {
+        V->aitr_rnorm1 = dznrm2_(&n, resid, &int1);
+    }
+
+    //  Determine if we need to perform another
+    //  step of re-orthogonalization.
+
+    if (V->aitr_rnorm1 > sq2o2*(*rnorm))
+    {
+
+        //  No need for further refinement.
+        //  The cosine of the angle between the
+        //  corrected residual vector and the old
+        //  residual vector is greater than 0.717
+        //  In other words the corrected residual
+        //  and the old residual vector share an
+        //  angle of less than arcCOS(0.717)
+
+        *rnorm = V->aitr_rnorm1;
+
+    } else {
+
+        //  Another step of iterative refinement step
+        //  is required.
+
+        *rnorm = V->aitr_rnorm1;
+        V->aitr_iter += 1;
+        if (V->aitr_iter < 2) { goto LINE80; }
+
+        //  Otherwise RESID is numerically in the span of V
+
+        for (jj = 0; jj < n; jj++)
+        {
+            resid[jj] = ARPACK_cplx(0.0, 0.0);
+        }
+        *rnorm = 0.0;
+    }
+
+LINE100:
+
+    V->aitr_restart = 0;
+    V->aitr_orth2 = 0;
+
+    //  STEP 6: Update  j = j+1;  Continue
+
+    V->aitr_j += 1;
+
+    if (V->aitr_j >= k + np)
+    {
+        V->ido = ido_DONE;
+        for (i = (k > 0 ? k-1 : k); i < k + np - 1; i++)
+        {
+
+            //  Check for splitting and deflation.
+            //  Use a standard test as in the QR algorithm
+            //  REFERENCE: LAPACK subroutine dlahqr
+
+            tst1 = cabs(h[i + ldh*i]) + cabs(h[i+1 + ldh*(i+1)]);
+            if (tst1 == 0.0)
+            {
+                tmp_int = k + np;
+                // zlanhs(norm, n, a, lda, work) with "work" being double type
+                // Recasting complex workspace to double for scratch space.
+                tst1 = zlanhs_("1", &tmp_int, h, &ldh, (double*)&workd[n]);
+            }
+            if (cabs(h[i+1 + ldh*i]) <= fmax(ulp*tst1, smlnum))
+            {
+                h[i+1 + ldh*i] = ARPACK_cplx(0.0, 0.0);
+            }
+        }
+        // 110
+        return;
+    }
+    goto LINE1000;
+
+}
+
+
+static void
+znapps(int n, int* kev, int np, ARPACK_CPLX_TYPE* shift, ARPACK_CPLX_TYPE* v,
+       int ldv, ARPACK_CPLX_TYPE* h, int ldh, ARPACK_CPLX_TYPE* resid,
+       ARPACK_CPLX_TYPE* q, int ldq, ARPACK_CPLX_TYPE* workl,
+       ARPACK_CPLX_TYPE* workd)
+{
+    int i, j, jj, int1 = 1, istart, iend = 0, tmp_int;
+    double smlnum = unfl * ( n / ulp);
+    double c, tst1;
+    double tmp_dbl;
+    ARPACK_CPLX_TYPE f, g, h11, h21, sigma, s, s2, r, t, tmp_cplx;
+
+#if defined(_MSC_VER)
+    ARPACK_CPLX_TYPE tmp_cplx2;
+#endif
+
+    ARPACK_CPLX_TYPE cdbl1 = ARPACK_cplx(1.0, 0.0);
+    ARPACK_CPLX_TYPE cdbl0 = ARPACK_cplx(0.0, 0.0);
+
+    int kplusp = *kev + np;
+
+    //  Initialize Q to the identity to accumulate
+    //  the rotations and reflections
+    zlaset_("G", &kplusp, &kplusp, &cdbl0, &cdbl1, q, &ldq);
+
+    //  Quick return if there are no shifts to apply
+
+    if (np == 0) { return; }
+
+    //  Chase the bulge with the application of each
+    //  implicit shift. Each shift is applied to the
+    //  whole matrix including each block.
+
+    for (jj = 0; jj < np; jj++)
+    {
+        sigma = shift[jj];
+        istart = 0;
+
+        while (istart < kplusp - 1)
+        {
+            for  (iend = istart; iend < kplusp - 1; iend++)
+            {
+                tst1 = fabs(creal(h[iend + ldh*iend])) + fabs(cimag(h[iend + ldh*iend])) +
+                       fabs(creal(h[iend+1 + ldh*(iend+1)])) + fabs(cimag(h[iend+1 + ldh*(iend+1)]));
+                if (tst1 == 0.0)
+                {
+                    tmp_int = kplusp - jj;
+                    zlanhs_("1", &tmp_int, h, &ldh, (double*)workl);
+                }
+                if (fabs(creal(h[iend+1 + ldh*iend])) <= fmax(ulp*tst1, smlnum))
+                {
+                    break;
+                }
+            }
+            if ((istart == iend) || (istart >= *kev))
+            {
+
+                // No reason to apply a shift to block of order 1
+                // or if the current block starts after the point
+                // of compression since we'll discard this stuff.
+
+                istart += 1;
+                continue;
+
+            } else if (iend < kplusp - 1) {
+
+                // Valid block found and it's not the entire remaining array
+                // Clean up the noise
+
+                    h[iend+1 + ldh*iend] = ARPACK_cplx(0.0, 0.0);
+            }
+
+            h11 = h[istart + ldh*istart];
+            h21 = h[istart + 1 + ldh*istart];
+            // f = h11 - sigma;
+            f = ARPACK_cplx(creal(h11)-creal(sigma), cimag(h11)-cimag(sigma));
+            g = h21;
+
+            for (i = istart; i < iend; i++)
+            {
+
+                //  Construct the plane rotation G to zero out the bulge
+
+                zlartg_(&f, &g, &c, &s, &r);
+                if (i > istart)
+                {
+                    h[i + ldh*(i-1)] = r;
+                    h[i + 1 + ldh*(i-1)] = ARPACK_cplx(0.0, 0.0);
+                }
+                tmp_int = kplusp - i;
+                zrot_(&tmp_int, &h[i + ldh*i], &ldh, &h[i + 1 + ldh*i], &ldh, &c, &s);
+                // z = a + bi, -conj(z) = -a + bi
+                s2 = conj(s);
+                tmp_int = (i + 2 > iend ? iend : i + 2) + 1;
+                zrot_(&tmp_int, &h[ldh*i], &int1, &h[ldh*(i+1)], &int1, &c, &s2);
+                tmp_int = (i + jj + 2 > kplusp ? kplusp : i + jj + 2);
+                zrot_(&tmp_int, &q[ldq*i], &int1, &q[ldq*(i+1)], &int1, &c, &s2);
+
+                if (i < iend - 1)
+                {
+                    f = h[i + 1 + ldh*i];
+                    g = h[i + 2 + ldh*i];
+                }
+            }
+            istart = iend + 1;
+        }
+    }
+
+    //  Perform a similarity transformation that makes
+    //  sure that H will have non negative sub diagonals
+
+    for (j = 0; j < *kev; j++)
+    {
+        if ((creal(h[j+1 + ldh*j]) < 0.0) || (cimag(h[j+1 + ldh*j]) != 0.0))
+        {
+            tmp_dbl = cabs(h[j+1 + ldh*j]);
+            t = ARPACK_cplx(creal(h[j+1 + ldh*j]) / tmp_dbl,
+            cimag(h[j+1 + ldh*j]) / tmp_dbl);
+
+            tmp_cplx = conj(t);
+            tmp_int = kplusp - j;
+            zscal_(&tmp_int, &tmp_cplx, &h[j+1 + ldh*j], &ldh);
+
+            tmp_int = (j+3 > kplusp ? kplusp : j+3);
+            zscal_(&tmp_int, &t, &h[ldh*(j+1)], &int1);
+
+            tmp_int = (j+np+2 > kplusp ? kplusp : j+np+2);
+            zscal_(&tmp_int, &t, &q[ldq*(j+1)], &int1);
+
+            h[j+1 + ldh*j] = ARPACK_cplx(creal(h[j+1 + ldh*j]), 0.0);
+        }
+    }
+    // 120
+
+    for (i = 0; i < *kev; i++)
+    {
+
+        //  Final check for splitting and deflation.
+        //  Use a standard test as in the QR algorithm
+        //  REFERENCE: LAPACK subroutine zlahqr.
+        //  Note: Since the subdiagonals of the
+        //  compressed H are nonnegative real numbers,
+        //  we take advantage of this.
+
+        tst1 = fabs(creal(h[i + ldh*i])) + fabs(creal(h[i+1 + ldh*(i+1)])) +
+               fabs(cimag(h[i + ldh*i])) + fabs(cimag(h[i+1 + ldh*(i+1)]));
+        if (tst1 == 0.0)
+        {
+            tst1 = zlanhs_("1", kev, h, &ldh, (double*)workl);
+        }
+        if (creal(h[i+1 + ldh*i]) <= fmax(ulp*tst1, smlnum))
+        {
+            h[i+1 + ldh*i] = ARPACK_cplx(0.0, 0.0);
+        }
+    }
+    // 130
+
+    //  Compute the (kev+1)-st column of (V*Q) and
+    //  temporarily store the result in WORKD(N+1:2*N).
+    //  This is needed in the residual update since we
+    //  cannot GUARANTEE that the corresponding entry
+    //  of H would be zero as in exact arithmetic.
+
+    if (creal(h[*kev + ldh*(*kev-1)]) > 0.0)
+    {
+        zgemv_("N", &n, &kplusp, &cdbl1, v, &ldv, &q[(*kev)*ldq], &int1, &cdbl0, &workd[n], &int1);
+    }
+
+    //  Compute column 1 to kev of (V*Q) in backward order
+    //  taking advantage of the upper Hessenberg structure of Q.
+
+    for (i = 0; i < *kev; i++)
+    {
+        tmp_int = kplusp - i;
+        zgemv_("N", &n, &tmp_int, &cdbl1, v, &ldv, &q[(*kev-i-1)*ldq], &int1, &cdbl0, workd, &int1);
+        zcopy_(&n, workd, &int1, &v[(kplusp-i-1)*ldv], &int1);
+    }
+
+    //   Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev).
+
+    zlacpy_("A", &n, kev, &v[ldv*(kplusp - *kev)], &ldv, v, &ldv);
+
+    //  Copy the (kev+1)-st column of (V*Q) in the appropriate place
+
+    if (creal(h[*kev + ldh*(*kev-1)]) > 0.0) {
+        zcopy_(&n, &workd[n], &int1, &v[ldv*(*kev)], &int1);
+    }
+
+    //  Update the residual vector:
+    //     r <- sigmak*r + betak*v(:,kev+1)
+    //  where
+    //     sigmak = (e_{kplusp}'*Q)*e_{kev}
+    //     betak = e_{kev+1}'*H*e_{kev}
+
+    zscal_(&n, &q[kplusp-1 + ldq*(*kev-1)], resid, &int1);
+
+    if (creal(h[*kev + ldh*(*kev-1)]) > 0.0)
+    {
+        zaxpy_(&n, &h[*kev + ldh*(*kev-1)], &v[ldv*(*kev)], &int1, resid, &int1);
+    }
+
+    return;
+}
+
+
+static void
+zneigh(double* rnorm, int n, ARPACK_CPLX_TYPE* h, int ldh, ARPACK_CPLX_TYPE* ritz,
+       ARPACK_CPLX_TYPE* bounds, ARPACK_CPLX_TYPE* q, int ldq, ARPACK_CPLX_TYPE* workl,
+       double* rwork, int* ierr)
+{
+    int select[1] = { 0 };
+    int int1 = 1, j;
+    double temp;
+    ARPACK_CPLX_TYPE vl[1] = { 0.0 };
+    ARPACK_CPLX_TYPE c1 = ARPACK_cplx(1.0, 0.0), c0 = ARPACK_cplx(0.0, 0.0);
+
+    //  1. Compute the eigenvalues, the last components of the
+    //     corresponding Schur vectors and the full Schur form T
+    //     of the current upper Hessenberg matrix H.
+    //     zlahqr returns the full Schur form of H
+    //     in WORKL(1:N**2), and the Schur vectors in q.
+
+    zlacpy_("A", &n, &n, h, &ldh, workl, &n);
+    zlaset_("A", &n, &n, &c0, &c1, q, &ldq);
+    zlahqr_(&int1, &int1, &n, &int1, &n, workl, &ldh, ritz, &int1, &n, q, &ldq, ierr);
+
+    if (*ierr != 0) { return; }
+
+    zcopy_(&n, &q[n-2], &ldq, bounds, &int1);
+
+    //  2. Compute the eigenvectors of the full Schur form T and
+    //     apply the Schur vectors to get the corresponding
+    //     eigenvectors.
+
+    ztrevc_("R", "B", select, &n, workl, &n, vl, &n, q, &ldq, &n, &n, &workl[n*n], rwork, ierr);
+
+    if (*ierr != 0) { return; }
+
+    //  Scale the returning eigenvectors so that their
+    //  euclidean norms are all one. LAPACK subroutine
+    //  ztrevc returns each eigenvector normalized so
+    //  that the element of largest magnitude has
+    //  magnitude 1; here the magnitude of a complex
+    //  number (x,y) is taken to be |x| + |y|.
+
+    for (j = 0; j < n; j++)
+    {
+        temp = 1.0 / dznrm2_(&n, &q[j*ldq], &int1);
+        zdscal_(&n, &temp, &q[j*ldq], &int1);
+    }
+
+    //  Compute the Ritz estimates
+
+    zcopy_(&n, &q[n-1], &n, bounds, &int1);
+    zdscal_(&n, rnorm, bounds, &int1);
+
+    return;
+}
+
+
+void
+zngets(struct ARPACK_arnoldi_update_vars_d *V, int* kev, int* np,
+       ARPACK_CPLX_TYPE* ritz, ARPACK_CPLX_TYPE* bounds)
+{
+
+    zsortc(V->which, 1, *kev + *np, ritz, bounds);
+
+    if (V->shift == 1)
+    {
+
+        //  Sort the unwanted Ritz values used as shifts so that
+        //  the ones with largest Ritz estimates are first
+        //  This will tend to minimize the effects of the
+        //  forward instability of the iteration when they shifts
+        //  are applied in subroutine znapps.
+        //  Be careful and use 'SM' since we want to sort BOUNDS!
+
+        zsortc(which_SM, 1, *np, bounds, ritz);
+    }
+
+    return;
+}
+
+
+static void
+zgetv0(struct ARPACK_arnoldi_update_vars_d *V, int initv, int n, int j,
+       ARPACK_CPLX_TYPE* v, int ldv, ARPACK_CPLX_TYPE* resid, double* rnorm,
+       int* ipntr, ARPACK_CPLX_TYPE* workd)
+{
+    int jj, int1 = 1;
+    const double sq2o2 = sqrt(2.0) / 2.0;
+    ARPACK_CPLX_TYPE c0 = ARPACK_cplx(0.0, 0.0);
+    ARPACK_CPLX_TYPE c1 = ARPACK_cplx(1.0, 0.0);
+    ARPACK_CPLX_TYPE cm1 = ARPACK_cplx(-1.0, 0.0);
+
+    if (V->ido == ido_FIRST)
+    {
+        V->info = 0;
+        V->getv0_iter = 0;
+        V->getv0_first = 0;
+        V->getv0_orth = 0;
+
+        //  Possibly generate a random starting vector in RESID
+        //  Skip if this the return of ido_RANDOM.
+
+        if (!(initv))
+        {
+            // Request a random vector from the user into resid
+            V->ido = ido_RANDOM;
+            return;
+        } else {
+            //  If initv = 1, then the user has provided a starting vector
+            //  in RESID. We need to copy it into workd[n] and perform an OP(x0).
+            //  Change the ido but don't exit to join back to the flow.
+            V->ido = ido_RANDOM;
+        }
+    }
+
+    // Back from random vector generation
+    if (V->ido == ido_RANDOM)
+    {
+        //  Force the starting vector into the range of OP to handle
+        //  the generalized problem when B is possibly (singular).
+
+        if (V->getv0_itry == 1)
+        {
+            ipntr[0] = 0;
+            ipntr[1] = n;
+            zcopy_(&n, resid, &int1, workd, &int1);
+            V->ido = ido_RANDOM_OPX;
+            return;
+        } else if ((V->getv0_itry > 1) && (V->bmat == 1))
+        {
+            zcopy_(&n, resid, &int1, &workd[n], &int1);
+        }
+    }
+
+    //  Back from computing OP*(initial-vector)
+
+    if (V->getv0_first) { goto LINE20; }
+
+    //  Back from computing OP*(orthogonalized-vector)
+
+    if (V->getv0_orth) { goto LINE40; }
+
+    //  Starting vector is now in the range of OP; r = OP*r;
+    //  Compute B-norm of starting vector.
+
+    V->getv0_first = 1;
+    if (V->getv0_itry == 1)
+    {
+        zcopy_(&n, &workd[n], &int1, resid, &int1);
+    }
+    if (V->bmat)
+    {
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        zcopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE20:
+    V->getv0_first = 0;
+    if (V->bmat)
+    {
+        V->getv0_rnorm0 = sqrt(cabs(zdotc_(&n, resid, &int1, workd, &int1)));
+    } else {
+        V->getv0_rnorm0 = dznrm2_(&n, resid, &int1);
+    }
+    *rnorm = V->getv0_rnorm0;
+
+    //  Exit if this is the very first Arnoldi step
+
+    if (j == 0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //  Otherwise need to B-orthogonalize the starting vector against
+    //  the current Arnoldi basis using Gram-Schmidt with iter. ref.
+    //  This is the case where an invariant subspace is encountered
+    //  in the middle of the Arnoldi factorization.
+    //
+    //        s = V^{H}*B*r;   r = r - V*s;
+    //
+    //  Stopping criteria used for iter. ref. is discussed in
+    //  Parlett's book, page 107 and in Gragg & Reichel TOMS paper.
+
+    V->getv0_orth = 1;
+
+LINE30:
+
+    zgemv_("C", &n, &j, &c1, v, &ldv, workd, &int1, &c0, &workd[n], &int1);
+    zgemv_("N", &n, &j, &cm1, v, &ldv, &workd[n], &int1, &c1, resid, &int1);
+
+    //  Compute the B-norm of the orthogonalized starting vector
+
+    if (V->bmat)
+    {
+        zcopy_(&n, resid, &int1, &workd[n], &int1);
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        zcopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE40:
+
+    if (V->bmat)
+    {
+        *rnorm = sqrt(cabs(zdotc_(&n, resid, &int1, workd, &int1)));
+    } else {
+        *rnorm = dznrm2_(&n, resid, &int1);
+    }
+
+    //  Check for further orthogonalization.
+
+    if (*rnorm > sq2o2*V->getv0_rnorm0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->getv0_iter += 1;
+
+    if (V->getv0_iter < 2)
+    {
+
+        //  Perform iterative refinement step
+
+        V->getv0_rnorm0 = *rnorm;
+        goto LINE30;
+    } else {
+
+        //  Iterative refinement step "failed"
+
+        for (jj = 0; jj < n; jj++) { resid[jj] = ARPACK_cplx(0.0, 0.0); }
+        *rnorm = 0.0;
+        V->info = -1;
+    }
+
+    V->ido = ido_DONE;
+    return;
+}
+
+
+static void
+zsortc(const enum ARPACK_which w, const int apply, const int n, ARPACK_CPLX_TYPE* x, ARPACK_CPLX_TYPE* y)
+{
+    int i, igap, j;
+    ARPACK_CPLX_TYPE temp;
+    ARPACK_compare_cfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortc_LM;
+            break;
+        case which_SM:
+            f = sortc_SM;
+            break;
+        case which_LR:
+            f = sortc_LR;
+            break;
+        case which_LI:
+            f = sortc_LI;
+            break;
+        case which_SR:
+            f = sortc_SR;
+            break;
+        case which_SI:
+            f = sortc_SI;
+            break;
+        default:
+            f = sortc_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(x[j], x[j+igap]))
+            {
+                if (j < 0) { break; }
+                temp = x[j];
+                x[j] = x[j+igap];
+                x[j+igap] = temp;
+
+                if (apply)
+                {
+                    temp = y[j];
+                    y[j] = y[j+igap];
+                    y[j+igap] = temp;
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+}
+
+
+static int sortc_LM(const ARPACK_CPLX_TYPE x, const ARPACK_CPLX_TYPE y) { return (cabs(x) > cabs(y)); }
+static int sortc_SM(const ARPACK_CPLX_TYPE x, const ARPACK_CPLX_TYPE y) { return (cabs(x) < cabs(y)); }
+static int sortc_LR(const ARPACK_CPLX_TYPE x, const ARPACK_CPLX_TYPE y) { return (creal(x) > creal(y)); }
+static int sortc_SR(const ARPACK_CPLX_TYPE x, const ARPACK_CPLX_TYPE y) { return (creal(x) < creal(y)); }
+static int sortc_LI(const ARPACK_CPLX_TYPE x, const ARPACK_CPLX_TYPE y) { return (cimag(x) > cimag(y)); }
+static int sortc_SI(const ARPACK_CPLX_TYPE x, const ARPACK_CPLX_TYPE y) { return (cimag(x) < cimag(y)); }
+
+
+// zdotc is the complex conjugate dot product of two complex vectors.
+// Due some historical reasons, this function can cause segfaults on some
+// platforms. Hence implemented here instead of using the BLAS version.
+static ARPACK_CPLX_TYPE
+zdotc_(const int* n, const ARPACK_CPLX_TYPE* restrict x, const int* incx, const ARPACK_CPLX_TYPE* restrict y, const int* incy)
+{
+    ARPACK_CPLX_TYPE result = ARPACK_cplx(0.0, 0.0);
+#ifdef _MSC_VER
+    ARPACK_CPLX_TYPE temp = ARPACK_cplx(0.0, 0.0);
+#endif
+    if (*n <= 0) { return result; }
+    if ((*incx == 1) && (*incy == 1))
+    {
+        for (int i = 0; i < *n; i++)
+        {
+#ifdef _MSC_VER
+            temp = _Cmulcc(x[i], conj(y[i]));
+            result = ARPACK_cplx(creal(result) + creal(temp), cimag(result) + cimag(temp));
+#else
+            result = result + (x[i] * conj(y[i]));
+#endif
+        }
+
+    } else {
+
+        for (int i = 0; i < *n; i++)
+        {
+#ifdef _MSC_VER
+            temp = _Cmulcc(x[i * (*incx)], conj(y[i * (*incy)]));
+            result = ARPACK_cplx(creal(result) + creal(temp), cimag(result) + cimag(temp));
+#else
+            result = result + (x[i * (*incx)] * conj(y[i * (*incy)]));
+#endif
+        }
+    }
+
+    return result;
+}
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.h
new file mode 100644
index 0000000000..47302631cf
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_double_complex.h
@@ -0,0 +1,45 @@
+#ifndef _ARPACK_N_DOUBLE_COMPLEX_H
+#define _ARPACK_N_DOUBLE_COMPLEX_H
+
+#include "_arpack.h"
+
+// BLAS Routines used
+void zaxpy_(int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* x, int* incx, ARPACK_CPLX_TYPE* y, int* incy);
+void zcopy_(int* n, ARPACK_CPLX_TYPE* x, int* incx, ARPACK_CPLX_TYPE* y, int* incy);
+void zgeru_(int* m, int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* x, int* incx, ARPACK_CPLX_TYPE* y, int* incy, ARPACK_CPLX_TYPE* a, int* lda);
+double dznrm2_(int* n, ARPACK_CPLX_TYPE* x, int* incx);
+void zscal_(int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* x, int* incx);
+void zdscal_(int* n, double* da, ARPACK_CPLX_TYPE* zx, int* incx);
+void zgemv_(char* trans, int* m, int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* a, int* lda, ARPACK_CPLX_TYPE* x, int* incx, ARPACK_CPLX_TYPE* beta, ARPACK_CPLX_TYPE* y, int* incy);
+void zrot_(int* n, ARPACK_CPLX_TYPE* cx, int* incx, ARPACK_CPLX_TYPE* cy, int* incy, double* c, ARPACK_CPLX_TYPE* s);
+void ztrmm_(char* side, char* uplo, char* transa, char* diag, int* m, int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* a, int* lda, ARPACK_CPLX_TYPE* b, int* ldb);
+
+// LAPACK Routines used
+void zgeqr2_(int* m, int* n, ARPACK_CPLX_TYPE* a, int* lda, ARPACK_CPLX_TYPE* tau, ARPACK_CPLX_TYPE* work, int* info);
+void zlacpy_(char* uplo, int* m, int* n, ARPACK_CPLX_TYPE* a, int* lda, ARPACK_CPLX_TYPE* b, int* ldb);
+void zlahqr_(int* wantt, int* wantz, int* n, int* ilo, int* ihi, ARPACK_CPLX_TYPE* h, int* ldh, ARPACK_CPLX_TYPE* w, int* iloz, int* ihiz, ARPACK_CPLX_TYPE* z, int* ldz, int* info );
+double zlanhs_(char* norm, int* n, ARPACK_CPLX_TYPE* a, int* lda, double* work);
+void zlarf_(char* side, int* m, int* n, ARPACK_CPLX_TYPE* v, int* incv, ARPACK_CPLX_TYPE* tau, ARPACK_CPLX_TYPE* c, int* ldc, ARPACK_CPLX_TYPE* work);
+void zlarfg_(int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* x, int* incx, ARPACK_CPLX_TYPE* tau);
+void zlartg_(ARPACK_CPLX_TYPE* f, ARPACK_CPLX_TYPE* g, double* c, ARPACK_CPLX_TYPE* s, ARPACK_CPLX_TYPE* r);
+void zlascl_(char* mtype, int* kl, int* ku, double* cfrom, double* cto, int* m, int* n, ARPACK_CPLX_TYPE* a, int* lda, int* info);
+void zlaset_(char* uplo, int* m, int* n, ARPACK_CPLX_TYPE* alpha, ARPACK_CPLX_TYPE* beta, ARPACK_CPLX_TYPE* a, int* lda);
+void ztrevc_(char* side, char* howmny, int* select, int* n, ARPACK_CPLX_TYPE* t, int* ldt, ARPACK_CPLX_TYPE* vl, int* ldvl, ARPACK_CPLX_TYPE* vr, int* ldvr, int* mm, int* m, ARPACK_CPLX_TYPE* work, double* rwork, int* info);
+void ztrsen_(char* job, char* compq, int* select, int* n, ARPACK_CPLX_TYPE* t, int* ldt, ARPACK_CPLX_TYPE* q, int* ldq, ARPACK_CPLX_TYPE* w, int* m, double* s, double* sep, ARPACK_CPLX_TYPE* work, int* lwork, int* info);
+void zunm2r_(char* side, char* trans, int* m, int* n, int* k, ARPACK_CPLX_TYPE* a, int* lda, ARPACK_CPLX_TYPE* tau, ARPACK_CPLX_TYPE* c, int* ldc, ARPACK_CPLX_TYPE* work, int* info);
+
+#if defined(_MSC_VER)
+    // MSVC definitions
+    #include <complex.h>  // MSVC C++ header
+    typedef _Dcomplex ARPACK_CPLX_TYPE;
+    #define ARPACK_cplx(real, imag) ((_Dcomplex){real, imag})
+
+#else
+    // C99 compliant compilers
+    #include <complex.h>
+    typedef double complex ARPACK_CPLX_TYPE;
+    #define ARPACK_cplx(real, imag) ((real) + (imag)*I)
+
+#endif
+
+#endif
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.c b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.c
new file mode 100644
index 0000000000..c24042ec03
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.c
@@ -0,0 +1,2101 @@
+#include "_arpack_n_single.h"
+
+typedef int ARPACK_compare_cfunc(const float, const float, const float, const float);
+
+static int sortc_LM(const float, const float, const float, const float);
+static int sortc_SM(const float, const float, const float, const float);
+static int sortc_LR(const float, const float, const float, const float);
+static int sortc_SR(const float, const float, const float, const float);
+static int sortc_LI(const float, const float, const float, const float);
+static int sortc_SI(const float, const float, const float, const float);
+
+static const float unfl = 1.1754943508222875e-38;
+// static const float ovfl = 1.0 / 1.1754943508222875e-38;
+static const float ulp = 1.1920928955078125e-07;
+
+static void snaup2(struct ARPACK_arnoldi_update_vars_s*, float*, float*, int, float*, int, float*, float*, float*, float*, int, float*, int*, float*);
+static void snconv(int n, float* ritzr, float* ritzi, float* bounds, const float tol, int* nconv);
+static void sneigh(float*,int,float*,int,float*,float*,float*,float*,int,float*,int*);
+static void snaitr(struct ARPACK_arnoldi_update_vars_s*,int,int,float*,float*,float*,int,float*,int,int*,float*);
+static void snapps(int,int*,int,float*,float*,float*,int,float*,int,float*,float*,int,float*,float*);
+static void sngets(struct ARPACK_arnoldi_update_vars_s*,int*,int*,float*,float*,float*);
+static void ssortc(const enum ARPACK_which w, const int apply, const int n, float* xreal, float* ximag, float* y);
+static void sgetv0(struct ARPACK_arnoldi_update_vars_s *V, int initv, int n, int j, float* v, int ldv, float* resid, float* rnorm, int* ipntr, float* workd);
+
+enum ARPACK_neupd_type {
+    REGULAR = 0,
+    SHIFTI,
+    REALPART,
+    IMAGPART
+};
+
+
+void
+ARPACK_sneupd(struct ARPACK_arnoldi_update_vars_s *V, int rvec, int howmny, int* select,
+       float* dr, float* di, float* z, int ldz, float sigmar, float sigmai,
+       float* workev, float* resid, float* v, int ldv, int* ipntr, float* workd,
+       float* workl)
+{
+    const float eps23 = powf(ulp, 2.0 / 3.0);
+    int ibd, iconj, ih, iheigr, iheigi, ihbds, iuptri, invsub, iri, irr, j, jj;
+    int bounds, k, ldh, ldq, np, numcnv, reord, ritzr, ritzi;
+    int iwork[1] = { 0 };
+    int ierr = 0, int1 = 1, tmp_int = 0, nconv2 = 0, outncv;
+    float conds, rnorm, sep, temp, temp1, dbl0 = 0.0, dbl1 = 1.0, dblm1 = -1.0;
+    float vl[1] = { 0.0 };
+    enum ARPACK_neupd_type TYP;
+
+    if (V->nconv <= 0) {
+        ierr = -14;
+    } else if (V->n <= 0) {
+        ierr = -1;
+    } else if (V->nev <= 0) {
+        ierr = -2;
+    } else if ((V->ncv <= V->nev + 1) || (V->ncv > V->n)) {
+        ierr = -3;
+    } else if ((V->which > 5) || (V->which < 0)) {
+        ierr = -5;
+    } else if ((V->bmat != 0) && (V->bmat != 1)) {
+        ierr = -6;
+    } else if ((rvec) && ((howmny < 0) || (howmny > 2))) {
+        ierr = -13;
+    } else if (howmny == 2) {
+        ierr = -12;  // NotImplementedError
+    }
+
+    if ((V->mode == 1) || (V->mode == 2)) {
+        TYP = REGULAR;
+    } else if ((V->mode == 3) && (sigmai == 0.0)) {
+        TYP = SHIFTI;
+    } else if (V->mode == 3) {
+        TYP = REALPART;
+    } else if (V->mode == 4) {
+        TYP = IMAGPART;
+    } else {
+        ierr = -10;
+    }
+
+    if ((V->mode == 1) && (V->bmat)) { ierr = -11; }
+
+    if (ierr != 0) {
+        V->info = ierr;
+        return;
+    }
+
+    //  Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //  workl(1:ncv*ncv) := generated Hessenberg matrix
+    //  workl(ncv*ncv+1:ncv*ncv+2*ncv) := real and imaginary parts of ritz values
+    //  workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := error bounds
+
+    //  The following is used and set by SNEUPD .
+    //  workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed real part of the Ritz values.
+    //  workl(ncv*ncv+4*ncv+1:ncv*ncv+5*ncv) := The untransformed imaginary part of the Ritz values.
+    //  workl(ncv*ncv+5*ncv+1:ncv*ncv+6*ncv) := The untransformed error bounds of the Ritz values
+    //  workl(ncv*ncv+6*ncv+1:2*ncv*ncv+6*ncv) := Holds the upper quasi-triangular matrix for H
+    //  workl(2*ncv*ncv+6*ncv+1: 3*ncv*ncv+6*ncv) := Holds the associated matrix representation of the invariant subspace for H.
+    //  GRAND total of NCV * ( 3 * NCV + 6 ) locations.
+
+    ih     = ipntr[4];
+    ritzr  = ipntr[5];
+    ritzi  = ipntr[6];
+    bounds = ipntr[7];
+    ldh = V->ncv;
+    ldq = V->ncv;
+    iheigr = bounds + ldh;
+    iheigi = iheigr + ldh;
+    ihbds  = iheigi + ldh;
+    iuptri = ihbds  + ldh;
+    invsub = iuptri + ldh*V->ncv;
+    ipntr[8]  = iheigr;
+    ipntr[9]  = iheigi;
+    ipntr[10] = ihbds;
+    ipntr[11] = iuptri;
+    ipntr[12] = invsub;
+
+    //  irr points to the REAL part of the Ritz
+    //      values computed by _neigh before
+    //      exiting _naup2.
+    //  iri points to the IMAGINARY part of the
+    //      Ritz values computed by _neigh
+    //      before exiting _naup2.
+    //  ibd points to the Ritz estimates
+    //      computed by _neigh before exiting
+    //      _naup2.
+
+    irr = ipntr[13] + (V->ncv)*(V->ncv);
+    iri = irr + V->ncv;
+    ibd = iri + V->ncv;
+
+    //  RNORM is B-norm of the RESID(1:N).
+    rnorm = workl[ih+2];
+    workl[ih+2] = 0.0;
+
+    if (rvec) {
+        reord = 0;
+
+        //  Use the temporary bounds array to store indices
+        //  These will be used to mark the select array later
+
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[bounds + j] = j;
+            select[j] = 0;
+        }
+        // 10
+
+        //  Select the wanted Ritz values.
+        //  Sort the Ritz values so that the
+        //  wanted ones appear at the tailing
+        //  NEV positions of workl(irr) and
+        //  workl(iri).  Move the corresponding
+        //  error estimates in workl(bound)
+        //  accordingly.
+
+        np = V->ncv - V->nev;
+        sngets(V, &V->nev, &np, &workl[irr], &workl[iri], &workl[bounds]);
+
+        //  Record indices of the converged wanted Ritz values
+        //  Mark the select array for possible reordering
+
+        numcnv = 0;
+        for (j = 1; j <= V->ncv; j++)
+        {
+            temp1 = fmaxf(eps23, hypotf(workl[irr + V->ncv - j], workl[iri + V->ncv - j]));
+
+            jj = (int)workl[bounds + V->ncv - j];
+
+            if ((numcnv < V->nconv) && (workl[ibd + jj] <= V->tol*temp1))
+            {
+                select[jj] = 1;
+                numcnv += 1;
+                if (jj > V->nconv - 1) { reord = 1; }
+            }
+        }
+        // 11
+
+        //  Check the count (numcnv) of converged Ritz values with
+        //  the number (nconv) reported by dnaupd.  If these two
+        //  are different then there has probably been an error
+        //  caused by incorrect passing of the dnaupd data.
+
+        if (numcnv != V->nconv)
+        {
+            V->info = -15;
+            return;
+        }
+
+        //  Call LAPACK routine dlahqr  to compute the real Schur form
+        //  of the upper Hessenberg matrix returned by DNAUPD .
+        //  Make a copy of the upper Hessenberg matrix.
+        //  Initialize the Schur vector matrix Q to the identity.
+
+        tmp_int = ldh*V->ncv;
+        scopy_(&tmp_int, &workl[ih], &int1, &workl[iuptri], &int1);
+        slaset_("A", &V->ncv, &V->ncv, &dbl0, &dbl1, &workl[invsub], &ldq);
+        slahqr_(&int1, &int1, &V->ncv, &int1, &V->ncv, &workl[iuptri], &ldh,
+                &workl[iheigr], &workl[iheigi], &int1, &V->ncv, &workl[invsub],
+                &ldq, &ierr);
+        scopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        if (ierr != 0)
+        {
+            V->info = -8;
+            return;
+        }
+
+        if (reord)
+        {
+            strsen_("N", "V", select, &V->ncv, &workl[iuptri], &ldh, &workl[invsub], &ldq,
+                    &workl[iheigr], &workl[iheigi], &nconv2, &conds, &sep, &workl[ihbds],
+                    &V->ncv, iwork, &int1, &ierr);
+
+            if (nconv2 < V->nconv) { V->nconv = nconv2; }
+            if (ierr == 1) {
+                V->info = 1;
+                return;
+            }
+        }
+
+        //  Copy the last row of the Schur vector
+        //  into workl(ihbds).  This will be used
+        //  to compute the Ritz estimates of
+        //  converged Ritz values.
+
+        scopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        //  Place the computed eigenvalues of H into DR and DI
+        //  if a spectral transformation was not used.
+
+        if (TYP == REGULAR) {
+            scopy_(&V->nconv, &workl[iheigr], &int1, dr, &int1);
+            scopy_(&V->nconv, &workl[iheigi], &int1, di, &int1);
+        }
+
+        //  Compute the QR factorization of the matrix representing
+        //  the wanted invariant subspace located in the first NCONV
+        //  columns of workl(invsub,ldq).
+
+        sgeqr2_(&V->ncv, &V->nconv, &workl[invsub], &ldq, workev, &workev[V->ncv], &ierr);
+
+        //  * Postmultiply V by Q using dorm2r .
+        //  * Copy the first NCONV columns of VQ into Z.
+        //  * Postmultiply Z by R.
+        //  The N by NCONV matrix Z is now a matrix representation
+        //  of the approximate invariant subspace associated with
+        //  the Ritz values in workl(iheigr) and workl(iheigi)
+        //  The first NCONV columns of V are now approximate Schur
+        //  vectors associated with the real upper quasi-triangular
+        //  matrix of order NCONV in workl(iuptri)
+
+        sorm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[invsub], &ldq, workev,
+                v, &ldv, &workd[V->n], &ierr);
+
+        slacpy_("A", &V->n, &V->nconv, v, &ldv, z, &ldz);
+
+        //  Perform both a column and row scaling if the
+        //  diagonal element of workl(invsub,ldq) is negative
+        //  I'm lazy and don't take advantage of the upper
+        //  quasi-triangular form of workl(iuptri,ldq)
+        //  Note that since Q is orthogonal, R is a diagonal
+        //  matrix consisting of plus or minus ones
+
+        for (j = 0; j < V->nconv; j++)
+        {
+            if (workl[invsub + j*ldq + j] < 0.0)
+            {
+                sscal_(&V->nconv, &dblm1, &workl[iuptri + j], &ldq);
+                sscal_(&V->nconv, &dblm1, &workl[iuptri + j*ldq], &int1);
+            }
+        }
+        // 20
+
+        if (howmny == 0)
+        {
+
+            //  Compute the NCONV wanted eigenvectors of T
+            //  located in workl(iuptri,ldq).
+
+            for (j = 0; j < V->ncv; j++)
+            {
+                if (j < V->nconv)
+                {
+                    select[j] = 1;
+                } else {
+                    select[j] = 0;
+                }
+            }
+            // 30
+
+            strevc_("R", "S", select, &V->ncv, &workl[iuptri], &ldq, vl, &int1,
+                    &workl[invsub], &ldq, &V->ncv, &outncv, workev, &ierr);
+
+            if (ierr != 0)
+            {
+                V->info = -9;
+                return;
+            }
+
+            //  Scale the returning eigenvectors so that their
+            //  Euclidean norms are all one. LAPACK subroutine
+            //  dtrevc  returns each eigenvector normalized so
+            //  that the element of largest magnitude has
+            //  magnitude 1;
+
+            iconj = 0;
+            for (j = 0; j < V->nconv; j++)
+            {
+                if (workl[iheigi + j] == 0.0)
+                {
+
+                    //  real eigenvalue case
+
+                    temp = 1.0 / snrm2_(&V->ncv, &workl[invsub + j*ldq], &int1);
+                    sscal_(&V->ncv, &temp, &workl[invsub + j*ldq], &int1);
+
+                } else {
+
+                    //  Complex conjugate pair case. Note that
+                    //  since the real and imaginary part of
+                    //  the eigenvector are stored in consecutive
+                    //  columns, we further normalize by the
+                    //  square root of two.
+
+                    if (iconj == 0)
+                    {
+                        temp = 1.0 / hypotf(snrm2_(&V->ncv, &workl[invsub + j*ldq], &int1),
+                                           snrm2_(&V->ncv, &workl[invsub + (j+1)*ldq], &int1));
+                        sscal_(&V->ncv, &temp, &workl[invsub + j*ldq], &int1);
+                        sscal_(&V->ncv, &temp, &workl[invsub + (j+1)*ldq], &int1);
+                        iconj = 1;
+                    } else {
+                        iconj = 0;
+                    }
+                }
+            }
+            // 40
+
+            sgemv_("T", &V->ncv, &V->nconv, &dbl1, &workl[invsub], &ldq, &workl[ihbds], &int1, &dbl0, workev, &int1);
+
+            iconj = 0;
+            for (j = 0; j < V->nconv; j++)
+            {
+                if (workl[iheigi + j] != 0.0)
+                {
+
+                    //  Complex conjugate pair case. Note that
+                    //  since the real and imaginary part of
+                    //  the eigenvector are stored in consecutive
+
+                    if (iconj == 0)
+                    {
+                        workev[j] = hypotf(workev[j], workev[j+1]);
+                        workev[j+1] = workev[j];
+                        iconj = 1;
+                    } else {
+                        iconj = 0;
+                    }
+                }
+            }
+            // 45
+
+            //  Copy Ritz estimates into workl(ihbds)
+
+            scopy_(&V->nconv, workev, &int1, &workl[ihbds], &int1);
+
+            //  Compute the QR factorization of the eigenvector matrix
+            //  associated with leading portion of T in the first NCONV
+            //  columns of workl(invsub,ldq).
+
+            sgeqr2_(&V->ncv, &V->nconv, &workl[invsub], &ldq, workev, &workev[V->ncv], &ierr);
+
+            //  * Postmultiply Z by Q.
+            //  * Postmultiply Z by R.
+            //  The N by NCONV matrix Z is now contains the
+            //  Ritz vectors associated with the Ritz values
+            //  in workl(iheigr) and workl(iheigi).
+
+            sorm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[invsub], &ldq,
+                    workev, z, &ldz, &workd[V->n], &ierr);
+
+            strmm_("R", "U", "N", "N", &V->n, &V->nconv, &dbl1, &workl[invsub], &ldq, z, &ldz);
+
+        }
+
+    } else {
+
+        //  An approximate invariant subspace is not needed.
+        //  Place the Ritz values computed DNAUPD  into DR and DI
+
+        scopy_(&V->nconv, &workl[ritzr], &int1, dr, &int1);
+        scopy_(&V->nconv, &workl[ritzi], &int1, di, &int1);
+        scopy_(&V->nconv, &workl[ritzr], &int1, &workl[iheigr], &int1);
+        scopy_(&V->nconv, &workl[ritzi], &int1, &workl[iheigi], &int1);
+        scopy_(&V->nconv, &workl[bounds], &int1, &workl[ihbds], &int1);
+    }
+
+    //  Transform the Ritz values and possibly vectors
+    //  and corresponding error bounds of OP to those
+    //  of A*x = lambda*B*x.
+
+    if (TYP == REGULAR)
+    {
+        if (rvec)
+        {
+            sscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+        }
+    } else {
+
+        //    A spectral transformation was used.
+        //  * Determine the Ritz estimates of the
+        //    Ritz values in the original system.
+
+        if (TYP == SHIFTI)
+        {
+            if (rvec)
+            {
+                sscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+            }
+
+            for (k = 0; k < V->ncv; k++)
+            {
+                temp = hypotf(workl[iheigr+k], workl[iheigi+k]);
+                workl[ihbds+k] = fabsf(workl[ihbds+k]) / temp / temp;
+            }
+            // 50
+
+        }
+
+        //  *  Transform the Ritz values back to the original system.
+        //     For TYPE = 'SHIFTI' the transformation is
+        //              lambda = 1/theta + sigma
+        //     For TYPE = 'REALPT' or 'IMAGPT' the user must from
+        //     Rayleigh quotients or a projection. See remark 3 above.
+        //  NOTES:
+        //  *The Ritz vectors are not affected by the transformation.
+
+        if (TYP == SHIFTI)
+        {
+            for (k = 0; k < V->ncv; k++)
+            {
+                temp = hypotf(workl[iheigr+k], workl[iheigi+k]);
+                workl[iheigr+k] =  workl[iheigr+k] / temp / temp + sigmar;
+                workl[iheigi+k] = -workl[iheigi+k] / temp / temp + sigmai;
+            }
+            // 80
+
+            scopy_(&V->nconv, &workl[iheigr], &int1, dr, &int1);
+            scopy_(&V->nconv, &workl[iheigi], &int1, di, &int1);
+
+        } else if ((TYP == REALPART) || (TYP == IMAGPART)) {
+            scopy_(&V->nconv, &workl[iheigr], &int1, dr, &int1);
+            scopy_(&V->nconv, &workl[iheigi], &int1, di, &int1);
+        }
+    }
+
+    //  Eigenvector Purification step. Formally perform
+    //  one of inverse subspace iteration. Only used
+    //  for MODE = 2.
+
+    if ((rvec) && (howmny == 0) && (TYP == SHIFTI))
+    {
+
+        //  Purify the computed Ritz vectors by adding a
+        //  little bit of the residual vector:
+        //                       T
+        //           resid(:)*( e    s ) / theta
+        //                       NCV
+        //  where H s = s theta. Remember that when theta
+        //  has nonzero imaginary part, the corresponding
+        //  Ritz vector is stored across two columns of Z.
+
+        iconj = 0;
+        for (j = 0; j < V->nconv; j++)
+        {
+            if ((workl[iheigi+j] == 0.0) && (workl[iheigr+j] != 0.0))
+            {
+                workev[j] = workl[invsub + j*ldq + V->ncv] / workl[iheigr+j];
+            } else if (iconj == 0) {
+
+                temp = hypotf(workl[iheigr+j], workl[iheigi+j]);
+                if (temp != 0.0)
+                {
+                    workev[j] = (workl[invsub + j*ldq + V->ncv]*workl[iheigr+j] +
+                                 workl[invsub + (j+1)*ldq + V->ncv]*workl[iheigi+j]
+                                ) / temp / temp;
+                    workev[j+1] = (workl[invsub + (j+1)*ldq + V->ncv]*workl[iheigr+j] -
+                                 workl[invsub + j*ldq + V->ncv]*workl[iheigi+j]
+                                ) / temp / temp;
+                }
+                iconj = 1;
+            } else {
+                iconj = 0;
+            }
+        }
+        // 110
+
+        //  Perform a rank one update to Z and
+        //  purify all the Ritz vectors together.
+
+        sger_(&V->n, &V->nconv, &dbl1, resid, &int1, workev, &int1, z, &ldz);
+    }
+
+    return;
+}
+
+void
+ARPACK_snaupd(struct ARPACK_arnoldi_update_vars_s *V, float* resid, float* v,
+              int ldv, int* ipntr, float* workd, float* workl)
+{
+    int bounds, ih, iq, iw, j, ldh, ldq, next, iritzi, iritzr;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        // perform basic checks
+        if (V->n <= 0) {
+            V->info = -1;
+        } else if (V->nev <= 0) {
+            V->info = -2;
+        } else if ((V->ncv < V->nev + 1) || (V->ncv > V->n)) {
+            V->info = -3;
+        } else if (V->maxiter <= 0) {
+            V->info = -4;
+        } else if ((V->which < 0) || (V->which > 5)) {
+            V->info = -5;
+        } else if ((V->bmat != 0) && (V->bmat != 1)) {
+            V->info = -6;
+        } else if ((V->mode < 1) || (V->mode > 4)) {
+            V->info = -10;
+        } else if ((V->mode == 1) && (V->bmat == 1)) {
+            V->info = -11;
+        } else if ((V->shift != 0) && (V->shift != 1)) {
+            V->info = -12;
+        }
+
+        if (V->info < 0) {
+            V->ido = ido_DONE;
+            return;
+        }
+
+        if (V->tol <= 0.0) {
+            V->tol = ulp;
+        }
+        V->np = V->ncv - V->nev;
+
+        for (j = 0; j < 3 * (V->ncv)*(V->ncv) + 6*(V->ncv); j++)
+        {
+            workl[j] = 0.0;
+        }
+    }
+
+    //  Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //
+    //  workl[0:ncv*ncv] := generated Hessenberg matrix
+    //  workl[ncv**2:ncv**2+2*ncv] := ritz.real and ritz.imag values
+    //  workl[ncv**2+2*ncv:ncv*ncv+3*ncv] := error bounds
+    //  workl[ncv**2+3*ncv+1:2*ncv*ncv+3*ncv] := rotation matrix Q
+    //  workl[2*ncv**2+3*ncv:3*ncv*ncv+6*ncv] := workspace
+    //
+    //  The final workspace is needed by subroutine dneigh  called
+    //  by dnaup2 . Subroutine dneigh  calls LAPACK routines for
+    //  calculating eigenvalues and the last row of the eigenvector
+    //  matrix.
+
+    ldh    = V->ncv;
+    ldq    = V->ncv;
+    ih     = 0;
+    iritzr = ih     + ldh*V->ncv;
+    iritzi = iritzr + V->ncv;
+    bounds = iritzi + V->ncv;
+    iq     = bounds + V->ncv;
+    iw     = iq     + ldq*V->ncv;
+    next   = iw     + (V->ncv*V->ncv) + 3*V->ncv;
+
+    ipntr[3] = next;
+    ipntr[4] = ih;
+    ipntr[5] = iritzr;
+    ipntr[6] = iritzi;
+    ipntr[7] = bounds;
+    ipntr[13]  = iw;
+
+    //  Carry out the Implicitly restarted Arnoldi Iteration.
+
+    snaup2(V, resid, v, ldv, &workl[ih], ldh, &workl[iritzr], &workl[iritzi], &workl[bounds], &workl[iq], ldq, &workl[iw], ipntr, workd);
+
+    //  ido != DONE implies use of reverse communication
+    //  to compute operations involving OP or shifts.
+
+    if (V->ido != ido_DONE) { return; }
+
+    V->nconv = V->np;
+    // iparam(9) = nopx
+    // iparam(10) = nbx
+    // iparam(11) = nrorth
+
+    if (V->info < 0) { return; }
+    if (V->info == 2) { V->info = 3; }
+
+    return;
+}
+
+void
+snaup2(struct ARPACK_arnoldi_update_vars_s *V, float* resid, float* v, int ldv,
+       float* h, int ldh, float* ritzr, float* ritzi, float* bounds,
+       float* q, int ldq, float* workl, int* ipntr, float* workd)
+{
+    enum ARPACK_which temp_which;
+    int int1 = 1, j, tmp_int;
+    const float eps23 = powf(ulp, 2.0 / 3.0);
+    float temp = 0.0;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->aup2_nev0 = V->nev;
+        V->aup2_np0 = V->np;
+
+        //  kplusp is the bound on the largest
+        //         Lanczos factorization built.
+        //  nconv is the current number of
+        //         "converged" eigenvlues.
+        //  iter is the counter on the current
+        //       iteration step.
+
+        V->aup2_kplusp = V->nev + V->np;
+        V->nconv = 0;
+        V->aup2_iter = 0;
+
+        //  Set flags for computing the first NEV
+        //  steps of the Arnoldi factorization.
+
+        V->aup2_getv0 = 1;
+        V->aup2_update = 0;
+        V->aup2_ushift = 0;
+        V->aup2_cnorm = 0;
+
+        if (V->info != 0)
+        {
+
+            //  User provides the initial residual vector.
+
+            V->aup2_initv = 1;
+            V->info = 0;
+        } else {
+            V->aup2_initv = 0;
+        }
+    }
+
+    //  Get a possibly random starting vector and
+    //  force it into the range of the operator OP.
+
+    if (V->aup2_getv0)
+    {
+        V->getv0_itry = 1;
+        sgetv0(V, V->aup2_initv, V->n, 0, v, ldv, resid, &V->aup2_rnorm, ipntr, workd);
+        if (V->ido != ido_DONE) { return; }
+        if (V->aup2_rnorm == 0.0)
+        {
+            V->info = -9;
+            V->ido = ido_DONE;
+            return;
+        }
+        V->aup2_getv0 = 0;
+        V->ido = ido_FIRST;
+    }
+
+    //  Back from reverse communication :
+    //  continue with update step
+
+    if (V->aup2_update) { goto LINE20; }
+
+    //  Back from computing user specified shifts
+
+    if (V->aup2_ushift) { goto LINE50; }
+
+    //  Back from computing residual norm
+    //  at the end of the current iteration
+
+    if (V->aup2_cnorm) { goto LINE100; }
+
+    //  Compute the first NEV steps of the Arnoldi factorization
+
+    snaitr(V, 0, V->nev, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //
+    //            M A I N  ARNOLDI  I T E R A T I O N  L O O P
+    //            Each iteration implicitly restarts the Arnoldi
+    //            factorization in place.
+    //
+
+LINE1000:
+    V->aup2_iter += 1;
+
+    //  Compute NP additional steps of the Arnoldi factorization.
+    //  Adjust NP since NEV might have been updated by last call
+    //  to the shift application routine dnapps .
+
+    V->np = V->aup2_kplusp - V->nev;
+
+    //  Compute NP additional steps of the Arnoldi factorization.
+
+    V->ido = ido_FIRST;
+
+LINE20:
+    V->aup2_update = 1;
+
+    snaitr(V, V->nev, V->np, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0) {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+    V->aup2_update = 0;
+
+    //  Compute the eigenvalues and corresponding error bounds
+    //  of the current upper Hessenberg matrix.
+
+    sneigh(&V->aup2_rnorm, V->aup2_kplusp, h, ldh, ritzr, ritzi, bounds, q, ldq, workl, &V->info);
+
+    if (V->info != 0)
+    {
+       V->info = -8;
+       V->ido = ido_DONE;
+       return;
+    }
+
+    //  Make a copy of eigenvalues and corresponding error
+    //  bounds obtained from dneigh.
+
+    tmp_int = V->aup2_kplusp * V->aup2_kplusp;
+    scopy_(&V->aup2_kplusp, ritzr, &int1, &workl[tmp_int], &int1);
+    tmp_int += V->aup2_kplusp;
+    scopy_(&V->aup2_kplusp, ritzi, &int1, &workl[tmp_int], &int1);
+    tmp_int += V->aup2_kplusp;
+    scopy_(&V->aup2_kplusp, bounds, &int1, &workl[tmp_int], &int1);
+
+    //  Select the wanted Ritz values and their bounds
+    //  to be used in the convergence test.
+    //  The wanted part of the spectrum and corresponding
+    //  error bounds are in the last NEV loc. of RITZR,
+    //  RITZI and BOUNDS respectively. The variables NEV
+    //  and NP may be updated if the NEV-th wanted Ritz
+    //  value has a non zero imaginary part. In this case
+    //  NEV is increased by one and NP decreased by one.
+    //  NOTE: The last two arguments of dngets  are no
+    //  longer used as of version 2.1.
+
+    V->nev = V->aup2_nev0;
+    V->np = V->aup2_np0;
+    V->aup2_numcnv = V->nev;
+
+    sngets(V, &V->nev, &V->np, ritzr, ritzi, bounds);
+
+    if (V->nev == V->aup2_nev0 + 1) { V->aup2_numcnv = V->aup2_nev0 + 1;}
+
+    //  Convergence test.
+
+    scopy_(&V->nev, &bounds[V->np], &int1, &workl[2*V->np], &int1);
+    snconv(V->nev, &ritzr[V->np], &ritzi[V->np], &workl[2*V->np], V->tol, &V->nconv);
+
+    //  Count the number of unwanted Ritz values that have zero
+    //  Ritz estimates. If any Ritz estimates are equal to zero
+    //  then a leading block of H of order equal to at least
+    //  the number of Ritz values with zero Ritz estimates has
+    //  split off. None of these Ritz values may be removed by
+    //  shifting. Decrease NP the number of shifts to apply. If
+    //  no shifts may be applied, then prepare to exit
+
+    // We are modifying V->np hence the temporary variable.
+    int nptemp = V->np;
+
+    for (j = 0; j < nptemp; j++)
+    {
+        if (bounds[j] == 0.0)
+        {
+            V->np -= 1;
+            V->nev += 1;
+        }
+    }
+    // 30
+
+    if ((V->nconv >= V->aup2_numcnv) || (V->aup2_iter > V->maxiter) || (V->np == 0))
+    {
+
+        //  Prepare to exit. Put the converged Ritz values
+        //  and corresponding bounds in RITZ(1:NCONV) and
+        //  BOUNDS(1:NCONV) respectively. Then sort. Be
+        //  careful when NCONV > NP
+
+        //   Use h( 3,1 ) as storage to communicate
+        //   rnorm to _neupd if needed
+
+         h[2] = V->aup2_rnorm;
+
+        //  To be consistent with dngets , we first do a
+        //  pre-processing sort in order to keep complex
+        //  conjugate pairs together.  This is similar
+        //  to the pre-processing sort used in dngets
+        //  except that the sort is done in the opposite
+        //  order.
+
+        // Translation note: Is this all because ARPACK did not have complex sort?
+
+        if (V->which == which_LM) { temp_which = which_SR; }
+        if (V->which == which_SM) { temp_which = which_LR; }
+        if (V->which == which_LR) { temp_which = which_SM; }
+        if (V->which == which_SR) { temp_which = which_LM; }
+        if (V->which == which_LI) { temp_which = which_SM; }
+        if (V->which == which_SI) { temp_which = which_LM; }
+
+        ssortc(temp_which, 1, V->aup2_kplusp, ritzr, ritzi, bounds);
+
+        if (V->which == which_LM) { temp_which = which_SM; }
+        if (V->which == which_SM) { temp_which = which_LM; }
+        if (V->which == which_LR) { temp_which = which_SR; }
+        if (V->which == which_SR) { temp_which = which_LR; }
+        if (V->which == which_LI) { temp_which = which_SI; }
+        if (V->which == which_SI) { temp_which = which_LI; }
+
+        ssortc(temp_which, 1, V->aup2_kplusp, ritzr, ritzi, bounds);
+
+        //  Scale the Ritz estimate of each Ritz value
+        //  by 1 / max(eps23,magnitude of the Ritz value).
+
+        for (j = 0; j < V->aup2_numcnv; j++)
+        {
+            temp = fmaxf(eps23, hypotf(ritzr[j], ritzi[j]));
+            bounds[j] = bounds[j] / temp;
+        }
+        // 35
+
+        //  Sort the Ritz values according to the scaled Ritz
+        //  estimates.  This will push all the converged ones
+        //  towards the front of ritzr, ritzi, bounds
+        //  (in the case when NCONV < NEV.)
+
+        temp_which = which_LR;
+        ssortc(temp_which, 1, V->aup2_numcnv, bounds, ritzr, ritzi);
+
+        //  Scale the Ritz estimate back to its original
+        //  value.
+
+        for (j = 0; j < V->aup2_numcnv; j++)
+        {
+            temp = fmaxf(eps23, hypotf(ritzr[j], ritzi[j]));
+            bounds[j] = bounds[j] * temp;
+        }
+        // 40
+
+        //  Sort the converged Ritz values again so that
+        //  the "threshold" value appears at the front of
+        //  ritzr, ritzi and bound.
+
+        ssortc(V->which, 1, V->nconv, ritzr, ritzi, bounds);
+
+        if ((V->aup2_iter > V->maxiter) && (V->nconv < V->aup2_numcnv))
+        {
+
+            //  Max iterations have been exceeded.
+
+            V->info = 1;
+        }
+
+        if ((V->np == 0) && (V->nconv < V->aup2_numcnv))
+        {
+
+            //  No shifts to apply.
+
+            V->info = 2;
+        }
+
+        V->np = V->nconv;
+        V->iter = V->aup2_iter;
+        V->nev = V->aup2_numcnv;
+        V->ido = ido_DONE;
+        return;
+
+    } else if ((V->nconv < V->aup2_numcnv) && (V->shift)) {
+
+        //  Do not have all the requested eigenvalues yet.
+        //  To prevent possible stagnation, adjust the size
+        //  of NEV.
+
+        int nevbef = V->nev;
+        V->nev += (V->nconv > (V->np / 2) ? (V->np / 2) : V->nconv);
+        if ((V->nev == 1) && (V->aup2_kplusp >= 6)) {
+            V->nev = V->aup2_kplusp / 2;
+        } else if ((V->nev == 1) && (V->aup2_kplusp > 3)) {
+            V->nev = 2;
+        }
+
+        //  SciPy Fix
+        //  We must keep nev below this value, as otherwise we can get
+        //  np == 0 (note that dngets below can bump nev by 1). If np == 0,
+        // the next call to `dnaitr` will write out-of-bounds.
+
+        if (V->nev > (V->aup2_kplusp - 2)) {
+            V->nev = V->aup2_kplusp - 2;
+        }
+        //  SciPy Fix End
+
+        V->np = V->aup2_kplusp - V->nev;
+
+        if (nevbef < V->nev) {
+            sngets(V, &V->nev, &V->np, ritzr, ritzi, bounds);
+        }
+
+    }
+
+    if (V->shift == 0)
+    {
+
+        //  User specified shifts: reverse communication to
+        //  compute the shifts. They are returned in the first
+        //  2*NP locations of WORKL.
+
+        V->aup2_ushift = 1;
+        V->ido = ido_USER_SHIFT;
+        return;
+    }
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  User specified shifts are returned
+    //  in WORKL(1:2*NP)
+
+    V->aup2_ushift = 0;
+
+    if (V->shift == 0)
+    {
+
+        //  Move the NP shifts from WORKL to
+        //  RITZR, RITZI to free up WORKL
+        //  for non-exact shift case.
+
+        scopy_(&V->np, workl, &int1, ritzr, &int1);
+        scopy_(&V->np, &workl[V->np], &int1, ritzi, &int1);
+    }
+
+    //  Apply the NP implicit shifts by QR bulge chasing.
+    //  Each shift is applied to the whole upper Hessenberg
+    //  matrix H.
+    //  The first 2*N locations of WORKD are used as workspace.
+
+    snapps(V->n, &V->nev, V->np, ritzr, ritzi, v, ldv, h, ldh, resid, q, ldq, workl, workd);
+
+    //  Compute the B-norm of the updated residual.
+    //  Keep B*RESID in WORKD(1:N) to be used in
+    //  the first step of the next call to dnaitr .
+
+    V->aup2_cnorm = 1;
+    if (V->bmat)
+    {
+        scopy_(&V->n, resid, &int1, &workd[V->n], &int1);
+        ipntr[0] = V->n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*RESID
+
+        return;
+    } else {
+        scopy_(&V->n, resid, &int1, workd, &int1);
+    }
+
+LINE100:
+
+    //  Back from reverse communication;
+    //  WORKD(1:N) := B*RESID
+
+    if (V->bmat)
+    {
+        V->aup2_rnorm = sdot_(&V->n, resid, &int1, workd, &int1);
+        V->aup2_rnorm = sqrtf(fabsf(V->aup2_rnorm));
+    } else {
+        V->aup2_rnorm = snrm2_(&V->n, resid, &int1);
+    }
+    V->aup2_cnorm = 0;
+
+    goto LINE1000;
+
+    //
+    //   E N D     O F     M A I N     I T E R A T I O N     L O O P
+    //
+
+}
+
+void
+snconv(int n, float* ritzr, float* ritzi, float* bounds, const float tol, int* nconv)
+{
+    const float eps23 = powf(ulp, 2.0 / 3.0);
+    float temp;
+
+    *nconv = 0;
+    for (int i = 0; i < n; i++)
+    {
+        temp = fmaxf(eps23, hypotf(ritzr[i], ritzi[i]));
+        if (bounds[i] <= tol*temp)
+        {
+            *nconv += 1;
+        }
+    }
+
+    return;
+}
+
+void
+sneigh(float* rnorm, int n, float* h, int ldh, float* ritzr, float* ritzi,
+       float* bounds, float* q, int ldq, float* workl, int* ierr)
+{
+    int select[1] = { 0 };
+    int i, iconj, int1 = 1, j;
+    float dbl1 = 1.0, dbl0 = 0.0, temp, tmp_dbl, vl[1] = { 0.0 };
+
+    //  1. Compute the eigenvalues, the last components of the
+    //     corresponding Schur vectors and the full Schur form T
+    //     of the current upper Hessenberg matrix H.
+    //  dlahqr returns the full Schur form of H in WORKL(1:N**2)
+    //  and the last components of the Schur vectors in BOUNDS.
+
+    slacpy_("A", &n, &n, h, &ldh, workl, &n);
+    for (j = 0; j < n-1; j++)
+    {
+        bounds[j] = 0.0;
+    }
+    bounds[n-1] = 1.0;
+    slahqr_(&int1, &int1, &n, &int1, &n, workl, &n, ritzr, ritzi, &int1, &int1, bounds, &int1, ierr);
+
+    if (*ierr != 0) { return; }
+
+    //  2. Compute the eigenvectors of the full Schur form T and
+    //     apply the last components of the Schur vectors to get
+    //     the last components of the corresponding eigenvectors.
+    //  Remember that if the i-th and (i+1)-st eigenvalues are
+    //  complex conjugate pairs, then the real & imaginary part
+    //  of the eigenvector components are split across adjacent
+    //  columns of Q.
+
+    strevc_("R", "A", select, &n, workl, &n, vl, &n, q, &ldq, &n, &n, &workl[n*n], ierr);
+    if (*ierr != 0) { return; }
+
+    //  Scale the returning eigenvectors so that their
+    //  euclidean norms are all one. LAPACK subroutine
+    //  dtrevc returns each eigenvector normalized so
+    //  that the element of largest magnitude has
+    //  magnitude 1; here the magnitude of a complex
+    //  number (x,y) is taken to be |x| + |y|.
+
+    iconj = 0;
+    for (i = 0; i < n; i++)
+    {
+        if (fabsf(ritzi[i]) == 0.0)
+        {
+
+            //  Real eigenvalue case
+
+            temp = snrm2_(&n, &q[ldq*i], &int1);
+            tmp_dbl = 1.0 / temp;
+            sscal_(&n, &tmp_dbl, &q[ldq*i], &int1);
+
+        } else {
+
+            //  Complex conjugate pair case. Note that
+            //  since the real and imaginary part of
+            //  the eigenvector are stored in consecutive
+            //  columns, we further normalize by the
+            //  square root of two.
+
+            if (iconj == 0)
+            {
+                temp = hypotf(snrm2_(&n, &q[ldq*i], &int1),
+                             snrm2_(&n, &q[ldq*(i+1)], &int1));
+                tmp_dbl = 1.0 / temp;
+                sscal_(&n, &tmp_dbl, &q[ldq*i], &int1);
+                sscal_(&n, &tmp_dbl, &q[ldq*(i+1)], &int1);
+                iconj = 1;
+            } else {
+                iconj = 0;
+            }
+        }
+    }
+    // 10
+
+    sgemv_("T", &n, &n, &dbl1, q, &ldq, bounds, &int1, &dbl0, workl, &int1);
+
+    //  Compute the Ritz estimates
+
+    iconj = 0;
+    for (i = 0; i < n; i++)
+    {
+        if (fabsf(ritzi[i]) == 0.0)
+        {
+
+            //  Real eigenvalue case
+
+            bounds[i] = *rnorm * fabsf(workl[i]);
+
+        } else {
+
+            //  Complex conjugate pair case. Note that
+            //  since the real and imaginary part of
+            //  the eigenvector are stored in consecutive
+            //  columns, we need to take the magnitude
+            //  of the last components of the two vectors
+
+            if (iconj == 0)
+            {
+                bounds[i] = *rnorm * hypotf(workl[i], workl[i+1]);
+                bounds[i+1] = bounds[i];
+                iconj = 1;
+            } else {
+                iconj = 0;
+            }
+        }
+    }
+    // 20
+
+    return;
+}
+
+void
+snaitr(struct ARPACK_arnoldi_update_vars_s *V, int k, int np, float* resid, float* rnorm,
+       float* v, int ldv, float* h, int ldh, int* ipntr, float* workd)
+{
+    int i = 0, infol, ipj, irj, ivj, jj, n, tmp_int;
+    float smlnum = unfl * ( V->n / ulp);
+    const float sq2o2 = sqrtf(2.0) / 2.0;
+
+    int int1 = 1;
+    float dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0, temp1, tst1;
+
+    n = V->n;  // n is constant, this is just for typing convenience
+    ipj = 0;
+    irj = ipj + n;
+    ivj = irj + n;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        //  Initial call to this routine
+
+        V->aitr_j = k;
+        V->info = 0;
+        V->aitr_step3 = 0;
+        V->aitr_step4 = 0;
+        V->aitr_orth1 = 0;
+        V->aitr_orth2 = 0;
+        V->aitr_restart = 0;
+    }
+
+    //  When in reverse communication mode one of:
+    //  STEP3, STEP4, ORTH1, ORTH2, RSTART
+    //  will be .true. when ....
+    //  STEP3: return from computing OP*v_{j}.
+    //  STEP4: return from computing B-norm of OP*v_{j}
+    //  ORTH1: return from computing B-norm of r_{j+1}
+    //  ORTH2: return from computing B-norm of correction to the residual vector.
+    //  RSTART: return from OP computations needed by sgetv0.
+
+    if (V->aitr_step3) { goto LINE50; }
+    if (V->aitr_step4) { goto LINE60; }
+    if (V->aitr_orth1) { goto LINE70; }
+    if (V->aitr_orth2) { goto LINE90; }
+    if (V->aitr_restart) { goto LINE30; }
+
+    //  Else this is the first step
+
+    //
+    //         A R N O L D I     I T E R A T I O N     L O O P
+    //
+    //  Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1)
+
+LINE1000:
+
+    //  STEP 1: Check if the B norm of j-th residual
+    //  vector is zero. Equivalent to determining whether
+    //  an exact j-step Arnoldi factorization is present.
+
+    V->aitr_betaj = *rnorm;
+
+    if (*rnorm > 0.0) { goto LINE40; }
+
+    //  Invariant subspace found, generate a new starting
+    //  vector which is orthogonal to the current Arnoldi
+    //  basis and continue the iteration.
+
+    V->aitr_betaj = 0.0;
+    V->getv0_itry = 1;
+
+LINE20:
+    V->aitr_restart = 1;
+    V->ido = ido_FIRST;
+
+LINE30:
+
+    // If in reverse communication mode and aitr_restart = 1, flow returns here.
+
+    sgetv0(V, 0, n, V->aitr_j, v, ldv, resid, rnorm, ipntr, workd);
+
+    if (V->ido != ido_DONE) { return; }
+    V->aitr_ierr = V->info;
+    if (V->aitr_ierr < 0)
+    {
+        V->getv0_itry += 1;
+        if (V->getv0_itry <= 3) { goto LINE20; }
+
+        //  Give up after several restart attempts.
+        //  Set INFO to the size of the invariant subspace
+        //  which spans OP and exit.
+
+        V->info = V->aitr_j;
+        V->ido = ido_DONE;
+        return;
+    }
+
+LINE40:
+
+    //  STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm
+    //  Note that p_{j} = B*r_{j-1}. In order to avoid overflow
+    //  when reciprocating a small RNORM, test against lower
+    //  machine bound.
+
+    scopy_(&n, resid, &int1, &v[ldv*(V->aitr_j)], &int1);
+    if (*rnorm >= unfl)
+    {
+        temp1 = 1.0 / *rnorm;
+        sscal_(&n, &temp1, &v[ldv*(V->aitr_j)], &int1);
+        sscal_(&n, &temp1, &workd[ipj], &int1);
+    } else {
+        slascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &v[ldv*(V->aitr_j)], &n, &infol);
+        slascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &workd[ipj], &n, &infol);
+    }
+
+    //  STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j}
+    //  Note that this is not quite yet r_{j}. See STEP 4
+
+    V->aitr_step3 = 1;
+    scopy_(&n, &v[ldv*(V->aitr_j)], &int1, &workd[ivj], &int1);
+    ipntr[0] = ivj;
+    ipntr[1] = irj;
+    ipntr[2] = ipj;
+    V->ido = ido_OPX;
+
+    //  Exit in order to compute OP*v_{j}
+
+    return;
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  WORKD(IRJ:IRJ+N-1) := OP*v_{j}
+    //  if step3 = .true.
+
+    V->aitr_step3 = 0;
+
+    //  Put another copy of OP*v_{j} into RESID.
+
+    scopy_(&n, &workd[irj], &int1, resid, &int1);
+
+    //  STEP 4:  Finish extending the Arnoldi
+    //           factorization to length j.
+
+    if (V->bmat)
+    {
+        V->aitr_step4 = 1;
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*OP*v_{j}
+
+        return;
+    } else {
+        scopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE60:
+
+    //  Back from reverse communication;
+    //  WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}
+    //  if step4 = .true.
+
+    V->aitr_step4 = 0;
+
+    //  The following is needed for STEP 5.
+    //  Compute the B-norm of OP*v_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_wnorm = sdot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_wnorm = sqrtf(fabsf(V->aitr_wnorm));
+    } else {
+        V->aitr_wnorm = snrm2_(&n, resid, &int1);
+    }
+
+    //  Compute the j-th residual corresponding
+    //  to the j step factorization.
+    //  Use Classical Gram Schmidt and compute:
+    //  w_{j} <-  V_{j}^T * B * OP * v_{j}
+    //  r_{j} <-  OP*v_{j} - V_{j} * w_{j}
+
+    //  Compute the j Fourier coefficients w_{j}
+    //  WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.
+    tmp_int = V->aitr_j + 1;
+    sgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &h[ldh*(V->aitr_j)], &int1);
+
+    //  Orthogonalize r_{j} against V_{j}.
+    //  RESID contains OP*v_{j}. See STEP 3.
+
+    sgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &h[ldh*(V->aitr_j)], &int1, &dbl1, resid, &int1);
+
+    if (V->aitr_j > 0) { h[V->aitr_j + ldh*(V->aitr_j-1)] = V->aitr_betaj; }
+
+    V->aitr_orth1 = 1;
+    if (V->bmat)
+    {
+        scopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}
+
+        return;
+    } else {
+        scopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE70:
+
+    //  Back from reverse communication if ORTH1 = .true.
+    //  WORKD(IPJ:IPJ+N-1) := B*r_{j}.
+
+    V->aitr_orth1 = 0;
+
+    //  Compute the B-norm of r_{j}.
+
+    if (V->bmat)
+    {
+        *rnorm = sdot_(&n, resid, &int1, &workd[ipj], &int1);
+        *rnorm = sqrtf(fabsf(*rnorm));
+    } else {
+        *rnorm = snrm2_(&n, resid, &int1);
+    }
+
+    //  STEP 5: Re-orthogonalization / Iterative refinement phase
+    //  Maximum NITER_ITREF tries.
+    //
+    //           s      = V_{j}^T * B * r_{j}
+    //           r_{j}  = r_{j} - V_{j}*s
+    //           alphaj = alphaj + s_{j}
+    //
+    //  The stopping criteria used for iterative refinement is
+    //  discussed in Parlett's book SEP, page 107 and in Gragg &
+    //  Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.
+    //  Determine if we need to correct the residual. The goal is
+    //  to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||
+    //  The following test determines whether the sine of the
+    //  angle between  OP*x and the computed residual is less
+    //  than or equal to 0.7071.
+
+    if (*rnorm > sq2o2*V->aitr_wnorm) { goto LINE100; }
+    V->aitr_iter = 0;
+
+    //  Enter the Iterative refinement phase. If further
+    //  refinement is necessary, loop back here. The loop
+    //  variable is ITER. Perform a step of Classical
+    //  Gram-Schmidt using all the Arnoldi vectors V_{j}
+
+LINE80:
+
+    //  Compute V_{j}^T * B * r_{j}.
+    //  WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1).
+    tmp_int = V->aitr_j + 1;
+    sgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &workd[irj], &int1);
+
+    //  Compute the correction to the residual:
+    //  r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).
+    //  The correction to H is v(:,1:J)*H(1:J,1:J)
+    //  + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.
+
+    sgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &workd[irj], &int1, &dbl1, resid, &int1);
+    saxpy_(&tmp_int, &dbl1, &workd[irj], &int1, &h[ldh*(V->aitr_j)], &int1);
+
+    V->aitr_orth2 = 1;
+
+    if (V->bmat)
+    {
+        scopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}.
+        //  r_{j} is the corrected residual.
+
+        return;
+    } else {
+        scopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE90:
+
+    //  Back from reverse communication if ORTH2 = .true.
+
+    //  Compute the B-norm of the corrected residual r_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_rnorm1 = sdot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_rnorm1 = sqrtf(fabsf(V->aitr_rnorm1));
+    } else {
+        V->aitr_rnorm1 = snrm2_(&n, resid, &int1);
+    }
+
+    //  Determine if we need to perform another
+    //  step of re-orthogonalization.
+
+    if (V->aitr_rnorm1 > sq2o2*(*rnorm))
+    {
+
+        //  No need for further refinement.
+        //  The cosine of the angle between the
+        //  corrected residual vector and the old
+        //  residual vector is greater than 0.717
+        //  In other words the corrected residual
+        //  and the old residual vector share an
+        //  angle of less than arcCOS(0.717)
+
+        *rnorm = V->aitr_rnorm1;
+
+    } else {
+
+        //  Another step of iterative refinement step
+        //  is required.
+
+        *rnorm = V->aitr_rnorm1;
+        V->aitr_iter += 1;
+        if (V->aitr_iter < 2) { goto LINE80; }
+
+        //  Otherwise RESID is numerically in the span of V
+
+        for (jj = 0; jj < n; jj++)
+        {
+            resid[jj] = 0.0;
+        }
+        *rnorm = 0.0;
+    }
+
+    // Branch here directly if iterative refinement
+    // wasn't necessary or after at most NITER_REF
+    // steps of iterative refinement.
+
+LINE100:
+
+    V->aitr_restart = 0;
+    V->aitr_orth2 = 0;
+
+    //  STEP 6: Update  j = j+1;  Continue
+
+    V->aitr_j += 1;
+    if (V->aitr_j >= k + np)
+    {
+        V->ido = ido_DONE;
+        for (i = (k > 0 ? k-1 : k); i < k + np - 1; i++)
+        {
+
+            //  Check for splitting and deflation.
+            //  Use a standard test as in the QR algorithm
+            //  REFERENCE: LAPACK subroutine dlahqr
+
+            tst1 = fabsf(h[i + ldh*i]) + fabsf(h[i+1 + ldh*(i+1)]);
+            if (tst1 == 0.0)
+            {
+                tmp_int = k + np;
+                tst1 = slanhs_("1", &tmp_int, h, &ldh, &workd[n]);
+            }
+            if (fabsf(h[i+1 + ldh*i]) <= fmaxf(ulp*tst1, smlnum))
+            {
+                h[i+1 + ldh*i] = 0.0;
+            }
+        }
+        // 110
+        return;
+    }
+    goto LINE1000;
+
+}
+
+
+void
+snapps(int n, int* kev, int np, float* shiftr, float* shifti, float* v,
+       int ldv, float* h, int ldh, float* resid, float* q, int ldq, float* workl,
+       float* workd)
+{
+    int cconj;
+    int i, ir, j, jj, int1 = 1, istart, iend = 0, nr, tmp_int;
+    int kplusp = *kev + np;
+    float smlnum = unfl * ( n / ulp);
+    float c, f, g, h11, h21, h12, h22, h32, s, sigmar, sigmai, r, t, tau, tst1;
+    float dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0;
+    float u[3] = { 0.0 };
+
+    //  Initialize Q to the identity to accumulate
+    //  the rotations and reflections
+    slaset_("A", &kplusp, &kplusp, &dbl0, &dbl1, q, &ldq);
+
+    //  Quick return if there are no shifts to apply
+
+    if (np == 0) { return; }
+
+    //  Chase the bulge with the application of each
+    //  implicit shift. Each shift is applied to the
+    //  whole matrix including each block.
+
+    cconj = 0;
+
+    // Loop over the shifts
+
+    for (jj = 0; jj < np; jj++)
+    {
+        sigmar = shiftr[jj];
+        sigmai = shifti[jj];
+
+        if (cconj)
+        {
+
+            // Skip flag is on; turn it off and proceed to the next shift.
+
+            cconj = 0;
+            continue;
+
+        } else if ((jj < np - 1) && fabsf(sigmai) != 0.0) {
+
+            // This shift has nonzero imaginary part, so we will apply
+            // together with the next one; turn on the skip flag.
+
+            cconj = 1;
+
+        } else if ((jj == np - 1) && (fabsf(sigmai) != 0.0)) {
+
+            // We have one block left but the shift has nonzero imaginary part.
+            // Don't apply it and reduce the number of shifts by incrementing
+            // kev by one.
+
+            *kev += 1;
+            continue;
+        }
+
+        // if sigmai = 0 then
+        //    Apply the jj-th shift ...
+        // else
+        //    Apply the jj-th and (jj+1)-th together ...
+        //    (Note that jj < np at this point in the code)
+        // end
+        // to the current block of H
+
+        istart = 0;
+        while (istart < kplusp - 1)
+        {
+            for (iend = istart; iend < kplusp - 1; iend++)
+            {
+                tst1 = fabsf(h[iend + (iend * ldh)]) + fabsf(h[iend + 1 + (iend + 1) * ldh]);
+                if (tst1 == 0.0)
+                {
+                    tmp_int = kplusp - jj;
+                    tst1 = slanhs_("1", &tmp_int, h, &ldh, workl);
+                }
+                if (fabsf(h[iend+1 + (iend * ldh)]) <= fmaxf(smlnum, ulp * tst1))
+                {
+                    break;
+                }
+            }
+            if (istart == iend)
+            {
+                istart += 1;
+                continue;
+            } else if  ((istart + 1 == iend) && fabsf(sigmai) > 0.0) {
+                istart += 2;
+                continue;
+            } else {
+                h[iend+1 + (iend * ldh)] = 0.0;
+            }
+
+            // We have a block [istart, iend] inclusive.
+            h11 = h[istart + istart * ldh];
+            h21 = h[istart + 1 + istart * ldh];
+
+            if (fabsf(sigmai) == 0.0)
+            {
+
+                f = h11 - sigmar;
+                g = h21;
+                for (i = istart; i < iend; i++)
+                {
+                    slartgp_(&f, &g, &c, &s, &r);
+                    if (i > istart)
+                    {
+                        h[i + (i - 1) * ldh] = r;
+                        h[i + 1 + (i - 1) * ldh] = 0.0;
+                    }
+                    tmp_int = kplusp - i;
+                    srot_(&tmp_int, &h[i + ldh*i], &ldh, &h[i + 1 + ldh*i], &ldh, &c, &s);
+                    tmp_int = (i+2 > iend ? iend : i + 2) + 1;
+                    srot_(&tmp_int, &h[ldh*i], &int1, &h[ldh*(i+1)], &int1, &c, &s);
+                    tmp_int = (i+jj+2 > kplusp ? kplusp : i + jj + 2);
+                    srot_(&tmp_int, &q[ldq*i], &int1, &q[ldq*(i+1)], &int1, &c, &s);
+
+                    if (i < iend - 1)
+                    {
+                        f = h[i+1 + i * ldh];
+                        g = h[i+2 + i * ldh];
+                    }
+                }
+            } else {
+
+                h12 = h[istart + ldh*(istart + 1)];
+                h22 = h[istart + 1 + ldh*(istart + 1)];
+                h32 = h[istart + 2 + ldh*(istart + 1)];
+
+                s = 2.0*sigmar;
+                t = hypotf(sigmar, sigmai);
+                u[0] = (h11*(h11 - s) + t*t) / h21 + h12;
+                u[1] = h11 + h22 - s;
+                u[2] = h32;
+
+                for (i = istart; i < iend; i++)
+                {
+                    nr = iend - i + 1;
+                    nr = (nr > 3? 3 : nr);
+                    slarfg_(&nr, &u[0], &u[1], &int1, &tau);
+                    if (i > istart)
+                    {
+                        h[i + (i - 1) * ldh] = u[0];
+                        h[i + 1 + (i - 1) * ldh] = 0.0;
+                        if (i < iend - 1) { h[i + 2 + (i - 1) * ldh] = 0.0; }
+                    }
+                    u[0] = 1.0;
+
+                    tmp_int = kplusp - i;
+                    slarf_("L", &nr, &tmp_int, u, &int1, &tau, &h[i + ldh*i], &ldh, workl);
+                    ir = (i + 3 > iend ? iend : i + 3) + 1;
+                    slarf_("R", &ir, &nr, u, &int1, &tau, &h[ldh*i], &ldh, workl);
+                    slarf_("R", &kplusp, &nr, u, &int1, &tau, &q[ldq*i], &ldq, workl);
+                    if (i < iend - 1)
+                    {
+                        u[0] = h[i+1 + i * ldh];
+                        u[1] = h[i+2 + i * ldh];
+                        if (i < iend-2) { u[2] = h[i+3 + i * ldh]; }
+                    }
+                }
+            }
+            istart = iend + 1;
+        }
+    }
+    //  Perform a similarity transformation that makes
+    //  sure that H will have non negative sub diagonals
+
+    for (j = 0; j < *kev; j++)
+    {
+        if (h[j+1 + ldh*j] < 0.0)
+        {
+            tmp_int = kplusp - j;
+            sscal_(&tmp_int, &dblm1, &h[j+1 + ldh*j], &ldh);
+            tmp_int = (j+3 > kplusp ? kplusp : j+3);
+            sscal_(&tmp_int, &dblm1, &h[ldh*(j+1)], &int1);
+            tmp_int = (j+np+2 > kplusp ? kplusp : j+np+2);
+            sscal_(&tmp_int, &dblm1, &q[ldq*(j+1)], &int1);
+        }
+    }
+    // 120
+
+    for (i = 0; i < *kev; i++)
+    {
+
+        //  Final check for splitting and deflation.
+        //  Use a standard test as in the QR algorithm
+        //  REFERENCE: LAPACK subroutine dlahqr
+
+        tst1 = fabsf(h[i + ldh*i]) + fabsf(h[i+1 + ldh*(i+1)]);
+        if (tst1 == 0.0)
+        {
+            tst1 = slanhs_("1", kev, h, &ldh, workl);
+        }
+        if (h[i+1 + ldh*i] <= fmaxf(ulp*tst1, smlnum))
+        {
+            h[i+1 + ldh*i] = 0.0;
+        }
+    }
+    // 130
+
+    //  Compute the (kev+1)-st column of (V*Q) and
+    //  temporarily store the result in WORKD(N+1:2*N).
+    //  This is needed in the residual update since we
+    //  cannot GUARANTEE that the corresponding entry
+    //  of H would be zero as in exact arithmetic.
+
+    if (h[*kev + ldh*(*kev-1)] > 0.0)
+    {
+        sgemv_("N", &n, &kplusp, &dbl1, v, &ldv, &q[(*kev)*ldq], &int1, &dbl0, &workd[n], &int1);
+    }
+
+    //  Compute column 1 to kev of (V*Q) in backward order
+    //  taking advantage of the upper Hessenberg structure of Q.
+
+    for (i = 0; i < *kev; i++)
+    {
+        tmp_int = kplusp - i;
+        sgemv_("N", &n, &tmp_int, &dbl1, v, &ldv, &q[(*kev-i-1)*ldq], &int1, &dbl0, workd, &int1);
+        scopy_(&n, workd, &int1, &v[(kplusp-i-1)*ldv], &int1);
+    }
+
+    //   Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev).
+
+    for (i = 0; i < *kev; i++)
+    {
+        scopy_(&n, &v[(kplusp-*kev+i)*ldv], &int1, &v[i*ldv], &int1);
+    }
+
+    //  Copy the (kev+1)-st column of (V*Q) in the appropriate place
+
+    if (h[*kev + ldh*(*kev-1)] > 0.0){
+        scopy_(&n, &workd[n], &int1, &v[ldv*(*kev)], &int1);
+    }
+
+    //  Update the residual vector:
+    //     r <- sigmak*r + betak*v(:,kev+1)
+    //  where
+    //     sigmak = (e_{kplusp}'*Q)*e_{kev}
+    //     betak = e_{kev+1}'*H*e_{kev}
+
+    sscal_(&n, &q[kplusp-1 + ldq*(*kev-1)], resid, &int1);
+
+    if (h[*kev + ldh*(*kev-1)] > 0.0)
+    {
+        saxpy_(&n, &h[*kev + ldh*(*kev-1)], &v[ldv*(*kev)], &int1, resid, &int1);
+    }
+
+    return;
+
+}
+
+
+void
+sngets(struct ARPACK_arnoldi_update_vars_s *V, int* kev, int* np,
+       float* ritzr, float* ritzi, float* bounds)
+{
+
+    //  LM, SM, LR, SR, LI, SI case.
+    //  Sort the eigenvalues of H into the desired order
+    //  and apply the resulting order to BOUNDS.
+    //  The eigenvalues are sorted so that the wanted part
+    //  are always in the last KEV locations.
+    //  We first do a pre-processing sort in order to keep
+    //  complex conjugate pairs together
+
+    switch (V->which)
+    {
+        case which_LM:
+            ssortc(which_LR, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_SM:
+            ssortc(which_SR, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_LR:
+            ssortc(which_LM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_SR:
+            ssortc(which_SM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_LI:
+            ssortc(which_LM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        case which_SI:
+            ssortc(which_SM, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+        default:
+            ssortc(which_LR, 1, *kev + *np, ritzr, ritzi, bounds);
+            break;
+    }
+    ssortc(V->which, 1, *kev + *np, ritzr, ritzi, bounds);
+
+    //  Increase KEV by one if the ( ritzr(np),ritzi(np) )
+    //  = ( ritzr(np+1),-ritzi(np+1) ) and ritz(np) .ne. zero
+    //  Accordingly decrease NP by one. In other words keep
+    //  complex conjugate pairs together.
+
+    if ((ritzr[*np] - ritzr[*np-1] == 0.0) && (ritzi[*np] + ritzi[*np-1] == 0.0))
+    {
+        *np -= 1;
+        *kev += 1;
+    }
+
+    if (V->shift == 1)
+    {
+
+        //  Sort the unwanted Ritz values used as shifts so that
+        //  the ones with largest Ritz estimates are first
+        //  This will tend to minimize the effects of the
+        //  forward instability of the iteration when they shifts
+        //  are applied in subroutine dnapps.
+        //  Be careful and use 'SR' since we want to sort BOUNDS!
+
+        ssortc(which_SR, 1, *np, bounds, ritzr, ritzi);
+    }
+
+    return;
+}
+
+void
+sgetv0(struct ARPACK_arnoldi_update_vars_s *V, int initv, int n, int j,
+       float* v, int ldv, float* resid, float* rnorm, int* ipntr, float* workd)
+{
+    int jj, int1 = 1;
+    const float sq2o2 = sqrtf(2.0) / 2.0;
+    float dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0;;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->info = 0;
+        V->getv0_iter = 0;
+        V->getv0_first = 0;
+        V->getv0_orth = 0;
+
+        //  Possibly generate a random starting vector in RESID
+        //  Skip if this the return of ido_RANDOM.
+
+        if (!(initv))
+        {
+            // Request a random vector from the user into resid
+            V->ido = ido_RANDOM;
+            return;
+        } else {
+            V->ido = ido_RANDOM;
+        }
+    }
+
+    // Back from random vector generation
+    if (V->ido == ido_RANDOM)
+    {
+        //  Force the starting vector into the range of OP to handle
+        //  the generalized problem when B is possibly (singular).
+
+        if (V->getv0_itry == 1)
+        {
+            ipntr[0] = 0;
+            ipntr[1] = n;
+            scopy_(&n, resid, &int1, workd, &int1);
+            V->ido = ido_RANDOM_OPX;
+            return;
+        } else if ((V->getv0_itry > 1) && (V->bmat == 1))
+        {
+            scopy_(&n, resid, &int1, &workd[n], &int1);
+        }
+    }
+
+    //  Back from computing OP*(initial-vector)
+
+    if (V->getv0_first) { goto LINE20; }
+
+    //  Back from computing OP*(orthogonalized-vector)
+
+    if (V->getv0_orth) { goto LINE40; }
+
+    //  Starting vector is now in the range of OP; r = OP*r;
+    //  Compute B-norm of starting vector.
+
+    V->getv0_first = 1;
+    if (V->getv0_itry == 1)
+    {
+        scopy_(&n, &workd[n], &int1, resid, &int1);
+    }
+    if (V->bmat)
+    {
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        scopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE20:
+
+    V->getv0_first = 0;
+    if (V->bmat)
+    {
+        V->getv0_rnorm0 = sdot_(&n, resid, &int1, workd, &int1);
+        V->getv0_rnorm0 = sqrtf(fabsf(V->getv0_rnorm0));
+    } else {
+        V->getv0_rnorm0 = snrm2_(&n, resid, &int1);
+    }
+    *rnorm = V->getv0_rnorm0;
+
+    //  Exit if this is the very first Arnoldi step
+
+    if (j == 0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //  Otherwise need to B-orthogonalize the starting vector against
+    //  the current Arnoldi basis using Gram-Schmidt with iter. ref.
+    //  This is the case where an invariant subspace is encountered
+    //  in the middle of the Arnoldi factorization.
+    //
+    //        s = V^{T}*B*r;   r = r - V*s;
+    //
+    //  Stopping criteria used for iter. ref. is discussed in
+    //  Parlett's book, page 107 and in Gragg & Reichel TOMS paper.
+
+    V->getv0_orth = 1;
+
+LINE30:
+
+    sgemv_("T", &n, &j, &dbl1, v, &ldv, workd, &int1, &dbl0, &workd[n], &int1);
+    sgemv_("N", &n, &j, &dblm1, v, &ldv, &workd[n], &int1, &dbl1, resid, &int1);
+
+    //  Compute the B-norm of the orthogonalized starting vector
+
+    if (V->bmat)
+    {
+        scopy_(&n, resid, &int1, &workd[n], &int1);
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        scopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE40:
+    if (V->bmat)
+    {
+        *rnorm = sdot_(&n, resid, &int1, workd, &int1);
+        *rnorm = sqrtf(fabsf(*rnorm));
+    } else {
+        *rnorm = snrm2_(&n, resid, &int1);
+    }
+
+    //  Check for further orthogonalization.
+
+    if (*rnorm > sq2o2*V->getv0_rnorm0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->getv0_iter += 1;
+    if (V->getv0_iter < 5)
+    {
+
+        //  Perform iterative refinement step
+
+        V->getv0_rnorm0 = *rnorm;
+        goto LINE30;
+    } else {
+
+        //  Iterative refinement step "failed"
+
+        for (jj = 0; jj < n; jj++) { resid[jj] = 0.0; }
+        *rnorm = 0.0;
+        V->info = -1;
+    }
+
+    V->ido = ido_DONE;
+
+    return;
+}
+
+void
+ssortc(const enum ARPACK_which w, const int apply, const int n, float* xreal, float* ximag, float* y)
+{
+    int i, igap, j;
+    float temp;
+    ARPACK_compare_cfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortc_LM;
+            break;
+        case which_SM:
+            f = sortc_SM;
+            break;
+        case which_LR:
+            f = sortc_LR;
+            break;
+        case which_LI:
+            f = sortc_LI;
+            break;
+        case which_SR:
+            f = sortc_SR;
+            break;
+        case which_SI:
+            f = sortc_SI;
+            break;
+        default:
+            f = sortc_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(xreal[j], ximag[j], xreal[j+igap], ximag[j+igap]))
+            {
+                if (j < 0) { break; }
+                temp = xreal[j];
+                xreal[j] = xreal[j+igap];
+                xreal[j+igap] = temp;
+                temp = ximag[j];
+                ximag[j] = ximag[j+igap];
+                ximag[j+igap] = temp;
+
+                if (apply)
+                {
+                    temp = y[j];
+                    y[j] = y[j+igap];
+                    y[j+igap] = temp;
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+}
+
+// The void casts are to avoid compiler warnings for unused parameters
+int
+sortc_LM(const float xre, const float xim, const float xreigap, const float ximigap)
+{
+    return (hypotf(xre, xim) > hypotf(xreigap, ximigap));
+}
+
+int
+sortc_SM(const float xre, const float xim, const float xreigap, const float ximigap)
+{
+    return (hypotf(xre, xim) < hypotf(xreigap, ximigap));
+}
+
+int
+sortc_LR(const float xre, const float xim, const float xreigap, const float ximigap)
+{
+    (void)xim; (void)ximigap;
+    return (xre > xreigap);
+}
+
+int
+sortc_SR(const float xre, const float xim, const float xreigap, const float ximigap)
+{
+    (void)xim; (void)ximigap;
+    return (xre < xreigap);
+}
+
+int
+sortc_LI(const float xre, const float xim, const float xreigap, const float ximigap)
+{
+    (void)xre; (void)xreigap;
+    return (fabsf(xim) > fabsf(ximigap));
+}
+
+int
+sortc_SI(const float xre, const float xim, const float xreigap, const float ximigap)
+{
+    (void)xre; (void)xreigap;
+    return (fabsf(xim) < fabsf(ximigap));
+}
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.h
new file mode 100644
index 0000000000..f869f6bd5a
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single.h
@@ -0,0 +1,32 @@
+#ifndef _ARPACK_N_SINGLE_H
+#define _ARPACK_N_SINGLE_H
+
+#include "_arpack.h"
+
+// BLAS Routines used
+void saxpy_(int* n, float* alpha, float* x, int* incx, float* y, int* incy);
+void scopy_(int* n, float* x, int* incx, float* y, int* incy);
+float sdot_(int* n, float* x, int* incx, float* y, int* incy);
+void sger_(int* m, int* n, float* alpha, float* x, int* incx, float* y, int* incy, float* a, int* lda);
+float snrm2_(int* n, float* x, int* incx);
+void sscal_(int* n, float* alpha, float* x, int* incx);
+void sgemv_(char* trans, int* m, int* n, float* alpha, float* a, int* lda, float* x, int* incx, float* beta, float* y, int* incy);
+void srot_(int* n, float* x, int* incx, float* y, int* incy, float* c, float* s);
+void strmm_(char* side, char* uplo, char* transa, char* diag, int* m, int* n, float* alpha, float* a, int* lda, float* b, int* ldb);
+
+// LAPACK Routines used
+void sgeqr2_(int* m, int* n, float* a, int* lda, float* tau, float* work, int* info);
+void slacpy_(char* uplo, int* m, int* n, float* a, int* lda, float* b, int* ldb);
+void slahqr_(int* wantt, int* wantz, int* n, int* ilo, int* ihi, float* h, int* ldh, float* wr, float* wi, int* iloz, int* ihiz, float* z, int* ldz, int* info );
+float slanhs_(char* norm, int* n, float* a, int* lda, float* work);
+void slaset_(char* uplo, int* m, int* n, float* alpha, float* beta, float* a, int* lda);
+void slarf_(char* side, int* m, int* n, float* v, int* incv, float* tau, float* c, int* ldc, float* work);
+void slarfg_(int* n, float* alpha, float* x, int* incx, float* tau);
+void slartg_(float* f, float* g, float* c, float* s, float* r);
+void slartgp_(float* f, float* g, float* c, float* s, float* r);
+void slascl_(char* mtype, int* kl, int* ku, float* cfrom, float* cto, int* m, int* n, float* a, int* lda, int* info);
+void sorm2r_(char* side, char* trans, int* m, int* n, int* k, float* a, int* lda, float* tau, float* c, int* ldc, float* work, int* info);
+void strevc_(char* side, char* howmny, int* select, int* n, float* t, int* ldt, float* vl, int* ldvl, float* vr, int* ldvr, int* mm, int* m, float* work, int* info);
+void strsen_(char* job, char* compq, int* select, int* n, float* t, int* ldt, float* q, int* ldq, float* wr, float* wi, int* m, float* s, float* sep, float* work, int* lwork, int* iwork, int* liwork, int* info);
+
+#endif
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.c b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.c
new file mode 100644
index 0000000000..d9e2037a86
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.c
@@ -0,0 +1,1861 @@
+#include "_arpack_n_single_complex.h"
+
+typedef int ARPACK_compare_cfunc(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+typedef int ARPACK_compare_rfunc(const float, const float);
+
+static const float unfl = 1.1754943508222875e-38;
+// static const float ovfl = 1.0 / 1.1754943508222875e-38;
+static const float ulp = 1.1920928955078125e-07;
+
+static ARPACK_CPLXF_TYPE cdotc_(const int* n, const ARPACK_CPLXF_TYPE* restrict x, const int* incx, const ARPACK_CPLXF_TYPE* restrict y, const int* incy);
+static void cgetv0(struct ARPACK_arnoldi_update_vars_s*, int, int, int, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, float*, int*, ARPACK_CPLXF_TYPE*);
+static void cnaup2(struct ARPACK_arnoldi_update_vars_s*, ARPACK_CPLXF_TYPE* , ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, int*, ARPACK_CPLXF_TYPE*, float*);
+static void cnaitr(struct ARPACK_arnoldi_update_vars_s*, int, int, ARPACK_CPLXF_TYPE*,float*, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, int, int*, ARPACK_CPLXF_TYPE*);
+static void cnapps(int, int*, int, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*);
+static void cneigh(float*, int, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*, int, ARPACK_CPLXF_TYPE*, float*, int*);
+static void cngets(struct ARPACK_arnoldi_update_vars_s*, int*, int*, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*);
+static void csortc(const enum ARPACK_which w, const int, const int, ARPACK_CPLXF_TYPE*, ARPACK_CPLXF_TYPE*);
+static int sortc_LM(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+static int sortc_SM(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+static int sortc_LR(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+static int sortc_SR(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+static int sortc_LI(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+static int sortc_SI(const ARPACK_CPLXF_TYPE, const ARPACK_CPLXF_TYPE);
+
+enum ARPACK_neupd_type {
+    REGULAR,
+    SHIFTI,
+    REALPART,
+    IMAGPART
+};
+
+
+void
+ARPACK_cneupd(struct ARPACK_arnoldi_update_vars_s *V, int rvec, int howmny, int* select,
+       ARPACK_CPLXF_TYPE* d, ARPACK_CPLXF_TYPE* z, int ldz, ARPACK_CPLXF_TYPE sigma,
+       ARPACK_CPLXF_TYPE* workev, ARPACK_CPLXF_TYPE* resid, ARPACK_CPLXF_TYPE* v, int ldv,
+       int* ipntr, ARPACK_CPLXF_TYPE* workd, ARPACK_CPLXF_TYPE* workl, float* rwork)
+{
+    const float eps23 = pow(ulp, 2.0 / 3.0);
+    int ibd, ih, iheig, ihbds, iuptri, invsub, irz, iwev, j, jj;
+    int bounds, k, ldh, ldq, np, numcnv, outncv, reord, ritz, wr;
+    int ierr = 0, int1 = 1, tmp_int = 0, nconv2 = 0;
+    float conds, sep, temp1, rtemp;
+    ARPACK_CPLXF_TYPE rnorm, temp;
+    ARPACK_CPLXF_TYPE cdbl0 = ARPACK_cplxf(0.0, 0.0);
+    ARPACK_CPLXF_TYPE cdbl1 = ARPACK_cplxf(1.0, 0.0);
+    ARPACK_CPLXF_TYPE cdblm1 = ARPACK_cplxf(-1.0, 0.0);
+    ARPACK_CPLXF_TYPE vl[1] = { cdbl0 };
+    enum ARPACK_neupd_type TYP;
+
+    if (V->nconv <= 0) {
+        ierr = -14;
+    } else if (V->n <= 0) {
+        ierr = -1;
+    } else if (V->nev <= 0) {
+        ierr = -2;
+    } else if ((V->ncv <= V->nev + 1) || (V->ncv > V->n)) {
+        ierr = -3;
+    } else if ((V->which > 5) || (V->which < 0)) {
+        ierr = -5;
+    } else if ((V->bmat != 0) && (V->bmat != 1)) {
+        ierr = -6;
+    } else if ((rvec) && ((howmny < 0) || (howmny > 2))) {
+        ierr = -13;
+    } else if (howmny == 2) {
+        ierr = -12;  // NotImplementedError
+    }
+
+    if ((V->mode == 1) || (V->mode == 2)) {
+        TYP = REGULAR;
+    } else if (V->mode == 3) {
+        TYP = SHIFTI;
+    } else {
+        ierr = -10;
+    }
+
+    if ((V->mode == 1) && (V->bmat)) { ierr = -11; }
+
+    if (ierr != 0) {
+        V->info = ierr;
+        return;
+    }
+
+    //  Pointer into WORKL for address of H, RITZ, WORKEV, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //  workl(1:ncv*ncv) := generated Hessenberg matrix
+    //  workl(ncv*ncv+1:ncv*ncv+ncv) := ritz values
+    //  workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv) := error bounds
+
+    //  The following is used and set by ZNEUPD.
+    //  workl(ncv*ncv+2*ncv+1:ncv*ncv+3*ncv) := The untransformed
+    //                                       Ritz values.
+    //  workl(ncv*ncv+3*ncv+1:ncv*ncv+4*ncv) := The untransformed
+    //                                       error bounds of
+    //                                       the Ritz values
+    //  workl(ncv*ncv+4*ncv+1:2*ncv*ncv+4*ncv) := Holds the upper
+    //                                       triangular matrix
+    //                                       for H.
+    //  workl(2*ncv*ncv+4*ncv+1: 3*ncv*ncv+4*ncv) := Holds the
+    //                                       associated matrix
+    //                                       representation of
+    //                                       the invariant
+    //                                       subspace for H.
+    //  GRAND total of NCV * ( 3 * NCV + 4 ) locations.
+
+    ih     = ipntr[4];
+    ritz   = ipntr[5];
+    bounds = ipntr[7];
+    ldh = V->ncv;
+    ldq = V->ncv;
+    iheig  = bounds + ldh;
+    ihbds  = iheig  + ldh;
+    iuptri = ihbds  + ldh;
+    invsub = iuptri + ldh*V->ncv;
+    ipntr[8]  = iheig;
+    ipntr[10] = ihbds;
+    ipntr[11] = iuptri;
+    ipntr[12] = invsub;
+    wr = 0;
+    iwev = wr + V->ncv;
+
+    //  irz points to the Ritz values computed
+    //      by _neigh before exiting _naup2.
+    //  ibd points to the Ritz estimates
+    //      computed by _neigh before exiting
+    //      _naup2.
+
+    irz = ipntr[13] + (V->ncv)*(V->ncv);
+    ibd = irz + V->ncv;
+
+    //  RNORM is B-norm of the RESID(1:N).
+
+    rnorm = workl[ih+2];
+    workl[ih+2] = ARPACK_cplxf(0.0, 0.0);
+
+    if (rvec) {
+        reord = 0;
+
+        //  Use the temporary bounds array to store indices
+        //  These will be used to mark the select array later
+
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[bounds + j] = ARPACK_cplxf(j, 0.0);
+            select[j] = 0;
+        }
+        // 10
+
+        //  Select the wanted Ritz values.
+        //  Sort the Ritz values so that the
+        //  wanted ones appear at the tailing
+        //  NEV positions of workl(irr) and
+        //  workl(iri).  Move the corresponding
+        //  error estimates in workl(ibd)
+        //  accordingly.
+
+        np = V->ncv - V->nev;
+        cngets(V, &V->nev, &np, &workl[irz], &workl[bounds]);
+
+        //  Record indices of the converged wanted Ritz values
+        //  Mark the select array for possible reordering
+
+        numcnv = 0;
+        for (j = 1; j <= V->ncv; j++)
+        {
+            temp1 = fmax(eps23, cabsf(workl[irz + V->ncv - j]));
+            jj = (int)crealf(workl[bounds + V->ncv - j]);
+
+            if ((numcnv < V->nconv) && (cabsf(workl[ibd + jj]) <= V->tol*temp1))
+            {
+                select[jj] = 1;
+                numcnv += 1;
+                if (jj > V->nconv - 1) { reord = 1; }
+            }
+        }
+        // 11
+
+        //  Check the count (numcnv) of converged Ritz values with
+        //  the number (nconv) reported by znaupd.  If these two
+        //  are different then there has probably been an error
+        //  caused by incorrect passing of the znaupd data.
+
+        if (numcnv != V->nconv)
+        {
+            V->info = -15;
+            return;
+        }
+
+        //  Call LAPACK routine zlahqr  to compute the Schur form
+        //  of the upper Hessenberg matrix returned by ZNAUPD .
+        //  Make a copy of the upper Hessenberg matrix.
+        //  Initialize the Schur vector matrix Q to the identity.
+
+        tmp_int = ldh*V->ncv;
+        ccopy_(&tmp_int, &workl[ih], &int1, &workl[iuptri], &int1);
+        claset_("A", &V->ncv, &V->ncv, &cdbl0, &cdbl1, &workl[invsub], &ldq);
+        clahqr_(&int1, &int1, &V->ncv, &int1, &V->ncv, &workl[iuptri], &ldh,
+                &workl[iheig], &int1, &V->ncv, &workl[invsub], &ldq, &ierr);
+        ccopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        if (ierr != 0)
+        {
+            V->info = -8;
+            return;
+        }
+
+        if (reord)
+        {
+
+            //  Reorder the computed upper triangular matrix.
+
+            ctrsen_("N", "V", select, &V->ncv, &workl[iuptri], &ldh, &workl[invsub], &ldq,
+                    &workl[iheig], &nconv2, &conds, &sep, workev, &V->ncv, &ierr);
+
+            if (nconv2 < V->nconv) { V->nconv = nconv2; }
+            if (ierr == 1) {
+                V->info = 1;
+                return;
+            }
+        }
+
+        //  Copy the last row of the Schur basis matrix
+        //  to workl(ihbds).  This vector will be used
+        //  to compute the Ritz estimates of converged
+        //  Ritz values.
+
+        ccopy_(&V->ncv, &workl[invsub + V->ncv - 1], &ldq, &workl[ihbds], &int1);
+
+        //  Place the computed eigenvalues of H into D
+        //  if a spectral transformation was not used.
+
+        if (TYP == REGULAR)
+        {
+            ccopy_(&V->nconv, &workl[iheig], &int1, d, &int1);
+        }
+
+        //  Compute the QR factorization of the matrix representing
+        //  the wanted invariant subspace located in the first NCONV
+        //  columns of workl(invsub,ldq).
+
+        cgeqr2_(&V->ncv, &V->nconv, &workl[invsub], &ldq, workev, &workev[V->ncv], &ierr);
+
+        //  * Postmultiply V by Q using zunm2r.
+        //  * Copy the first NCONV columns of VQ into Z.
+        //  * Postmultiply Z by R.
+        //  The N by NCONV matrix Z is now a matrix representation
+        //  of the approximate invariant subspace associated with
+        //  the Ritz values in workl(iheig). The first NCONV
+        //  columns of V are now approximate Schur vectors
+        //  associated with the upper triangular matrix of order
+        //  NCONV in workl(iuptri).
+
+        cunm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[invsub], &ldq, workev, v, &ldv, &workd[V->n], &ierr);
+        clacpy_("A", &V->n, &V->nconv, v, &ldv, z, &ldz);
+
+        for (int j = 0; j < V->nconv; j++)
+        {
+
+            //  Perform both a column and row scaling if the
+            //  diagonal element of workl(invsub,ldq) is negative
+            //  I'm lazy and don't take advantage of the upper
+            //  triangular form of workl(iuptri,ldq).
+            //  Note that since Q is orthogonal, R is a diagonal
+            //  matrix consisting of plus or minus ones.
+
+            if (crealf(workl[invsub + j*ldq + j]) < 0.0)
+            {
+                cscal_(&V->nconv, &cdblm1, &workl[iuptri + j], &ldq);
+                cscal_(&V->nconv, &cdblm1, &workl[iuptri + j*ldq], &int1);
+            }
+        }
+        // 20
+
+        if (howmny == 0)
+        {
+
+            //  Compute the NCONV wanted eigenvectors of T
+            //  located in workl(iuptri,ldq).
+
+            for (int j = 0; j < V->ncv; j++)
+            {
+                if (j < V->nconv)
+                {
+                    select[j] = 1;
+                } else {
+                    select[j] = 0;
+                }
+            }
+            // 30
+
+            ctrevc_("R", "S", select, &V->ncv, &workl[iuptri], &ldq, vl, &int1,
+                    &workl[invsub], &ldq, &V->ncv, &outncv, workev, rwork, &ierr);
+            if (ierr != 0)
+            {
+                V->info = -9;
+                return;
+            }
+
+            //  Scale the returning eigenvectors so that their
+            //  Euclidean norms are all one. LAPACK subroutine
+            //  ztrevc returns each eigenvector normalized so
+            //  that the element of largest magnitude has
+            //  magnitude 1.
+
+            for (j = 0; j < V->nconv; j++)
+            {
+                rtemp = 1.0 / scnrm2_(&V->ncv, &workl[invsub + j*ldq], &int1);
+                csscal_(&V->ncv, &rtemp, &workl[invsub + j*ldq], &int1);
+
+                //  Ritz estimates can be obtained by taking
+                //  the inner product of the last row of the
+                //  Schur basis of H with eigenvectors of T.
+                //  Note that the eigenvector matrix of T is
+                //  upper triangular, thus the length of the
+                //  inner product can be set to j.
+                tmp_int = j + 1;
+                workev[j] = cdotc_(&tmp_int, &workl[ihbds], &int1, &workl[invsub + j*ldq], &int1);
+            }
+            // 40
+
+            //  Copy Ritz estimates into workl(ihbds)
+
+            ccopy_(&V->nconv, workev, &int1, &workl[ihbds], &int1);
+
+            //  The eigenvector mactirx Q of T is triangular. Form Z*Q
+
+            ctrmm_("R", "U", "N", "N", &V->n, &V->nconv, &cdbl1, &workl[invsub], &ldq, z, &ldz);
+
+        }
+
+    } else {
+
+        // An approximate invariant subspace is not needed.
+        // Place the Ritz values computed ZNAUPD into D.
+
+        ccopy_(&V->nconv, &workl[ritz], &int1, d, &int1);
+        ccopy_(&V->nconv, &workl[ritz], &int1, &workl[iheig], &int1);
+        ccopy_(&V->nconv, &workl[bounds], &int1, &workl[ihbds], &int1);
+
+    }
+
+    //  Transform the Ritz values and possibly vectors
+    //  and corresponding error bounds of OP to those
+    //  of A*x = lambda*B*x.
+
+    if (TYP == REGULAR)
+    {
+        if (rvec)
+        {
+            cscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+        }
+    } else {
+
+        //    A spectral transformation was used.
+        //  * Determine the Ritz estimates of the
+        //    Ritz values in the original system.
+
+        if (rvec)
+        {
+            cscal_(&V->ncv, &rnorm, &workl[ihbds], &int1);
+        }
+        for (k = 0; k < V->ncv; k++)
+        {
+#if defined(_MSC_VER)
+            // Complex division is not supported in MSVC, multiply with reciprocal
+            temp = _FCmulcr(conjf(workl[iheig + k]), 1.0 / cabsf(workl[iheig + k]));
+            workl[ihbds + k] = _FCmulcc(_FCmulcc(workl[ihbds + k], temp), temp);
+#else
+            temp = workl[iheig + k];
+            workl[ihbds + k] = workl[ihbds + k] / temp / temp;
+#endif
+        }
+        // 50
+    }
+
+    //  *  Transform the Ritz values back to the original system.
+    //     For TYPE = 'SHIFTI' the transformation is
+    //              lambda = 1/theta + sigma
+    //  NOTES:
+    //  *The Ritz vectors are not affected by the transformation.
+
+    if (TYP == SHIFTI)
+    {
+        for (k = 0; k < V->nconv; k++)
+        {
+#if defined(_MSC_VER)
+            // Complex division is not supported in MSVC
+            temp = _FCmulcr(conjf(workl[iheig + k]), 1.0 / cabsf(workl[iheig + k]));
+            d[k] = ARPACK_cplxf(crealf(temp) + crealf(sigma), cimagf(temp) + cimagf(sigma));
+#else
+            d[k] = 1.0 / workl[iheig + k] + sigma;
+#endif
+        }
+        // 60
+    }
+
+    //  Eigenvector Purification step. Formally perform
+    //  one of inverse subspace iteration. Only used
+    //  for MODE = 3. See reference 3.
+
+    if ((rvec) && (howmny == 0) && (TYP == SHIFTI))
+    {
+
+        //  Purify the computed Ritz vectors by adding a
+        //  little bit of the residual vector:
+        //                       T
+        //           resid(:)*( e    s ) / theta
+        //                       NCV
+        //  where H s = s theta.
+
+        for (j = 0; j < V->nconv; j++)
+        {
+            if ((crealf(workl[iheig+j]) != 0.0) || (cimagf(workl[iheig+j]) != 0.0))
+            {
+#if defined(_MSC_VER)
+                // Complex division is not supported in MSVC
+                temp = _FCmulcr(conjf(workl[iheig + j]), 1.0 / cabsf(workl[iheig + j]));
+                workev[j] = _FCmulcc(workl[invsub + j*ldq + V->ncv], temp);
+#else
+                workev[j] = workl[invsub + j*ldq + V->ncv] / workl[iheig+j];
+#endif
+            }
+        }
+        // 100
+
+        //  Perform a rank one update to Z and
+        //  purify all the Ritz vectors together.
+
+        cgeru_(&V->n, &V->nconv, &cdbl1, resid, &int1, workev, &int1, z, &ldz);
+    }
+
+    return;
+}
+
+
+void
+ARPACK_cnaupd(struct ARPACK_arnoldi_update_vars_s *V, ARPACK_CPLXF_TYPE* resid,
+       ARPACK_CPLXF_TYPE* v, int ldv, int* ipntr, ARPACK_CPLXF_TYPE* workd,
+       ARPACK_CPLXF_TYPE* workl, float* rwork)
+{
+    int bounds, ierr = 0, ih, iq, iw, ldh, ldq, next, iritz;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        // perform basic checks
+        if (V->n <= 0) {
+            ierr = -1;
+        } else if (V->nev <= 0) {
+            ierr = -2;
+        } else if ((V->ncv < V->nev + 1) || (V->ncv > V->n)) {
+            ierr = -3;
+        } else if (V->maxiter <= 0) {
+            ierr = -4;
+        } else if ((V->which < 0) || (V->which > 5)) {
+            ierr = -5;
+        } else if ((V->bmat != 0) && (V->bmat != 1)) {
+            ierr = -6;
+        } else if ((V->mode < 1) || (V->mode > 3)) {
+            ierr = -10;
+        } else if ((V->mode == 1) && (V->bmat == 1)) {
+            ierr = -11;
+        }
+
+        if (ierr != 0) {
+            V->info = ierr;
+            V->ido = 99;
+            return;
+        }
+
+        if (V->tol <= 0.0) {
+            V-> tol = ulp;
+        }
+
+        if ((V->shift != 0) && (V->shift != 1) && (V->shift != 2))
+        {
+            V->shift = 1;
+        }
+
+        //  NP is the number of additional steps to
+        //  extend the length NEV Lanczos factorization.
+        //  NEV0 is the local variable designating the
+        //  size of the invariant subspace desired.
+
+        V->np = V->ncv - V->nev;
+
+        for (int j = 0; j < 3 * (V->ncv*V->ncv) + 6*V->ncv; j++)
+        {
+            workl[j] = ARPACK_cplxf(0.0, 0.0);
+        }
+    }
+    //  Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    //  etc... and the remaining workspace.
+    //  Also update pointer to be used on output.
+    //  Memory is laid out as follows:
+    //  workl(1:ncv*ncv) := generated Hessenberg matrix
+    //  workl(ncv*ncv+1:ncv*ncv+ncv) := the ritz values
+    //  workl(ncv*ncv+ncv+1:ncv*ncv+2*ncv)   := error bounds
+    //  workl(ncv*ncv+2*ncv+1:2*ncv*ncv+2*ncv) := rotation matrix Q
+    //  workl(2*ncv*ncv+2*ncv+1:3*ncv*ncv+5*ncv) := workspace
+    //  The final workspace is needed by subroutine zneigh  called
+    //  by znaup2 . Subroutine zneigh  calls LAPACK routines for
+    //  calculating eigenvalues and the last row of the eigenvector
+    //  matrix.
+
+    ldh    = V->ncv;
+    ldq    = V->ncv;
+    ih     = 0;
+    iritz  = ih     + ldh*V->ncv;
+    bounds = iritz  + V->ncv;
+    iq     = bounds + V->ncv;
+    iw     = iq     + ldq*V->ncv;
+    next   = iw     + (V->ncv*V->ncv) + 3*V->ncv;
+
+    ipntr[3] = next;
+    ipntr[4] = ih;
+    ipntr[5] = iritz;
+    ipntr[6] = iq;
+    ipntr[7] = bounds;
+    ipntr[13]  = iw;
+
+    cnaup2(V, resid, v, ldv, &workl[ih], ldh, &workl[iritz], &workl[bounds],
+           &workl[iq], ldq, &workl[iw], ipntr, workd, rwork);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP or shifts.
+
+    if (V->ido != ido_DONE) { return; }
+
+    V->nconv = V->np;
+
+    if (V->info < 0) { return; }
+    if (V->info == 2) { V->info = 3; }
+
+    return;
+}
+
+
+void
+cnaup2(struct ARPACK_arnoldi_update_vars_s *V, ARPACK_CPLXF_TYPE* resid,
+       ARPACK_CPLXF_TYPE* v, int ldv, ARPACK_CPLXF_TYPE* h, int ldh,
+       ARPACK_CPLXF_TYPE* ritz, ARPACK_CPLXF_TYPE* bounds,
+       ARPACK_CPLXF_TYPE* q, int ldq, ARPACK_CPLXF_TYPE* workl, int* ipntr,
+       ARPACK_CPLXF_TYPE* workd, float* rwork)
+{
+    enum ARPACK_which temp_which;
+    int i, int1 = 1, j, tmp_int;
+    const float eps23 = pow(ulp, 2.0 / 3.0);
+    float temp = 0.0, rtemp;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->aup2_nev0 = V->nev;
+        V->aup2_np0 = V->np;
+
+        //  kplusp is the bound on the largest
+        //         Lanczos factorization built.
+        //  nconv is the current number of
+        //         "converged" eigenvlues.
+        //  iter is the counter on the current
+        //       iteration step.
+
+        V->aup2_kplusp = V->nev + V->np;
+        V->nconv = 0;
+        V->aup2_iter = 0;
+
+        //  Set flags for computing the first NEV
+        //  steps of the Arnoldi factorization.
+
+        V->aup2_getv0 = 1;
+        V->aup2_update = 0;
+        V->aup2_ushift = 0;
+        V->aup2_cnorm = 0;
+
+        if (V->info != 0)
+        {
+
+            //  User provides the initial residual vector.
+
+            V->aup2_initv = 1;
+            V->info = 0;
+        } else {
+            V->aup2_initv = 0;
+        }
+    }
+
+    //  Get a possibly random starting vector and
+    //  force it into the range of the operator OP.
+
+    if (V->aup2_getv0)
+    {
+        V->getv0_itry = 1;
+        cgetv0(V, V->aup2_initv, V->n, 0, v, ldv, resid, &V->aup2_rnorm, ipntr, workd);
+        if (V->ido != ido_DONE) { return; }
+        if (V->aup2_rnorm == 0.0)
+        {
+            V->info = -9;
+            V->ido = ido_DONE;
+            return;
+        }
+        V->aup2_getv0 = 0;
+        V->ido = ido_FIRST;
+    }
+
+    //  Back from reverse communication :
+    //  continue with update step
+
+    if (V->aup2_update) { goto LINE20; }
+
+    //  Back from computing user specified shifts
+
+    if (V->aup2_ushift) { goto LINE50; }
+
+    //  Back from computing residual norm
+    //  at the end of the current iteration
+
+    if (V->aup2_cnorm) { goto LINE100; }
+
+    //  Compute the first NEV steps of the Arnoldi factorization
+
+    cnaitr(V, 0, V->nev, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //
+    //            M A I N  ARNOLDI  I T E R A T I O N  L O O P
+    //            Each iteration implicitly restarts the Arnoldi
+    //            factorization in place.
+    //
+
+LINE1000:
+    V->aup2_iter += 1;
+
+    //  Compute NP additional steps of the Arnoldi factorization.
+    //  Adjust NP since NEV might have been updated by last call
+    //  to the shift application routine dnapps .
+
+    V->np = V->aup2_kplusp - V->nev;
+    V->ido = ido_FIRST;
+
+LINE20:
+    V->aup2_update = 1;
+
+    cnaitr(V, V->nev, V->np, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0) {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+    V->aup2_update = 0;
+
+    //  Compute the eigenvalues and corresponding error bounds
+    //  of the current upper Hessenberg matrix.
+
+    cneigh(&V->aup2_rnorm, V->aup2_kplusp, h, ldh, ritz, bounds, q, ldq, workl, rwork, &V->info);
+
+    if (V->info != 0)
+    {
+       V->info = -8;
+       V->ido = ido_DONE;
+       return;
+    }
+
+    //  Select the wanted Ritz values and their bounds
+    //  to be used in the convergence test.
+    //  The wanted part of the spectrum and corresponding
+    //  error bounds are in the last NEV loc. of RITZ,
+    //  and BOUNDS respectively.
+
+    V->nev = V->aup2_nev0;
+    V->np = V->aup2_np0;
+
+    //  Make a copy of Ritz values and the corresponding
+    //  Ritz estimates obtained from zneigh .
+    tmp_int = V->aup2_kplusp * V->aup2_kplusp;
+    ccopy_(&V->aup2_kplusp, ritz, &int1, &workl[tmp_int], &int1);
+    tmp_int += V->aup2_kplusp;
+    ccopy_(&V->aup2_kplusp, bounds, &int1, &workl[tmp_int], &int1);
+
+    //  Select the wanted Ritz values and their bounds
+    //  to be used in the convergence test.
+    //  The wanted part of the spectrum and corresponding
+    //  bounds are in the last NEV loc. of RITZ
+    //  BOUNDS respectively.
+
+    cngets(V, &V->nev, &V->np, ritz, bounds);
+
+    //  Convergence test: currently we use the following criteria.
+    //  The relative accuracy of a Ritz value is considered
+    //  acceptable if:
+    //
+    //  error_bounds(i) .le. tol*max(eps23, magnitude_of_ritz(i)).
+    //
+    V->nconv = 0;
+    for (i = 0; i < V->nev; i++)
+    {
+        rtemp = fmax(eps23, cabsf(ritz[V->np + i]));
+        if (cabsf(bounds[V->np + i]) <= V->tol*rtemp)
+        {
+            V->nconv += 1;
+        }
+    }
+    // 25
+
+    //  Count the number of unwanted Ritz values that have zero
+    //  Ritz estimates. If any Ritz estimates are equal to zero
+    //  then a leading block of H of order equal to at least
+    //  the number of Ritz values with zero Ritz estimates has
+    //  split off. None of these Ritz values may be removed by
+    //  shifting. Decrease NP the number of shifts to apply. If
+    //  no shifts may be applied, then prepare to exit
+
+    // We are modifying V->np hence the temporary variable.
+    int nptemp = V->np;
+
+    for (j = 0; j < nptemp; j++)
+    {
+        if ((crealf(bounds[j]) == 0.0) && (cimagf(bounds[j]) == 0.0))
+        {
+            V->np -= 1;
+            V->nev += 1;
+        }
+    }
+    // 30
+
+    if ((V->nconv >= V->aup2_nev0) || (V->aup2_iter > V->maxiter) || (V->np == 0))
+    {
+
+        //  Prepare to exit. Put the converged Ritz values
+        //  and corresponding bounds in RITZ(1:NCONV) and
+        //  BOUNDS(1:NCONV) respectively. Then sort. Be
+        //  careful when NCONV > NP
+
+        //   Use h( 3,1 ) as storage to communicate
+        //   rnorm to _neupd if needed
+
+         h[2] = ARPACK_cplxf(V->aup2_rnorm, 0.0);
+
+        // Sort Ritz values so that converged Ritz
+        // values appear within the first NEV locations
+        // of ritz and bounds, and the most desired one
+        // appears at the front.
+
+        // Translation note: Is this all because ARPACK did not have complex sort?
+
+        if (V->which == which_LM) { temp_which = which_SM; }
+        if (V->which == which_SM) { temp_which = which_LM; }
+        if (V->which == which_LR) { temp_which = which_SR; }
+        if (V->which == which_SR) { temp_which = which_LR; }
+        if (V->which == which_LI) { temp_which = which_SI; }
+        if (V->which == which_SI) { temp_which = which_LI; }
+
+        csortc(temp_which, 1, V->aup2_kplusp, ritz, bounds);
+
+        //  Scale the Ritz estimate of each Ritz value
+        //  by 1 / max(eps23,magnitude of the Ritz value).
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmax(eps23, cabsf(ritz[j]));
+            bounds[j] = ARPACK_cplxf(crealf(bounds[j]) / temp, cimagf(bounds[j]) / temp);
+        }
+        // 35
+
+        //  Sort the Ritz values according to the scaled Ritz
+        //  estimates.  This will push all the converged ones
+        //  towards the front of ritzr, ritzi, bounds
+        //  (in the case when NCONV < NEV.)
+
+        temp_which = which_LM;
+        csortc(temp_which, 1, V->aup2_nev0, bounds, ritz);
+
+        //  Scale the Ritz estimate back to its original
+        //  value.
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmax(eps23, cabsf(ritz[j]));
+            bounds[j] = ARPACK_cplxf(crealf(bounds[j]) * temp, cimagf(bounds[j]) * temp);
+        }
+        // 40
+
+        //  Sort the converged Ritz values again so that
+        //  the "threshold" value appears at the front of
+        //  ritzr, ritzi and bound.
+
+        csortc(V->which, 1, V->nconv, ritz, bounds);
+
+        if ((V->aup2_iter > V->maxiter) && (V->nconv < V->aup2_nev0))
+        {
+
+            //  Max iterations have been exceeded.
+
+            V->info = 1;
+        }
+
+        if ((V->np == 0) && (V->nconv < V->aup2_nev0))
+        {
+
+            //  No shifts to apply.
+
+            V->info = 2;
+        }
+
+        V->np = V->nconv;
+        V->iter = V->aup2_iter;
+        V->nev = V->nconv;
+        V->ido = ido_DONE;
+        return;
+
+    } else if ((V->nconv < V->aup2_nev0) && (V->shift)) {
+
+        //  Do not have all the requested eigenvalues yet.
+        //  To prevent possible stagnation, adjust the size
+        //  of NEV.
+
+        int nevbef = V->nev;
+        V->nev += (V->nconv > (V->np / 2) ? (V->np / 2) : V->nconv);
+        if ((V->nev == 1) && (V->aup2_kplusp >= 6)) {
+            V->nev = V->aup2_kplusp / 2;
+        } else if ((V->nev == 1) && (V->aup2_kplusp > 3)) {
+            V->nev = 2;
+        }
+
+        V->np = V->aup2_kplusp - V->nev;
+
+        // If the size of NEV was just increased
+        // resort the eigenvalues.
+
+        if (nevbef < V->nev) {
+            cngets(V, &V->nev, &V->np, ritz, bounds);
+        }
+    }
+
+    if (V->shift == 0)
+    {
+
+        //  User specified shifts: pop back out to get the shifts
+        //  and return them in the first 2*NP locations of WORKL.
+
+        V->aup2_ushift = 1;
+        V->ido = ido_USER_SHIFT;
+        return;
+    }
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  User specified shifts are returned
+    //  in WORKL(1:2*NP)
+
+    V->aup2_ushift = 0;
+
+    if (V->shift != 1)
+    {
+
+        //  Move the NP shifts from WORKL to
+        //  RITZR, RITZI to free up WORKL
+        //  for non-exact shift case.
+
+        ccopy_(&V->np, workl, &int1, ritz, &int1);
+    }
+
+    //  Apply the NP implicit shifts by QR bulge chasing.
+    //  Each shift is applied to the whole upper Hessenberg
+    //  matrix H.
+    //  The first 2*N locations of WORKD are used as workspace.
+
+    cnapps(V->n, &V->nev, V->np, ritz, v, ldv, h, ldh, resid, q, ldq, workl, workd);
+
+    //  Compute the B-norm of the updated residual.
+    //  Keep B*RESID in WORKD(1:N) to be used in
+    //  the first step of the next call to dnaitr .
+
+    V->aup2_cnorm = 1;
+    if (V->bmat)
+    {
+        ccopy_(&V->n, resid, &int1, &workd[V->n], &int1);
+        ipntr[0] = V->n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*RESID
+
+        return;
+    } else {
+        ccopy_(&V->n, resid, &int1, workd, &int1);
+    }
+
+LINE100:
+
+    //  Back from reverse communication;
+    //  WORKD(1:N) := B*RESID
+
+    if (V->bmat)
+    {
+        V->aup2_rnorm = sqrt(cabsf(cdotc_(&V->n, resid, &int1, workd, &int1)));
+    } else {
+        V->aup2_rnorm = scnrm2_(&V->n, resid, &int1);
+    }
+    V->aup2_cnorm = 0;
+
+    goto LINE1000;
+
+    //
+    //   E N D     O F     M A I N     I T E R A T I O N     L O O P
+    //
+
+}
+
+
+static void
+cnaitr(struct ARPACK_arnoldi_update_vars_s *V, int k, int np, ARPACK_CPLXF_TYPE* resid,
+       float* rnorm, ARPACK_CPLXF_TYPE* v, int ldv, ARPACK_CPLXF_TYPE* h, int ldh,
+       int* ipntr, ARPACK_CPLXF_TYPE* workd)
+{
+    int i, infol, ipj, irj, ivj, jj, n, tmp_int;
+    float smlnum = unfl * ( V->n / ulp);
+    const float sq2o2 = sqrt(2.0) / 2.0;
+
+    int int1 = 1;
+    float dbl1 = 1.0, temp1, tst1;
+    ARPACK_CPLXF_TYPE cdbl1 = ARPACK_cplxf(1.0, 0.0);
+    ARPACK_CPLXF_TYPE cdblm1 = ARPACK_cplxf(-1.0, 0.0);
+    ARPACK_CPLXF_TYPE cdbl0 = ARPACK_cplxf(0.0, 0.0);
+
+    n = V->n;  // n is constant, this is just for typing convenience
+    ipj = 0;
+    irj = ipj + n;
+    ivj = irj + n;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        //  Initial call to this routine
+        V->aitr_j = k;
+        V->info = 0;
+        V->aitr_step3 = 0;
+        V->aitr_step4 = 0;
+        V->aitr_orth1 = 0;
+        V->aitr_orth2 = 0;
+        V->aitr_restart = 0;
+    }
+
+    //  When in reverse communication mode one of:
+    //  STEP3, STEP4, ORTH1, ORTH2, RSTART
+    //  will be .true. when ....
+    //  STEP3: return from computing OP*v_{j}.
+    //  STEP4: return from computing B-norm of OP*v_{j}
+    //  ORTH1: return from computing B-norm of r_{j+1}
+    //  ORTH2: return from computing B-norm of
+    //         correction to the residual vector.
+    //  RSTART: return from OP computations needed by
+    //          dgetv0.
+
+    if (V->aitr_step3) { goto LINE50; }
+    if (V->aitr_step4) { goto LINE60; }
+    if (V->aitr_orth1) { goto LINE70; }
+    if (V->aitr_orth2) { goto LINE90; }
+    if (V->aitr_restart) { goto LINE30; }
+
+    //  Else this is the first step
+
+    //
+    //         A R N O L D I     I T E R A T I O N     L O O P
+    //
+    //  Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1)
+
+LINE1000:
+
+    //  STEP 1: Check if the B norm of j-th residual
+    //  vector is zero. Equivalent to determining whether
+    //  an exact j-step Arnoldi factorization is present.
+
+    V->aitr_betaj = *rnorm;
+    if (*rnorm > 0.0) { goto LINE40; }
+
+    //  Invariant subspace found, generate a new starting
+    //  vector which is orthogonal to the current Arnoldi
+    //  basis and continue the iteration.
+
+    V->aitr_betaj = 0.0;
+    V->getv0_itry = 1;
+
+LINE20:
+    V->aitr_restart = 1;
+    V->ido = ido_FIRST;
+
+LINE30:
+
+    // If in reverse communication mode and aitr_restart = 1, flow returns here.
+
+    cgetv0(V, 0, n, V->aitr_j, v, ldv, resid, rnorm, ipntr, workd);
+
+    if (V->ido != ido_DONE) { return; }
+    V->aitr_ierr = V->info;
+    if (V->aitr_ierr < 0)
+    {
+        V->getv0_itry += 1;
+        if (V->getv0_itry <= 3) { goto LINE20; }
+
+        //  Give up after several restart attempts.
+        //  Set INFO to the size of the invariant subspace
+        //  which spans OP and exit.
+
+        V->info = V->aitr_j;
+        V->ido = ido_DONE;
+        return;
+    }
+
+LINE40:
+
+    //  STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm
+    //  Note that p_{j} = B*r_{j-1}. In order to avoid overflow
+    //  when reciprocating a small RNORM, test against lower
+    //  machine bound.
+
+    ccopy_(&n, resid, &int1, &v[ldv*V->aitr_j], &int1);
+
+    if (*rnorm >= unfl)
+    {
+        temp1 = 1.0 / *rnorm;
+        csscal_(&n, &temp1, &v[ldv*V->aitr_j], &int1);
+        csscal_(&n, &temp1, &workd[ipj], &int1);
+    } else {
+        clascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &v[ldv*V->aitr_j], &n, &infol);
+        clascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &workd[ipj], &n, &infol);
+    }
+
+    //  STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j}
+    //  Note that this is not quite yet r_{j}. See STEP 4
+
+    V->aitr_step3 = 1;
+    ccopy_(&n, &v[ldv*(V->aitr_j)], &int1, &workd[ivj], &int1);
+    ipntr[0] = ivj;
+    ipntr[1] = irj;
+    ipntr[2] = ipj;
+    V->ido = ido_OPX;
+
+    //  Exit in order to compute OP*v_{j}
+
+    return;
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  WORKD(IRJ:IRJ+N-1) := OP*v_{j}
+    //  if step3 = .true.
+
+    V->aitr_step3 = 0;
+
+    //  Put another copy of OP*v_{j} into RESID.
+
+    ccopy_(&n, &workd[irj], &int1, resid, &int1);
+
+    //  STEP 4:  Finish extending the Arnoldi
+    //           factorization to length j.
+
+    if (V->bmat)
+    {
+        V->aitr_step4 = 1;
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*OP*v_{j}
+
+        return;
+    } else {
+        ccopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE60:
+
+    //  Back from reverse communication;
+    //  WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}
+    //  if step4 = .true.
+
+    V->aitr_step4 = 0;
+
+    //  The following is needed for STEP 5.
+    //  Compute the B-norm of OP*v_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_wnorm = sqrt(cabsf(cdotc_(&n, resid, &int1, &workd[ipj], &int1)));
+    } else {
+        V->aitr_wnorm = scnrm2_(&n, resid, &int1);
+    }
+
+    //  Compute the j-th residual corresponding
+    //  to the j step factorization.
+    //  Use Classical Gram Schmidt and compute:
+    //  w_{j} <-  V_{j}^T * B * OP * v_{j}
+    //  r_{j} <-  OP*v_{j} - V_{j} * w_{j}
+
+    //  Compute the j Fourier coefficients w_{j}
+    //  WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.
+    tmp_int = V->aitr_j + 1;
+    cgemv_("C", &n, &tmp_int, &cdbl1, v, &ldv, &workd[ipj], &int1, &cdbl0, &h[ldh*(V->aitr_j)], &int1);
+
+    //  Orthogonalize r_{j} against V_{j}.
+    //  RESID contains OP*v_{j}. See STEP 3.
+
+    cgemv_("N", &n, &tmp_int, &cdblm1, v, &ldv, &h[ldh*(V->aitr_j)], &int1, &cdbl1, resid, &int1);
+
+    if (V->aitr_j > 0) { h[V->aitr_j + ldh*(V->aitr_j-1)] = ARPACK_cplxf(V->aitr_betaj, 0.0); }
+
+    V->aitr_orth1 = 1;
+    if (V->bmat)
+    {
+        ccopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}
+
+        return;
+    } else {
+        ccopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE70:
+
+    //  Back from reverse communication if ORTH1 = .true.
+    //  WORKD(IPJ:IPJ+N-1) := B*r_{j}.
+
+    V->aitr_orth1 = 0;
+
+    //  Compute the B-norm of r_{j}.
+
+    if (V->bmat)
+    {
+        *rnorm = sqrt(cabsf(cdotc_(&n, resid, &int1, &workd[ipj], &int1)));
+    } else {
+        *rnorm = scnrm2_(&n, resid, &int1);
+    }
+
+    //  STEP 5: Re-orthogonalization / Iterative refinement phase
+    //  Maximum NITER_ITREF tries.
+    //
+    //           s      = V_{j}^T * B * r_{j}
+    //           r_{j}  = r_{j} - V_{j}*s
+    //           alphaj = alphaj + s_{j}
+    //
+    //  The stopping criteria used for iterative refinement is
+    //  discussed in Parlett's book SEP, page 107 and in Gragg &
+    //  Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.
+    //  Determine if we need to correct the residual. The goal is
+    //  to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||
+    //  The following test determines whether the sine of the
+    //  angle between  OP*x and the computed residual is less
+    //  than or equal to 0.7071.
+
+    if (*rnorm > sq2o2*V->aitr_wnorm) { goto LINE100; }
+    V->aitr_iter = 0;
+
+    //  Enter the Iterative refinement phase. If further
+    //  refinement is necessary, loop back here. The loop
+    //  variable is ITER. Perform a step of Classical
+    //  Gram-Schmidt using all the Arnoldi vectors V_{j}
+
+LINE80:
+
+    //  Compute V_{j}^T * B * r_{j}.
+    //  WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1).
+    tmp_int = V->aitr_j + 1;
+    cgemv_("C", &n, &tmp_int, &cdbl1, v, &ldv, &workd[ipj], &int1, &cdbl0, &workd[irj], &int1);
+
+    //  Compute the correction to the residual:
+    //  r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).
+    //  The correction to H is v(:,1:J)*H(1:J,1:J)
+    //  + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.
+
+    cgemv_("N", &n, &tmp_int, &cdblm1, v, &ldv, &workd[irj], &int1, &cdbl1, resid, &int1);
+    caxpy_(&tmp_int, &cdbl1, &workd[irj], &int1, &h[ldh*(V->aitr_j)], &int1);
+
+    V->aitr_orth2 = 1;
+
+    if (V->bmat)
+    {
+        ccopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}.
+        //  r_{j} is the corrected residual.
+
+        return;
+    } else {
+        ccopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE90:
+
+    //  Back from reverse communication if ORTH2 = .true.
+    //  Compute the B-norm of the corrected residual r_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_rnorm1 = sqrt(cabsf(cdotc_(&n, resid, &int1, &workd[ipj], &int1)));
+    } else {
+        V->aitr_rnorm1 = scnrm2_(&n, resid, &int1);
+    }
+
+    //  Determine if we need to perform another
+    //  step of re-orthogonalization.
+
+    if (V->aitr_rnorm1 > sq2o2*(*rnorm))
+    {
+
+        //  No need for further refinement.
+        //  The cosine of the angle between the
+        //  corrected residual vector and the old
+        //  residual vector is greater than 0.717
+        //  In other words the corrected residual
+        //  and the old residual vector share an
+        //  angle of less than arcCOS(0.717)
+
+        *rnorm = V->aitr_rnorm1;
+
+    } else {
+
+        //  Another step of iterative refinement step
+        //  is required.
+
+        *rnorm = V->aitr_rnorm1;
+        V->aitr_iter += 1;
+        if (V->aitr_iter < 2) { goto LINE80; }
+
+        //  Otherwise RESID is numerically in the span of V
+
+        for (jj = 0; jj < n; jj++)
+        {
+            resid[jj] = ARPACK_cplxf(0.0, 0.0);
+        }
+        *rnorm = 0.0;
+    }
+
+LINE100:
+
+    V->aitr_restart = 0;
+    V->aitr_orth2 = 0;
+
+    //  STEP 6: Update  j = j+1;  Continue
+
+    V->aitr_j += 1;
+
+    if (V->aitr_j >= k + np)
+    {
+        V->ido = ido_DONE;
+        for (i = (k > 0 ? k-1 : k); i < k + np - 1; i++)
+        {
+
+            //  Check for splitting and deflation.
+            //  Use a standard test as in the QR algorithm
+            //  REFERENCE: LAPACK subroutine dlahqr
+
+            tst1 = cabsf(h[i + ldh*i]) + cabsf(h[i+1 + ldh*(i+1)]);
+            if (tst1 == 0.0)
+            {
+                tmp_int = k + np;
+                // clanhs(norm, n, a, lda, work) with "work" being float type
+                // Recasting complex workspace to float for scratch space.
+                tst1 = clanhs_("1", &tmp_int, h, &ldh, (float*)&workd[n]);
+            }
+            if (cabsf(h[i+1 + ldh*i]) <= fmax(ulp*tst1, smlnum))
+            {
+                h[i+1 + ldh*i] = ARPACK_cplxf(0.0, 0.0);
+            }
+        }
+        // 110
+        return;
+    }
+    goto LINE1000;
+
+}
+
+
+static void
+cnapps(int n, int* kev, int np, ARPACK_CPLXF_TYPE* shift, ARPACK_CPLXF_TYPE* v,
+       int ldv, ARPACK_CPLXF_TYPE* h, int ldh, ARPACK_CPLXF_TYPE* resid,
+       ARPACK_CPLXF_TYPE* q, int ldq, ARPACK_CPLXF_TYPE* workl,
+       ARPACK_CPLXF_TYPE* workd)
+{
+    int i, j, jj, int1 = 1, istart, iend = 0, tmp_int;
+    float smlnum = unfl * ( n / ulp);
+    float c, tst1;
+    float tmp_dbl;
+    ARPACK_CPLXF_TYPE f, g, h11, h21, sigma, s, s2, r, t, tmp_cplx;
+
+    #if defined(_MSC_VER)
+    ARPACK_CPLXF_TYPE tmp_cplx2;
+    #endif
+
+    ARPACK_CPLXF_TYPE cdbl1 = ARPACK_cplxf(1.0, 0.0);
+    ARPACK_CPLXF_TYPE cdbl0 = ARPACK_cplxf(0.0, 0.0);
+
+    int kplusp = *kev + np;
+
+    //  Initialize Q to the identity to accumulate
+    //  the rotations and reflections
+    claset_("G", &kplusp, &kplusp, &cdbl0, &cdbl1, q, &ldq);
+
+    //  Quick return if there are no shifts to apply
+
+    if (np == 0) { return; }
+
+    //  Chase the bulge with the application of each
+    //  implicit shift. Each shift is applied to the
+    //  whole matrix including each block.
+
+    for (jj = 0; jj < np; jj++)
+    {
+        sigma = shift[jj];
+        istart = 0;
+
+        while (istart < kplusp - 1)
+        {
+            for  (iend = istart; iend < kplusp - 1; iend++)
+            {
+                tst1 = fabs(crealf(h[iend + ldh*iend])) + fabs(cimagf(h[iend + ldh*iend])) +
+                       fabs(crealf(h[iend+1 + ldh*(iend+1)])) + fabs(cimagf(h[iend+1 + ldh*(iend+1)]));
+                if (tst1 == 0.0)
+                {
+                   tmp_int = kplusp - jj;
+                    clanhs_("1", &tmp_int, h, &ldh, (float*)workl);
+                }
+                if (fabs(crealf(h[iend+1 + ldh*iend])) <= fmax(ulp*tst1, smlnum))
+                {
+                    break;
+                }
+            }
+            if ((istart == iend) || (istart >= *kev))
+            {
+
+                // No reason to apply a shift to block of order 1
+                // or if the current block starts after the point
+                // of compression since we'll discard this stuff.
+
+                istart += 1;
+                continue;
+
+            } else if (iend < kplusp - 1) {
+
+                // Valid block found and it's not the entire remaining array
+                // Clean up the noise
+
+                h[iend+1 + ldh*iend] = ARPACK_cplxf(0.0, 0.0);
+            }
+
+            h11 = h[istart + ldh*istart];
+            h21 = h[istart + 1 + ldh*istart];
+            // f = h11 - sigma;
+            f = ARPACK_cplxf(crealf(h11)-crealf(sigma), cimagf(h11)-cimagf(sigma));
+            g = h21;
+
+            for (i = istart; i < iend; i++)
+            {
+
+                //  Construct the plane rotation G to zero out the bulge
+
+                clartg_(&f, &g, &c, &s, &r);
+                if (i > istart)
+                {
+                    h[i + ldh*(i-1)] = r;
+                    h[i + 1 + ldh*(i-1)] = ARPACK_cplxf(0.0, 0.0);
+                }
+                tmp_int = kplusp - i;
+                crot_(&tmp_int, &h[i + ldh*i], &ldh, &h[i + 1 + ldh*i], &ldh, &c, &s);
+                // z = a + bi, -conj(z) = -a + bi
+                s2 = conjf(s);
+                tmp_int = (i + 2 > iend ? iend : i + 2) + 1;
+                crot_(&tmp_int, &h[ldh*i], &int1, &h[ldh*(i+1)], &int1, &c, &s2);
+                tmp_int = (i + jj + 2 > kplusp ? kplusp : i + jj + 2);
+                crot_(&tmp_int, &q[ldq*i], &int1, &q[ldq*(i+1)], &int1, &c, &s2);
+
+                if (i < iend - 1)
+                {
+                    f = h[i + 1 + ldh*i];
+                    g = h[i + 2 + ldh*i];
+                }
+            }
+            istart = iend + 1;
+        }
+    }
+
+    //  Perform a similarity transformation that makes
+    //  sure that H will have non negative sub diagonals
+
+    for (j = 0; j < *kev; j++)
+    {
+        if ((crealf(h[j+1 + ldh*j]) < 0.0) || (cimagf(h[j+1 + ldh*j]) != 0.0))
+        {
+            tmp_dbl = cabsf(h[j+1 + ldh*j]);
+            t = ARPACK_cplxf(crealf(h[j+1 + ldh*j]) / tmp_dbl,
+            cimagf(h[j+1 + ldh*j]) / tmp_dbl);
+
+            tmp_cplx = conjf(t);
+            tmp_int = kplusp - j;
+            cscal_(&tmp_int, &tmp_cplx, &h[j+1 + ldh*j], &ldh);
+
+            tmp_int = (j+3 > kplusp ? kplusp : j+3);
+            cscal_(&tmp_int, &t, &h[ldh*(j+1)], &int1);
+
+            tmp_int = (j+np+2 > kplusp ? kplusp : j+np+2);
+            cscal_(&tmp_int, &t, &q[ldq*(j+1)], &int1);
+
+            h[j+1 + ldh*j] = ARPACK_cplxf(crealf(h[j+1 + ldh*j]), 0.0);
+        }
+    }
+    // 120
+
+    for (i = 0; i < *kev; i++)
+    {
+
+        //  Final check for splitting and deflation.
+        //  Use a standard test as in the QR algorithm
+        //  REFERENCE: LAPACK subroutine zlahqr.
+        //  Note: Since the subdiagonals of the
+        //  compressed H are nonnegative real numbers,
+        //  we take advantage of this.
+
+        tst1 = fabs(crealf(h[i + ldh*i])) + fabs(crealf(h[i+1 + ldh*(i+1)])) +
+               fabs(cimagf(h[i + ldh*i])) + fabs(cimagf(h[i+1 + ldh*(i+1)]));
+        if (tst1 == 0.0)
+        {
+            tst1 = clanhs_("1", kev, h, &ldh, (float*)workl);
+        }
+        if (crealf(h[i+1 + ldh*i]) <= fmax(ulp*tst1, smlnum))
+        {
+            h[i+1 + ldh*i] = ARPACK_cplxf(0.0, 0.0);
+        }
+    }
+    // 130
+
+    //  Compute the (kev+1)-st column of (V*Q) and
+    //  temporarily store the result in WORKD(N+1:2*N).
+    //  This is needed in the residual update since we
+    //  cannot GUARANTEE that the corresponding entry
+    //  of H would be zero as in exact arithmetic.
+
+    if (crealf(h[*kev + ldh*(*kev-1)]) > 0.0)
+    {
+        cgemv_("N", &n, &kplusp, &cdbl1, v, &ldv, &q[(*kev)*ldq], &int1, &cdbl0, &workd[n], &int1);
+    }
+
+    //  Compute column 1 to kev of (V*Q) in backward order
+    //  taking advantage of the upper Hessenberg structure of Q.
+
+    for (i = 0; i < *kev; i++)
+    {
+        tmp_int = kplusp - i;
+        cgemv_("N", &n, &tmp_int, &cdbl1, v, &ldv, &q[(*kev-i-1)*ldq], &int1, &cdbl0, workd, &int1);
+        ccopy_(&n, workd, &int1, &v[(kplusp-i-1)*ldv], &int1);
+    }
+
+    //   Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev).
+
+    clacpy_("A", &n, kev, &v[ldv*(kplusp - *kev)], &ldv, v, &ldv);
+
+    //  Copy the (kev+1)-st column of (V*Q) in the appropriate place
+
+    if (crealf(h[*kev + ldh*(*kev-1)]) > 0.0) {
+        ccopy_(&n, &workd[n], &int1, &v[ldv*(*kev)], &int1);
+    }
+
+    //  Update the residual vector:
+    //     r <- sigmak*r + betak*v(:,kev+1)
+    //  where
+    //     sigmak = (e_{kplusp}'*Q)*e_{kev}
+    //     betak = e_{kev+1}'*H*e_{kev}
+
+    cscal_(&n, &q[kplusp-1 + ldq*(*kev-1)], resid, &int1);
+
+    if (crealf(h[*kev + ldh*(*kev-1)]) > 0.0)
+    {
+        caxpy_(&n, &h[*kev + ldh*(*kev-1)], &v[ldv*(*kev)], &int1, resid, &int1);
+    }
+
+    return;
+}
+
+
+static void
+cneigh(float* rnorm, int n, ARPACK_CPLXF_TYPE* h, int ldh, ARPACK_CPLXF_TYPE* ritz,
+       ARPACK_CPLXF_TYPE* bounds, ARPACK_CPLXF_TYPE* q, int ldq, ARPACK_CPLXF_TYPE* workl,
+       float* rwork, int* ierr)
+{
+    int select[1] = { 0 };
+    int int1 = 1, j;
+    float temp;
+    ARPACK_CPLXF_TYPE vl[1] = { 0.0 };
+    ARPACK_CPLXF_TYPE c1 = ARPACK_cplxf(1.0, 0.0), c0 = ARPACK_cplxf(0.0, 0.0);
+
+    //  1. Compute the eigenvalues, the last components of the
+    //     corresponding Schur vectors and the full Schur form T
+    //     of the current upper Hessenberg matrix H.
+    //     zlahqr returns the full Schur form of H
+    //     in WORKL(1:N**2), and the Schur vectors in q.
+
+    clacpy_("A", &n, &n, h, &ldh, workl, &n);
+    claset_("A", &n, &n, &c0, &c1, q, &ldq);
+    clahqr_(&int1, &int1, &n, &int1, &n, workl, &ldh, ritz, &int1, &n, q, &ldq, ierr);
+
+    if (*ierr != 0) { return; }
+
+    ccopy_(&n, &q[n-2], &ldq, bounds, &int1);
+
+    //  2. Compute the eigenvectors of the full Schur form T and
+    //     apply the Schur vectors to get the corresponding
+    //     eigenvectors.
+
+    ctrevc_("R", "B", select, &n, workl, &n, vl, &n, q, &ldq, &n, &n, &workl[n*n], rwork, ierr);
+
+    if (*ierr != 0) { return; }
+
+    //  Scale the returning eigenvectors so that their
+    //  euclidean norms are all one. LAPACK subroutine
+    //  ztrevc returns each eigenvector normalized so
+    //  that the element of largest magnitude has
+    //  magnitude 1; here the magnitude of a complex
+    //  number (x,y) is taken to be |x| + |y|.
+
+    for (j = 0; j < n; j++)
+    {
+        temp = 1.0 / scnrm2_(&n, &q[j*ldq], &int1);
+        csscal_(&n, &temp, &q[j*ldq], &int1);
+    }
+
+    //  Compute the Ritz estimates
+
+    ccopy_(&n, &q[n-1], &n, bounds, &int1);
+    csscal_(&n, rnorm, bounds, &int1);
+
+    return;
+}
+
+
+void
+cngets(struct ARPACK_arnoldi_update_vars_s *V, int* kev, int* np,
+       ARPACK_CPLXF_TYPE* ritz, ARPACK_CPLXF_TYPE* bounds)
+{
+
+    csortc(V->which, 1, *kev + *np, ritz, bounds);
+
+    if (V->shift == 1)
+    {
+
+        //  Sort the unwanted Ritz values used as shifts so that
+        //  the ones with largest Ritz estimates are first
+        //  This will tend to minimize the effects of the
+        //  forward instability of the iteration when they shifts
+        //  are applied in subroutine znapps.
+        //  Be careful and use 'SM' since we want to sort BOUNDS!
+
+        csortc(which_SM, 1, *np, bounds, ritz);
+    }
+
+    return;
+}
+
+
+static void
+cgetv0(struct ARPACK_arnoldi_update_vars_s *V, int initv, int n, int j,
+       ARPACK_CPLXF_TYPE* v, int ldv, ARPACK_CPLXF_TYPE* resid, float* rnorm,
+       int* ipntr, ARPACK_CPLXF_TYPE* workd)
+{
+    int jj, int1 = 1;
+    const float sq2o2 = sqrt(2.0) / 2.0;
+    ARPACK_CPLXF_TYPE c0 = ARPACK_cplxf(0.0, 0.0);
+    ARPACK_CPLXF_TYPE c1 = ARPACK_cplxf(1.0, 0.0);
+    ARPACK_CPLXF_TYPE cm1 = ARPACK_cplxf(-1.0, 0.0);
+
+    if (V->ido == ido_FIRST)
+    {
+        V->info = 0;
+        V->getv0_iter = 0;
+        V->getv0_first = 0;
+        V->getv0_orth = 0;
+
+        //  Possibly generate a random starting vector in RESID
+        //  Skip if this the return of ido_RANDOM.
+
+        if (!(initv))
+        {
+            // Request a random vector from the user into resid
+            V->ido = ido_RANDOM;
+            return;
+        } else {
+            //  If initv = 1, then the user has provided a starting vector
+            //  in RESID. We need to copy it into workd[n] and perform an OP(x0).
+            //  Change the ido but don't exit to join back to the flow.
+            V->ido = ido_RANDOM;
+        }
+    }
+
+    // Back from random vector generation
+    if (V->ido == ido_RANDOM)
+    {
+        //  Force the starting vector into the range of OP to handle
+        //  the generalized problem when B is possibly (singular).
+
+        if (V->getv0_itry == 1)
+        {
+            ipntr[0] = 0;
+            ipntr[1] = n;
+            ccopy_(&n, resid, &int1, workd, &int1);
+            V->ido = ido_RANDOM_OPX;
+            return;
+        } else if ((V->getv0_itry > 1) && (V->bmat == 1))
+        {
+            ccopy_(&n, resid, &int1, &workd[n], &int1);
+        }
+    }
+
+    //  Back from computing OP*(initial-vector)
+
+    if (V->getv0_first) { goto LINE20; }
+
+    //  Back from computing OP*(orthogonalized-vector)
+
+    if (V->getv0_orth) { goto LINE40; }
+
+    //  Starting vector is now in the range of OP; r = OP*r;
+    //  Compute B-norm of starting vector.
+
+    V->getv0_first = 1;
+    if (V->getv0_itry == 1)
+    {
+        ccopy_(&n, &workd[n], &int1, resid, &int1);
+    }
+    if (V->bmat)
+    {
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        ccopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE20:
+
+    V->getv0_first = 0;
+    if (V->bmat)
+    {
+        V->getv0_rnorm0 = sqrt(cabsf(cdotc_(&n, resid, &int1, workd, &int1)));
+    } else {
+        V->getv0_rnorm0 = scnrm2_(&n, resid, &int1);
+    }
+    *rnorm = V->getv0_rnorm0;
+
+    //  Exit if this is the very first Arnoldi step
+
+    if (j == 0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //  Otherwise need to B-orthogonalize the starting vector against
+    //  the current Arnoldi basis using Gram-Schmidt with iter. ref.
+    //  This is the case where an invariant subspace is encountered
+    //  in the middle of the Arnoldi factorization.
+    //
+    //        s = V^{T}*B*r;   r = r - V*s;
+    //
+    //  Stopping criteria used for iter. ref. is discussed in
+    //  Parlett's book, page 107 and in Gragg & Reichel TOMS paper.
+
+    V->getv0_orth = 1;
+
+LINE30:
+
+    cgemv_("C", &n, &j, &c1, v, &ldv, workd, &int1, &c0, &workd[n], &int1);
+    cgemv_("N", &n, &j, &cm1, v, &ldv, &workd[n], &int1, &c1, resid, &int1);
+
+    //  Compute the B-norm of the orthogonalized starting vector
+
+    if (V->bmat)
+    {
+        ccopy_(&n, resid, &int1, &workd[n], &int1);
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        ccopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE40:
+    if (V->bmat)
+    {
+        *rnorm = sqrt(cabsf(cdotc_(&n, resid, &int1, workd, &int1)));
+    } else {
+        *rnorm = scnrm2_(&n, resid, &int1);
+    }
+
+    //  Check for further orthogonalization.
+
+    if (*rnorm > sq2o2*V->getv0_rnorm0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->getv0_iter += 1;
+
+    if (V->getv0_iter < 2)
+    {
+
+        //  Perform iterative refinement step
+
+        V->getv0_rnorm0 = *rnorm;
+        goto LINE30;
+    } else {
+
+        //  Iterative refinement step "failed"
+
+        for (jj = 0; jj < n; jj++) { resid[jj] = ARPACK_cplxf(0.0, 0.0); }
+        *rnorm = 0.0;
+        V->info = -1;
+    }
+
+    V->ido = ido_DONE;
+    return;
+}
+
+
+void
+csortc(const enum ARPACK_which w, const int apply, const int n,  ARPACK_CPLXF_TYPE *x,  ARPACK_CPLXF_TYPE *y)
+{
+    int i, igap, j;
+    ARPACK_CPLXF_TYPE temp;
+    ARPACK_compare_cfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortc_LM;
+            break;
+        case which_SM:
+            f = sortc_SM;
+            break;
+        case which_LR:
+            f = sortc_LR;
+            break;
+        case which_LI:
+            f = sortc_LI;
+            break;
+        case which_SR:
+            f = sortc_SR;
+            break;
+        case which_SI:
+            f = sortc_SI;
+            break;
+        default:
+            f = sortc_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(x[j], x[j+igap]))
+            {
+                if (j < 0) { break; }
+                temp = x[j];
+                x[j] = x[j+igap];
+                x[j+igap] = temp;
+
+                if (apply)
+                {
+                    temp = y[j];
+                    y[j] = y[j+igap];
+                    y[j+igap] = temp;
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+}
+
+
+static int sortc_LM(const ARPACK_CPLXF_TYPE x, const ARPACK_CPLXF_TYPE y) { return (cabsf(x) > cabsf(y)); }
+static int sortc_SM(const ARPACK_CPLXF_TYPE x, const ARPACK_CPLXF_TYPE y) { return (cabsf(x) < cabsf(y)); }
+static int sortc_LR(const ARPACK_CPLXF_TYPE x, const ARPACK_CPLXF_TYPE y) { return (crealf(x) > crealf(y)); }
+static int sortc_SR(const ARPACK_CPLXF_TYPE x, const ARPACK_CPLXF_TYPE y) { return (crealf(x) < crealf(y)); }
+static int sortc_LI(const ARPACK_CPLXF_TYPE x, const ARPACK_CPLXF_TYPE y) { return (cimagf(x) > cimagf(y)); }
+static int sortc_SI(const ARPACK_CPLXF_TYPE x, const ARPACK_CPLXF_TYPE y) { return (cimagf(x) < cimagf(y)); }
+
+
+// cdotc is the complex conjugate dot product of two complex vectors.
+// Due some historical reasons, this function can cause segfaults on some
+// platforms. Hence implemented here instead of using the BLAS version.
+static ARPACK_CPLXF_TYPE
+cdotc_(const int* n, const ARPACK_CPLXF_TYPE* restrict x, const int* incx, const ARPACK_CPLXF_TYPE* restrict y, const int* incy)
+{
+    ARPACK_CPLXF_TYPE result = ARPACK_cplxf(0.0, 0.0);
+#ifdef _MSC_VER
+    ARPACK_CPLXF_TYPE temp = ARPACK_cplxf(0.0, 0.0);
+#endif
+    if (*n <= 0) { return result; }
+    if ((*incx == 1) && (*incy == 1))
+    {
+        for (int i = 0; i < *n; i++)
+        {
+#ifdef _MSC_VER
+            temp = _FCmulcc(x[i], conjf(y[i]));
+            result = ARPACK_cplxf(crealf(result) + crealf(temp), cimagf(result) + cimagf(temp));
+#else
+            result = result + (x[i] * conjf(y[i]));
+#endif
+        }
+
+    } else {
+
+        for (int i = 0; i < *n; i++)
+        {
+#ifdef _MSC_VER
+            temp = _FCmulcc(x[i * (*incx)], conjf(y[i * (*incy)]));
+            result = ARPACK_cplxf(crealf(result) + crealf(temp), cimagf(result) + cimagf(temp));
+#else
+            result = result + (x[i * (*incx)] * conjf(y[i * (*incy)]));
+#endif
+        }
+    }
+
+    return result;
+}
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.h
new file mode 100644
index 0000000000..b4d48de2ed
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_n_single_complex.h
@@ -0,0 +1,45 @@
+#ifndef _ARPACK_N_SINGLE_COMPLEX_H
+#define _ARPACK_N_SINGLE_COMPLEX_H
+
+#include "_arpack.h"
+
+// BLAS Routines used
+void caxpy_(int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* x, int* incx, ARPACK_CPLXF_TYPE* y, int* incy);
+void ccopy_(int* n, ARPACK_CPLXF_TYPE* x, int* incx, ARPACK_CPLXF_TYPE* y, int* incy);
+void cgeru_(int* m, int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* x, int* incx, ARPACK_CPLXF_TYPE* y, int* incy, ARPACK_CPLXF_TYPE* a, int* lda);
+float scnrm2_(int* n, ARPACK_CPLXF_TYPE* x, int* incx);
+void cscal_(int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* x, int* incx);
+void csscal_(int* n, float* da, ARPACK_CPLXF_TYPE* zx, int* incx);
+void cgemv_(char* trans, int* m, int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* a, int* lda, ARPACK_CPLXF_TYPE* x, int* incx, ARPACK_CPLXF_TYPE* beta, ARPACK_CPLXF_TYPE* y, int* incy);
+void crot_(int* n, ARPACK_CPLXF_TYPE* cx, int* incx, ARPACK_CPLXF_TYPE* cy, int* incy, float* c, ARPACK_CPLXF_TYPE* s);
+void ctrmm_(char* side, char* uplo, char* transa, char* diag, int* m, int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* a, int* lda, ARPACK_CPLXF_TYPE* b, int* ldb);
+
+// LAPACK Routines used
+void cgeqr2_(int* m, int* n, ARPACK_CPLXF_TYPE* a, int* lda, ARPACK_CPLXF_TYPE* tau, ARPACK_CPLXF_TYPE* work, int* info);
+void clacpy_(char* uplo, int* m, int* n, ARPACK_CPLXF_TYPE* a, int* lda, ARPACK_CPLXF_TYPE* b, int* ldb);
+void clahqr_(int* wantt, int* wantz, int* n, int* ilo, int* ihi, ARPACK_CPLXF_TYPE* h, int* ldh, ARPACK_CPLXF_TYPE* w, int* iloz, int* ihiz, ARPACK_CPLXF_TYPE* z, int* ldz, int* info );
+float clanhs_(char* norm, int* n, ARPACK_CPLXF_TYPE* a, int* lda, float* work);
+void clarf_(char* side, int* m, int* n, ARPACK_CPLXF_TYPE* v, int* incv, ARPACK_CPLXF_TYPE* tau, ARPACK_CPLXF_TYPE* c, int* ldc, ARPACK_CPLXF_TYPE* work);
+void clarfg_(int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* x, int* incx, ARPACK_CPLXF_TYPE* tau);
+void clartg_(ARPACK_CPLXF_TYPE* f, ARPACK_CPLXF_TYPE* g, float* c, ARPACK_CPLXF_TYPE* s, ARPACK_CPLXF_TYPE* r);
+void clascl_(char* mtype, int* kl, int* ku, float* cfrom, float* cto, int* m, int* n, ARPACK_CPLXF_TYPE* a, int* lda, int* info);
+void claset_(char* uplo, int* m, int* n, ARPACK_CPLXF_TYPE* alpha, ARPACK_CPLXF_TYPE* beta, ARPACK_CPLXF_TYPE* a, int* lda);
+void ctrevc_(char* side, char* howmny, int* select, int* n, ARPACK_CPLXF_TYPE* t, int* ldt, ARPACK_CPLXF_TYPE* vl, int* ldvl, ARPACK_CPLXF_TYPE* vr, int* ldvr, int* mm, int* m, ARPACK_CPLXF_TYPE* work, float* rwork, int* info);
+void ctrsen_(char* job, char* compq, int* select, int* n, ARPACK_CPLXF_TYPE* t, int* ldt, ARPACK_CPLXF_TYPE* q, int* ldq, ARPACK_CPLXF_TYPE* w, int* m, float* s, float* sep, ARPACK_CPLXF_TYPE* work, int* lwork, int* info);
+void cunm2r_(char* side, char* trans, int* m, int* n, int* k, ARPACK_CPLXF_TYPE* a, int* lda, ARPACK_CPLXF_TYPE* tau, ARPACK_CPLXF_TYPE* c, int* ldc, ARPACK_CPLXF_TYPE* work, int* info);
+
+#if defined(_MSC_VER)
+    // MSVC definitions
+    #include <complex.h>  // MSVC C++ header
+    typedef _Fcomplex ARPACK_CPLXF_TYPE;
+    #define ARPACK_cplxf(real, imag) ((_Fcomplex){real, imag})
+
+#else
+    // C99 compliant compilers
+    #include <complex.h>
+    typedef float complex ARPACK_CPLXF_TYPE;
+    #define ARPACK_cplxf(real, imag) ((real) + (imag)*I)
+
+#endif
+
+#endif
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.c b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.c
new file mode 100644
index 0000000000..e0cf5a9595
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.c
@@ -0,0 +1,2238 @@
+#include "_arpack_s_double.h"
+
+typedef int ARPACK_compare_rfunc(const double, const double);
+
+static int sortr_LM(const double, const double);
+static int sortr_SM(const double, const double);
+static int sortr_LA(const double, const double);
+static int sortr_SA(const double, const double);
+
+static const double unfl = 2.2250738585072014e-308;
+static const double ulp = 2.220446049250313e-16;
+
+static void dsaup2(struct ARPACK_arnoldi_update_vars_d*, double*, double*, int, double*, int, double*, double*, double*, int, double*, int*, double*);
+static void dsconv(int, double*, double*, double, int*);
+static void dseigt(double, int, double*, int, double*, double*, double*, int*);
+static void dsaitr(struct ARPACK_arnoldi_update_vars_d*, int, int, double*, double*, double*, int, double*, int, int*, double*);
+static void dsapps(int, int*, int, double*, double*, int, double*, int, double*, double* , int, double*);
+static void dsgets(struct ARPACK_arnoldi_update_vars_d*, int*, int*, double*, double*, double*);
+static void dgetv0(struct ARPACK_arnoldi_update_vars_d *, int, int, int, double*, int, double*, double*, int*, double*);
+static void dsortr(const enum ARPACK_which w, const int apply, const int n, double* x1, double* x2);
+static void dsesrt(const enum ARPACK_which w, const int apply, const int n, double* x, int na, double* a, const int lda);
+static void dstqrb(int n, double* d, double* e, double* z, double* work, int* info);
+
+enum ARPACK_seupd_type {
+    REGULAR,
+    SHIFTI,
+    BUCKLE,
+    CAYLEY
+};
+
+
+void
+ARPACK_dseupd(struct ARPACK_arnoldi_update_vars_d *V, int rvec, int howmny, int* select,
+       double* d, double* z, int ldz, double sigma, double* resid, double* v,
+       int ldv, int* ipntr, double* workd, double* workl)
+{
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    int j, jj, k;
+    int ibd, ih, ihb, ihd, iq, irz, iw, ldh, ldq, ritz, bounds, next, np;
+    int ierr = 0, int1 = 1, tmp_int = 0, numcnv, reord;
+    double bnorm2, rnorm, temp, temp1, dbl1 = 1.0;
+
+    if (V->nconv == 0) { return; }
+
+    ierr = 0;
+    enum ARPACK_seupd_type TYP = REGULAR;
+
+    if (V->nconv <= 0) {
+        ierr = -14;
+    } else if (V->n <= 0) {
+        ierr = -1;
+    } else if (V->nev <= 0) {
+        ierr = -2;
+    } else if ((V->ncv <= V->nev) || (V->ncv > V->n)) {
+        ierr = -3;
+    } else if ((V->which != 0) &&
+               (V->which != 1) &&
+               (V->which != 6) &&
+               (V->which != 7) &&
+               (V->which != 8)) {
+        ierr = -5;
+    } else if ((V->bmat != 0) && (V->bmat != 1)) {
+        ierr = -6;
+    } else if ((rvec) && ((howmny < 0) || (howmny > 2))) {
+        ierr = -15;
+    } else if ((rvec) && (howmny == 2)) {
+        ierr = -16;  // NotImplementedError
+    }
+
+    if ((V->mode == 1) || (V->mode == 2)) {
+        TYP = REGULAR;
+    } else if (V->mode == 3) {
+        TYP = SHIFTI;
+    } else if (V->mode == 4) {
+        TYP = BUCKLE;
+    } else if (V->mode == 5) {
+        TYP = CAYLEY;
+    } else {
+        ierr = -10;
+    }
+
+    if ((V->mode == 1) && (V->bmat)) { ierr = -11; }
+    if ((V->nev == 1) && (V->which == which_BE)) { ierr = -12; }
+
+    if (ierr != 0) {
+        V->info = ierr;
+        return;
+    }
+
+
+    // Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    // etc... and the remaining workspace.
+    // Also update pointer to be used on output.
+    // Memory is laid out as follows:
+    // workl(1:2*ncv) := generated tridiagonal matrix H
+    //       The subdiagonal is stored in workl(2:ncv).
+    //       The dead spot is workl(1) but upon exiting
+    //       dsaupd  stores the B-norm of the last residual
+    //       vector in workl(1). We use this !!!
+    // workl(2*ncv+1:2*ncv+ncv) := ritz values
+    //       The wanted values are in the first NCONV spots.
+    // workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates
+    //       The wanted values are in the first NCONV spots.
+    // NOTE: workl(1:4*ncv) is set by dsaupd  and is not
+    //       modified by dseupd .
+    // ----------------------------------------------------
+    // The following is used and set by dseupd .
+    // workl(4*ncv+1:4*ncv+ncv) := used as workspace during
+    //       computation of the eigenvectors of H. Stores
+    //       the diagonal of H. Upon EXIT contains the NCV
+    //       Ritz values of the original system. The first
+    //       NCONV spots have the wanted values. If MODE =
+    //       1 or 2 then will equal workl(2*ncv+1:3*ncv).
+    // workl(5*ncv+1:5*ncv+ncv) := used as workspace during
+    //       computation of the eigenvectors of H. Stores
+    //       the subdiagonal of H. Upon EXIT contains the
+    //       NCV corresponding Ritz estimates of the
+    //       original system. The first NCONV spots have the
+    //       wanted values. If MODE = 1,2 then will equal
+    //       workl(3*ncv+1:4*ncv).
+    // workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is
+    //       the eigenvector matrix for H as returned by
+    //       dsteqr . Not referenced if RVEC = .False.
+    //       Ordering follows that of workl(4*ncv+1:5*ncv)
+    // workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=
+    //       Workspace. Needed by dsteqr  and by dseupd .
+    // GRAND total of NCV*(NCV+8) locations.
+
+    ih = ipntr[4];
+    ritz = ipntr[5];
+    bounds = ipntr[6];
+    ldh = V->ncv;
+    ldq = V->ncv;
+    ihd = bounds + ldh;
+    ihb = ihd    + ldh;
+    iq  = ihb    + ldh;
+    iw  = iq     + ldh*V->ncv;
+    next = iw    + 2*V->ncv;
+    ipntr[3] = next;
+    ipntr[7] = ihd;
+    ipntr[8] = ihb;
+    ipntr[9] = iq;
+
+    // irz points to the Ritz values computed
+    //     by _seigt before exiting _saup2.
+    // ibd points to the Ritz estimates
+    //     computed by _seigt before exiting
+    //     _saup2.
+
+    irz = ipntr[10] + V->ncv;
+    ibd = irz + V->ncv;
+
+    // RNORM is B-norm of the RESID(1:N).
+    // BNORM2 is the 2 norm of B*RESID(1:N).
+    // Upon exit of dsaupd  WORKD(1:N) has
+    // B*RESID(1:N).
+
+    rnorm = workl[ih];
+    if (V->bmat)
+    {
+        bnorm2 = dnrm2_(&V->n, workd, &int1);
+    } else {
+        bnorm2 = rnorm;
+    }
+
+    if (rvec) {
+        reord = 0;
+
+        // Use the temporary bounds array to store indices
+        // These will be used to mark the select array later
+
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[bounds + j] = j;
+            select[j] = 0;
+        }
+        // 10
+
+        // Select the wanted Ritz values.
+        // Sort the Ritz values so that the
+        // wanted ones appear at the tailing
+        // NEV positions of workl(irr) and
+        // workl(iri).  Move the corresponding
+        // error estimates in workl(bound)
+        // accordingly.
+
+        np = V->ncv - V->nev;
+        V->shift = 0;
+        dsgets(V, &V->nev, &np, &workl[irz], &workl[bounds], workl);
+
+        //  Record indices of the converged wanted Ritz values
+        //  Mark the select array for possible reordering
+
+        numcnv = 0;
+        for (j = 1; j <= V->ncv; j++)
+        {
+            temp1 = fmax(eps23, fabs(workl[irz + V->ncv - j]));
+
+            jj = (int)workl[bounds + V->ncv - j];
+
+            if ((numcnv < V->nconv) && (workl[ibd + jj] <= V->tol*temp1))
+            {
+                select[jj] = 1;
+                numcnv += 1;
+                if (jj > V->nconv - 1) { reord = 1; }
+            }
+        }
+        // 11
+
+        //  Check the count (numcnv) of converged Ritz values with
+        //  the number (nconv) reported by saupd.  If these two
+        //  are different then there has probably been an error
+        //  caused by incorrect passing of the saupd data.
+
+        if (numcnv != V->nconv)
+        {
+            V->info = -17;
+            return;
+        }
+
+        // Call LAPACK routine _steqr to compute the eigenvalues and
+        // eigenvectors of the final symmetric tridiagonal matrix H.
+        // Initialize the eigenvector matrix Q to the identity.
+
+        tmp_int = V->ncv - 1;
+        dcopy_(&tmp_int, &workl[ih+1], &int1, &workl[ihb], &int1);
+        dcopy_(&V->ncv, &workl[ih+ldh], &int1, &workl[ihd], &int1);
+
+        dsteqr_("I", &V->ncv, &workl[ihd], &workl[ihb], &workl[iq], &ldq, &workl[iw], &ierr);
+
+        if (ierr != 0)
+        {
+            V->info = -8;
+            return;
+        }
+
+        if (reord)
+        {
+
+            // Reordered the eigenvalues and eigenvectors
+            // computed by _steqr so that the "converged"
+            // eigenvalues appear in the first NCONV
+            // positions of workl(ihd), and the associated
+            // eigenvectors appear in the first NCONV
+            // columns.
+
+            int leftptr = 0;
+            int rightptr = V->ncv - 1;
+
+            if (V->ncv > 1)
+            {
+                do
+                {
+                    if (select[leftptr])
+                    {
+
+                        // Search, from the left, for the first non-converged Ritz value.
+
+                        leftptr += 1;
+
+                    } else if (!(select[rightptr])) {
+
+                        // Search, from the right, the first converged Ritz value
+
+                        rightptr -= 1;
+
+                    } else {
+
+                        // Swap the Ritz value on the left that has not
+                        // converged with the Ritz value on the right
+                        // that has converged.  Swap the associated
+                        // eigenvector of the tridiagonal matrix H as
+                        // well.
+
+                        temp = workl[ihd + leftptr];
+                        workl[ihd + leftptr] = workl[ihd + rightptr];
+                        workl[ihd + rightptr] = temp;
+
+                        dcopy_(&V->ncv, &workl[iq + V->ncv*leftptr], &int1, &workl[iw], &int1);
+                        dcopy_(&V->ncv, &workl[iq + V->ncv*rightptr], &int1, &workl[iq + V->ncv*leftptr], &int1);
+                        dcopy_(&V->ncv, &workl[iw], &int1, &workl[iq + V->ncv*rightptr], &int1);
+
+                        leftptr += 1;
+                        rightptr -= 1;
+                    }
+                } while (leftptr < rightptr);
+            }
+        }
+
+        // Load the converged Ritz values into D.
+
+        dcopy_(&V->nconv, &workl[ihd], &int1, d, &int1);
+
+    } else {
+
+        // Ritz vectors not required. Load Ritz values into D.
+
+        dcopy_(&V->nconv, &workl[ritz], &int1, d, &int1);
+        dcopy_(&V->ncv, &workl[ritz], &int1, &workl[ihd], &int1);
+    }
+
+    // Transform the Ritz values and possibly vectors and corresponding
+    // Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values
+    // (and corresponding data) are returned in ascending order.
+
+    if (TYP == REGULAR)
+    {
+
+        // Ascending sort of wanted Ritz values, vectors and error
+        // bounds. Not necessary if only Ritz values are desired.
+
+        if (rvec) {
+            dsesrt(which_LA, rvec, V->nconv, d, V->ncv, &workl[iq], ldq);
+        } else {
+            dcopy_(&V->ncv, &workl[bounds], &int1, &workl[ihb], &int1);
+        }
+
+    } else {
+
+        // *  Make a copy of all the Ritz values.
+        // *  Transform the Ritz values back to the original system.
+        //    For TYPE = 'SHIFTI' the transformation is
+        //             lambda = 1/theta + sigma
+        //    For TYPE = 'BUCKLE' the transformation is
+        //             lambda = sigma * theta / ( theta - 1 )
+        //    For TYPE = 'CAYLEY' the transformation is
+        //             lambda = sigma * (theta + 1) / (theta - 1 )
+        //    where the theta are the Ritz values returned by dsaupd.
+        // NOTES:
+        // *The Ritz vectors are not affected by the transformation.
+        //  They are only reordered.
+
+        dcopy_(&V->ncv, &workl[ihd], &int1, &workl[iw], &int1);
+        if (TYP == SHIFTI)
+        {
+            for (int k = 0; k < V->ncv; k++)
+            {
+                workl[ihd + k] = 1.0 / workl[ihd + k] + sigma;
+            }
+        } else if (TYP == BUCKLE) {
+            for (int k = 0; k < V->ncv; k++) {
+                workl[ihd + k] = sigma * workl[ihd + k] / (workl[ihd + k] - 1.0);
+            }
+        } else if (TYP == CAYLEY) {
+            for (int k = 0; k < V->ncv; k++) {
+                workl[ihd + k] = sigma * (workl[ihd + k] + 1.0) / (workl[ihd + k] - 1.0);
+            }
+        }
+
+        // *  Store the wanted NCONV lambda values into D.
+        // *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)
+        //    into ascending order and apply sort to the NCONV theta
+        //    values in the transformed system. We will need this to
+        //    compute Ritz estimates in the original system.
+        // *  Finally sort the lambda`s into ascending order and apply
+        //    to Ritz vectors if wanted. Else just sort lambda`s into
+        //    ascending order.
+        // NOTES:
+        // *workl(iw:iw+ncv-1) contain the theta ordered so that they
+        //  match the ordering of the lambda. We`ll use them again for
+        //  Ritz vector purification.
+
+        dcopy_(&V->nconv, &workl[ihd], &int1, d, &int1);
+        dsortr(which_LA, 1, V->nconv, &workl[ihd], &workl[iw]);
+        if (rvec) {
+            dsesrt(which_LA, rvec, V->nconv, d, V->ncv, &workl[iq], ldq);
+        } else {
+            dcopy_(&V->ncv, &workl[bounds], &int1, &workl[ihb], &int1);
+            temp = bnorm2 / rnorm;
+            dscal_(&V->ncv, &temp, &workl[ihb], &int1);
+            dsortr(which_LA, 1, V->nconv, d, &workl[ihb]);
+        }
+    }
+
+    // Compute the Ritz vectors. Transform the wanted
+    // eigenvectors of the symmetric tridiagonal H by
+    // the Lanczos basis matrix V.
+
+    if ((rvec) && (howmny == 0))
+    {
+
+        // Compute the QR factorization of the matrix representing
+        // the wanted invariant subspace located in the first NCONV
+        // columns of workl(iq, ldq).
+
+        dgeqr2_(&V->ncv, &V->nconv, &workl[iq], &ldq, &workl[iw + V->ncv], &workl[ihb], &ierr);
+
+        // * Postmultiply V by Q.
+        // * Copy the first NCONV columns of VQ into Z.
+        // The N by NCONV matrix Z is now a matrix representation
+        // of the approximate invariant subspace associated with
+        // the Ritz values in workl(ihd).
+
+        dorm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[iq], &ldq, &workl[iw + V->ncv], v, &ldv, &workd[V->n], &ierr);
+        dlacpy_("A", &V->n, &V->nconv, v, &ldv, z, &ldz);
+
+        // In order to compute the Ritz estimates for the Ritz
+        // values in both systems, need the last row of the
+        // eigenvector matrix. Remember, it's in factored form.
+
+        for (int j = 0; j < V->ncv - 1; j++)
+        {
+            workl[ihb + j] = 0.0;
+        }
+        workl[ihb + V->ncv - 1] = 1.0;
+        dorm2r_("L", "T", &V->ncv, &int1, &V->nconv, &workl[iq], &ldq, &workl[iw + V->ncv], &workl[ihb], &V->ncv, &temp, &ierr);
+
+        //  Make a copy of the last row into
+        //  workl(iw+ncv:iw+2*ncv), as it is needed again in
+        //  the Ritz vector purification step below
+
+        for (int j = 0; j < V->nconv; j++)
+        {
+            workl[iw + V->ncv + j] = workl[ihb + j];
+        }
+        // 67
+
+    } else if ((rvec) && (howmny == 2)) {
+        // Not yet implemented
+        ;
+    }
+
+    if ((TYP == REGULAR) && (rvec))
+    {
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[ihb + j] = rnorm * fabs(workl[ihb + j]);
+        }
+
+    } else if ((TYP != REGULAR) && (rvec)) {
+
+        // *  Determine Ritz estimates of the theta.
+        //    If RVEC = .true. then compute Ritz estimates
+        //               of the theta.
+        //    If RVEC = .false. then copy Ritz estimates
+        //              as computed by dsaupd .
+        // *  Determine Ritz estimates of the lambda.
+
+
+        dscal_(&V->ncv, &bnorm2, &workl[ihb], &int1);
+
+        for (k = 0; k < V->ncv; k++)
+        {
+            if (TYP == SHIFTI)
+            {
+                workl[ihb + k] = fabs(workl[ihb + k]) / pow(workl[iw + k], 2.0);
+            } else if (TYP == BUCKLE) {
+                workl[ihb + k] = sigma * fabs(workl[ihb + k]) / pow(workl[iw + k] - 1.0, 2.0);
+            } else if (TYP == CAYLEY) {
+                workl[ihb + k] = fabs(workl[ihb + k] / workl[iw + k] * (workl[iw + k] - 1.0));
+            }
+        }
+        // 80, 90, 100
+    }
+
+    // Ritz vector purification step. Formally perform
+    // one of inverse subspace iteration. Only used
+    // for MODE = 3,4,5. See reference 7
+
+    if ((rvec) && ((TYP == SHIFTI) || (TYP == CAYLEY)))
+    {
+        for (k = 0; k < V->nconv; k++)
+        {
+            workl[iw + k] = workl[iw + V->ncv + k] / workl[iw + k];
+        }
+        // 110
+    } else if ((rvec) && (TYP == BUCKLE))
+    {
+        for (k = 0; k < V->nconv; k++)
+        {
+            workl[iw + k] = workl[iw + V->ncv + k] / (workl[iw + k] - 1.0);
+        }
+        // 120
+    }
+
+    if ((rvec) && (TYP != REGULAR))
+    {
+        dger_(&V->n, &V->nconv, &dbl1, resid, &int1, &workl[iw], &int1, z, &ldz);
+    }
+
+    return;
+}
+
+
+void
+ARPACK_dsaupd(struct ARPACK_arnoldi_update_vars_d *V, double* resid, double* v, int ldv,
+       int* ipntr, double* workd, double* workl)
+{
+
+    int bounds = 0, ih = 0, iq = 0, iw = 0, j = 0, ldh = 0, ldq = 0, next = 0, ritz = 0;
+
+    if (V->ido == ido_FIRST)
+    {
+        if (V->n <= 0) {
+            V->info = -1;
+        } else if (V->nev <= 0) {
+            V->info = -2;
+        } else if ((V->ncv < V->nev + 1) || (V->ncv > V->n)) {
+            V->info = -3;
+        } else if (V->maxiter <= 0) {
+            V->info = -4;
+        } else if ((V->which != 0) &&
+            (V->which != 1) &&
+            (V->which != 6) &&
+            (V->which != 7) &&
+            (V->which != 8)) {
+            V->info = -5;
+        } else if ((V->bmat != 0) && (V->bmat != 1)) {
+            V->info = -6;
+        } else if ((V->mode < 1) || (V->mode > 5)) {
+            V->info = -10;
+        } else if ((V->mode == 1) && (V->bmat == 1)) {
+            V->info = -11;
+        } else if ((V->shift != 0) && (V->shift != 1)) {
+            V->info = -12;
+        } else if ((V->nev == 1) && (V->which == which_BE)) {
+            V->info = -13;
+        }
+
+        if (V->info < 0)
+        {
+            V->ido = ido_DONE;
+            return;
+        }
+
+        if (V->tol <= 0.0) { V->tol = ulp; }
+
+        // NP is the number of additional steps to
+        // extend the length NEV Lanczos factorization.
+        V->np = V->ncv - V->nev;
+
+        // Zero out internal workspace
+        for (j = 0; j < (V->ncv)*((V->ncv) + 8); j++) { workl[j] = 0.0; }
+    }
+
+    // Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    // etc... and the remaining workspace.
+    // Also update pointer to be used on output.
+    // Memory is laid out as follows:
+    // workl(1:2*ncv) := generated tridiagonal matrix
+    // workl(2*ncv+1:2*ncv+ncv) := ritz values
+    // workl(3*ncv+1:3*ncv+ncv) := computed error bounds
+    // workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q
+    // workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace
+
+    ldh = V->ncv;
+    ldq = V->ncv;
+    ih = 0;
+    ritz = ih + 2*ldh;
+    bounds = ritz + V->ncv;
+    iq = bounds + V->ncv;
+    iw = iq + (V->ncv)*(V->ncv);
+    next = iw + 3*(V->ncv);
+
+    ipntr[3] = next;
+    ipntr[4] = ih;
+    ipntr[5] = ritz;
+    ipntr[6] = bounds;
+    ipntr[10] = iw;
+
+    // Carry out the Implicitly restarted Lanczos Iteration.
+    dsaup2(V, resid, v, ldv, &workl[ih], ldh, &workl[ritz], &workl[bounds],
+           &workl[iq], ldq, &workl[iw], ipntr, workd);
+
+     /*-------------------------------------------------*
+     | ido .ne. 99 implies use of reverse communication |
+     | to compute operations involving OP or shifts.    |
+     *-------------------------------------------------*/
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info < 0) { return; }
+    if (V->info == 2) { V->info = 3; }
+
+    return;
+}
+
+
+void
+dsaup2(struct ARPACK_arnoldi_update_vars_d *V, double* resid, double* v, int ldv,
+       double* h, int ldh, double* ritz, double* bounds,
+       double* q, int ldq, double* workl, int* ipntr, double* workd)
+{
+    int int1 = 1, j, tmp_int, nevd2, nevm2;
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    double temp = 0.0;
+    // Initialize to silence the compiler warning
+    enum ARPACK_which temp_which = which_LM;
+
+    if (V->ido == ido_FIRST)
+    {
+        // nev0 and np0 are integer variables hold the initial values of NEV & NP
+        V->aup2_nev0 = V->nev;
+        V->aup2_np0 = V->np;
+
+        // kplusp is the bound on the largest Lanczos factorization built.
+        // nconv is the current number of "converged" eigenvalues.
+        // iter is the counter on the current iteration step.
+        V->aup2_kplusp = V->nev + V->np;
+        V->nconv = 0;
+        V->aup2_iter = 0;
+
+        // Set flags for computing the first NEV steps of the Lanczos factorization.               |
+
+        V->aup2_getv0 = 1;
+        V->aup2_update = 0;
+        V->aup2_cnorm = 0;
+        V->aup2_ushift = 0;
+
+        if (V->info != 0)
+        {
+            // User provides the initial residual vector.
+            V->aup2_initv = 1;
+            V->info = 0;
+        } else {
+            V->aup2_initv = 0;
+        }
+    }
+
+    // Get a possibly random starting vector and
+    // force it into the range of the operator OP.
+
+    if (V->aup2_getv0)
+    {
+        V->getv0_itry = 1;
+        dgetv0(V, V->aup2_initv, V->n, 0, v, ldv, resid, &V->aup2_rnorm, ipntr, workd);
+        if (V->ido != ido_DONE) { return; }
+        if (V->aup2_rnorm == 0.0)
+        {
+            V->info = -9;
+            V->ido = ido_DONE;
+            return;
+        }
+        V->aup2_getv0 = 0;
+        V->ido = ido_FIRST;
+    }
+
+    // Back from reverse communication :
+    // continue with update step
+
+    if (V->aup2_update) { goto LINE20; }
+
+    //  Back from computing user specified shifts
+
+    if (V->aup2_ushift) { goto LINE50; }
+
+    //  Back from computing residual norm
+    //  at the end of the current iteration
+
+    if (V->aup2_cnorm) { goto LINE100; }
+
+    //  Compute the first NEV steps of the Arnoldi factorization
+
+    dsaitr(V, 0, V->aup2_nev0, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //
+    //            M A I N  ARNOLDI  I T E R A T I O N  L O O P
+    //            Each iteration implicitly restarts the Arnoldi
+    //            factorization in place.
+    //
+
+LINE1000:
+
+    V->aup2_iter += 1;
+
+    // Compute NP additional steps of the Lanczos factorization.
+
+    V->ido = ido_FIRST;
+
+LINE20:
+    V->aup2_update = 1;
+
+    dsaitr(V, V->nev, V->np, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+     /*--------------------------------------------------*
+     | ido .ne. 99 implies use of reverse communication  |
+     | to compute operations involving OP and possibly B |
+     *--------------------------------------------------*/
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->aup2_update = 0;
+
+    // Compute the eigenvalues and corresponding error bounds
+    // of the current symmetric tridiagonal matrix.
+    dseigt(V->aup2_rnorm, V->aup2_kplusp, h, ldh, ritz, bounds, workl, &V->info);
+
+    if (V->info != 0)
+    {
+        V->info = -8;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    // Make a copy of eigenvalues and corresponding error
+    // bounds obtained from _seigt.
+
+    dcopy_(&V->aup2_kplusp, ritz, &int1, &workl[V->aup2_kplusp], &int1);
+    dcopy_(&V->aup2_kplusp, bounds, &int1, &workl[2*V->aup2_kplusp], &int1);
+
+    // Select the wanted Ritz values and their bounds
+    // to be used in the convergence test.
+    // The selection is based on the requested number of
+    // eigenvalues instead of the current NEV and NP to
+    // prevent possible misconvergence.
+    // * Wanted Ritz values := RITZ(NP+1:NEV+NP)
+    // * Shifts := RITZ(1:NP) := WORKL(1:NP)
+
+    V->nev = V->aup2_nev0;
+    V->np = V->aup2_np0;
+
+    dsgets(V, &V->nev, &V->np, ritz, bounds, workl);
+
+    // Convergence test
+
+    dcopy_(&V->nev, &bounds[V->np], &int1, &workl[V->np], &int1);
+    dsconv(V->nev, &ritz[V->np], &workl[V->np], V->tol, &V->nconv);
+
+    // Count the number of unwanted Ritz values that have zero
+    // Ritz estimates. If any Ritz estimates are equal to zero
+    // then a leading block of H of order equal to at least
+    // the number of Ritz values with zero Ritz estimates has
+    // split off. None of these Ritz values may be removed by
+    // shifting. Decrease NP the number of shifts to apply. If
+    // no shifts may be applied, then prepare to exit
+
+    tmp_int = V->np;
+    for (j = 0; j < tmp_int; j++)
+    {
+        if (bounds[j] == 0.0)
+        {
+            V->np -= 1;
+            V->nev += 1;
+        }
+    }
+    // 30
+
+    if ((V->nconv >= V->aup2_nev0) || (V->aup2_iter > V->maxiter) || (V->np == 0))
+    {
+        // Prepare to exit. Put the converged Ritz values
+        // and corresponding bounds in RITZ(1:NCONV) and
+        // BOUNDS(1:NCONV) respectively. Then sort. Be
+        // careful when NCONV > NP since we don't want to
+        // swap overlapping locations.
+
+        if (V->which == which_BE)
+        {
+
+            // Both ends of the spectrum are requested.
+            // Sort the eigenvalues into algebraically decreasing
+            // order first then swap low end of the spectrum next
+            // to high end in appropriate locations.
+            // NOTE: when np < floor(nev/2) be careful not to swap
+            // overlapping locations.
+
+            dsortr(which_SA, 1, V->aup2_kplusp, ritz, bounds);
+            nevd2 = V->aup2_nev0 / 2;
+            nevm2 = V->aup2_nev0 - nevd2;
+            if (V->nev > 1)
+            {
+                V->np = V->aup2_kplusp - V->aup2_nev0;
+
+                tmp_int = (nevd2 < V->np ? nevd2 : V->np);
+                int tmp_int2 = V->aup2_kplusp - tmp_int;
+
+                dswap_(&tmp_int, &ritz[nevm2], &int1, &ritz[tmp_int2], &int1);
+                dswap_(&tmp_int, &bounds[nevm2], &int1, &bounds[tmp_int2], &int1);
+            }
+
+        } else {
+
+            // LM, SM, LA, SA case.
+            // Sort the eigenvalues of H into the an order that
+            // is opposite to WHICH, and apply the resulting
+            // order to BOUNDS.  The eigenvalues are sorted so
+            // that the wanted part are always within the first
+            // NEV locations.
+
+            if (V->which == which_LM) { temp_which = which_SM; }
+            if (V->which == which_SM) { temp_which = which_LM; }
+            if (V->which == which_LA) { temp_which = which_SA; }
+            if (V->which == which_SA) { temp_which = which_LA; }
+
+            dsortr(temp_which, 1, V->aup2_kplusp, ritz, bounds);
+        }
+
+        // Scale the Ritz estimate of each Ritz value
+        // by 1 / max(eps23,magnitude of the Ritz value).
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmax(eps23, fabs(ritz[j]));
+            bounds[j] = bounds[j] / temp;
+        }
+        // 35
+
+        // Sort the Ritz values according to the scaled Ritz
+        // estimates.  This will push all the converged ones
+        // towards the front of ritzr, ritzi, bounds
+        // (in the case when NCONV < NEV.)
+
+        dsortr(which_LA, 1, V->aup2_nev0, bounds, ritz);
+
+        // Scale the Ritz estimate back to its original
+        // value.
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmax(eps23, fabs(ritz[j]));
+            bounds[j] = bounds[j] * temp;
+        }
+        // 40
+
+        // Sort the "converged" Ritz values again so that
+        // the "threshold" values and their associated Ritz
+        // estimates appear at the appropriate position in
+        // ritz and bound.
+
+        if (V->which == which_BE)
+        {
+
+            // Sort the "converged" Ritz values in increasing
+            // order.  The "threshold" values are in the
+            // middle.
+
+            dsortr(which_LA, 1, V->nconv, ritz, bounds);
+        } else {
+
+            // In LM, SM, LA, SA case, sort the "converged"
+            // Ritz values according to WHICH so that the
+            // "threshold" value appears at the front of
+            // ritz.
+
+            dsortr(V->which, 1, V->nconv, ritz, bounds);
+        }
+
+        //  Use h( 1,1 ) as storage to communicate
+        //  rnorm to _seupd if needed
+
+        h[0] = V->aup2_rnorm;
+
+        // Max iterations have been exceeded.
+
+        if ((V->aup2_iter > V->maxiter) && (V->nconv < V->nev))
+        {
+            V->info = 1;
+        }
+
+        // No shifts to apply.
+
+        if ((V->np ==  0) && (V->nconv < V->aup2_nev0))
+        {
+            V->info = 2;
+        }
+
+        V->np = V->nconv;
+        V->nev = V->nconv;
+        V->iter = V->aup2_iter;
+        V->ido = ido_DONE;
+        return;
+
+    } else if ((V->nconv < V->nev) && (V->shift == 1)) {
+
+        // Do not have all the requested eigenvalues yet.
+        // To prevent possible stagnation, adjust the number
+        // of Ritz values and the shifts.
+
+        int nevbef = V->nev;
+        V->nev += (V->nconv > (V->np / 2) ? (V->np / 2) : V->nconv);
+        if ((V->nev == 1) && (V->aup2_kplusp >= 6))
+        {
+            V->nev = V->aup2_kplusp / 2;
+        } else if ((V->nev == 1) && (V->aup2_kplusp > 2))
+        {
+            V->nev = 2;
+        }
+        V->np = V->aup2_kplusp - V->nev;
+
+        // If the size of NEV was just increased resort the eigenvalues.
+
+        if (nevbef < V->nev)
+        {
+            dsgets(V, &V->nev, &V->np, ritz, bounds, workl);
+        }
+    }
+
+    if (V->shift == 0)
+    {
+        // User specified shifts: reverse communication to
+        // compute the shifts. They are returned in the first
+        // NP locations of WORKL.
+
+        V->aup2_ushift = 1;
+        V->ido = ido_USER_SHIFT;
+        return;
+    }
+
+LINE50:
+
+    // Back from reverse communication;
+    // User specified shifts are returned
+    // in WORKL(1:*NP)
+
+    V->aup2_ushift = 0;
+
+    // Move the NP shifts to the first NP locations of RITZ to
+    // free up WORKL.  This is for the non-exact shift case;
+    // in the exact shift case, dsgets already handles this.
+
+    if (V->shift == 0) { dcopy_(&V->np, workl, &int1, ritz, &int1); }
+
+     /*--------------------------------------------------------*
+     | Apply the NP0 implicit shifts by QR bulge chasing.      |
+     | Each shift is applied to the entire tridiagonal matrix. |
+     | The first 2*N locations of WORKD are used as workspace. |
+     | After dsapps is done, we have a Lanczos                 |
+     | factorization of length NEV.                            |
+     *--------------------------------------------------------*/
+
+    dsapps(V->n, &V->nev, V->np, ritz, v, ldv, h, ldh, resid, q, ldq, workd);
+
+    // Compute the B-norm of the updated residual.
+    // Keep B*RESID in WORKD(1:N) to be used in
+    // the first step of the next call to dsaitr.
+
+    V->aup2_cnorm = 1;
+
+    if (V->bmat)
+    {
+        dcopy_(&V->n, resid, &int1, &workd[V->n], &int1);
+        ipntr[0] = V->n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*RESID
+
+        return;
+    } else {
+        dcopy_(&V->n, resid, &int1, workd, &int1);
+    }
+
+LINE100:
+
+     /*---------------------------------*
+     | Back from reverse communication; |
+     | WORKD(1:N) := B*RESID            |
+     *---------------------------------*/
+
+    if (V->bmat)
+    {
+        V->aup2_rnorm = sqrt(fabs(ddot_(&V->n, resid, &int1, workd, &int1)));
+    } else {
+        V->aup2_rnorm = dnrm2_(&V->n, resid, &int1);
+    }
+
+    V->aup2_cnorm = 0;
+
+    goto LINE1000;
+
+    //
+    //   E N D     O F     M A I N     I T E R A T I O N     L O O P
+    //
+
+}
+
+
+void
+dsconv(int n, double *ritz, double *bounds, double tol, int* nconv)
+{
+    const double eps23 = pow(ulp, 2.0 / 3.0);
+    double temp = 0.0;
+
+    *nconv = 0;
+    // Convergence test
+    for (int i = 0; i < n; i++)
+    {
+        temp = fmax(eps23, fabs(ritz[i]));
+        if (fabs(bounds[i]) <= tol * temp) { *nconv += 1; }
+    }
+
+    return;
+}
+
+
+void
+dseigt(double rnorm, int n, double* h, int ldh, double* eig, double* bounds,
+       double* workl, int* ierr)
+{
+    int int1 = 1, tmp_int;
+    dcopy_(&n, &h[ldh], &int1, eig, &int1);
+    tmp_int = n - 1;
+    dcopy_(&tmp_int, &h[1], &int1, workl, &int1);
+    dstqrb(n, eig, workl, bounds, &workl[n], ierr);
+    if (*ierr != 0) { return; }
+    for (int k = 0; k < n; k++) { bounds[k] = rnorm * fabs(bounds[k]); }
+    return;
+}
+
+
+void
+dsaitr(struct ARPACK_arnoldi_update_vars_d *V, int k, int np, double* resid, double* rnorm,
+       double* v, int ldv, double* h, int ldh, int* ipntr, double* workd)
+{
+    int i, infol, ipj, irj, ivj, jj, n, tmp_int;
+    const double sq2o2 = sqrt(2.0) / 2.0;
+
+    int int1 = 1;
+    double dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0, temp1;
+
+    n = V->n;  // n is constant, this is just for typing convenience
+    ipj = 0;
+    irj = ipj + n;
+    ivj = irj + n;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        // Initial call to this routine
+
+        V->aitr_j = k;
+        V->info = 0;
+        V->aitr_step3 = 0;
+        V->aitr_step4 = 0;
+        V->aitr_orth1 = 0;
+        V->aitr_orth2 = 0;
+        V->aitr_restart = 0;
+    }
+
+    // When in reverse communication mode one of:
+    // STEP3, STEP4, ORTH1, ORTH2, RSTART
+    // will be .true. when ....
+    // STEP3: return from computing OP*v_{j}.
+    // STEP4: return from computing B-norm of OP*v_{j}
+    // ORTH1: return from computing B-norm of r_{j+1}
+    // ORTH2: return from computing B-norm of
+    //        correction to the residual vector.
+    // RSTART: return from OP computations needed by
+    //         dgetv0.
+
+    if (V->aitr_step3) { goto LINE50; }
+    if (V->aitr_step4) { goto LINE60; }
+    if (V->aitr_orth1) { goto LINE70; }
+    if (V->aitr_orth2) { goto LINE90; }
+    if (V->aitr_restart) { goto LINE30; }
+
+    //  Else this is the first step
+
+    //
+    //         A R N O L D I     I T E R A T I O N     L O O P
+    //
+    //  Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1)
+
+LINE1000:
+
+        // Check for exact zero. Equivalent to determining whether
+        // a j-step Arnoldi factorization is present.
+
+    if (*rnorm > 0.0) { goto LINE40; }
+
+        // Invariant subspace found, generate a new starting
+        // vector which is orthogonal to the current Arnoldi
+        // basis and continue the iteration.
+
+    V->getv0_itry = 1;
+
+LINE20:
+    V->aitr_restart = 1;
+    V->ido = ido_FIRST;
+
+LINE30:
+
+    // If in reverse communication mode and aitr_restart = 1, flow returns here.
+
+    dgetv0(V, 0, n, V->aitr_j, v, ldv, resid, rnorm, ipntr, workd);
+
+    if (V->ido != ido_DONE) { return; }
+    V->aitr_ierr = V->info;
+    if (V->aitr_ierr < 0)
+    {
+        V->getv0_itry += 1;
+        if (V->getv0_itry <= 3) { goto LINE20; }
+
+        //  Give up after several restart attempts.
+        //  Set INFO to the size of the invariant subspace
+        //  which spans OP and exit.
+
+        V->info = V->aitr_j;
+        V->ido = ido_DONE;
+        return;
+    }
+
+LINE40:
+
+    //  STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm
+    //  Note that p_{j} = B*r_{j-1}. In order to avoid overflow
+    //  when reciprocating a small RNORM, test against lower
+    //  machine bound.
+
+    dcopy_(&n, resid, &int1, &v[ldv*(V->aitr_j)], &int1);
+    if (*rnorm >= unfl)
+    {
+        temp1 = 1.0 / *rnorm;
+        dscal_(&n, &temp1, &v[ldv*(V->aitr_j)], &int1);
+        dscal_(&n, &temp1, &workd[ipj], &int1);
+    } else {
+        dlascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &v[ldv*(V->aitr_j)], &n, &infol);
+        dlascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &workd[ipj], &n, &infol);
+    }
+
+    //  STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j}
+    //  Note that this is not quite yet r_{j}. See STEP 4
+
+    V->aitr_step3 = 1;
+    dcopy_(&n, &v[ldv*(V->aitr_j)], &int1, &workd[ivj], &int1);
+    ipntr[0] = ivj;
+    ipntr[1] = irj;
+    ipntr[2] = ipj;
+    V->ido = ido_OPX;
+
+    //  Exit in order to compute OP*v_{j}
+
+    return;
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  WORKD(IRJ:IRJ+N-1) := OP*v_{j}
+
+    V->aitr_step3 = 0;
+
+    // Put another copy of OP*v_{j} into RESID.
+
+    dcopy_(&n, &workd[irj], &int1, resid, &int1);
+
+    // STEP 4:  Finish extending the symmetric
+    //          Arnoldi to length j. If MODE = 2
+    //          then B*OP = B*inv(B)*A = A and
+    //          we don't need to compute B*OP.
+    // NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is
+    // assumed to have A*v_{j}.
+
+    if (V->mode == 2) { goto LINE65; }
+    if (V->bmat)
+    {
+        V->aitr_step4 = 1;
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*OP*v_{j}
+
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE60:
+
+    // Back from reverse communication;
+    // WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}.
+
+    V->aitr_step4 = 0;
+
+    //  The following is needed for STEP 5.
+    //  Compute the B-norm of OP*v_{j}.
+
+LINE65:
+
+    if (V->mode == 2)
+    {
+
+        // Note that the B-norm of OP*v_{j}
+        // is the inv(B)-norm of A*v_{j}.
+
+        V->aitr_wnorm = ddot_(&n, resid, &int1, &workd[ivj], &int1);
+        V->aitr_wnorm = sqrt(fabs(V->aitr_wnorm));
+    } else if (V->bmat) {
+        V->aitr_wnorm = ddot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_wnorm = sqrt(fabs(V->aitr_wnorm));
+    } else {
+        V->aitr_wnorm = dnrm2_(&n, resid, &int1);
+    }
+
+    //  Compute the j-th residual corresponding
+    //  to the j step factorization.
+    //  Use Classical Gram Schmidt and compute:
+    //  w_{j} <-  V_{j}^T * B * OP * v_{j}
+    //  r_{j} <-  OP*v_{j} - V_{j} * w_{j}
+
+    //  Compute the j Fourier coefficients w_{j}
+    //  WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.
+    tmp_int = V->aitr_j + 1;
+    if (V->mode != 2)
+    {
+        dgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &workd[irj], &int1);
+    } else {
+        dgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ivj], &int1, &dbl0, &workd[irj], &int1);
+    }
+
+    //  Orthogonalize r_{j} against V_{j}.
+    //  RESID contains OP*v_{j}. See STEP 3.
+
+    dgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &workd[irj], &int1, &dbl1, resid, &int1);
+
+    // Extend H to have j rows and columns.
+
+    h[V->aitr_j + ldh] = workd[irj + V->aitr_j];
+
+    if ((V->aitr_j == 0) || (V->aitr_restart))
+    {
+        h[V->aitr_j] = 0.0;
+    } else {
+        h[V->aitr_j] = *rnorm;
+    }
+
+    V->aitr_orth1 = 1;
+    V->aitr_iter = 0;
+
+    if (V->bmat)
+    {
+        dcopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}
+
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE70:
+
+    //  Back from reverse communication if ORTH1 = .true.
+    //  WORKD(IPJ:IPJ+N-1) := B*r_{j}.
+
+    V->aitr_orth1 = 0;
+
+    //  Compute the B-norm of r_{j}.
+
+    if (V->bmat)
+    {
+        *rnorm = ddot_(&n, resid, &int1, &workd[ipj], &int1);
+        *rnorm = sqrt(fabs(*rnorm));
+    } else {
+        *rnorm = dnrm2_(&n, resid, &int1);
+    }
+
+    // STEP 5: Re-orthogonalization / Iterative refinement phase
+    // Maximum NITER_ITREF tries.
+    //
+    //          s      = V_{j}^T * B * r_{j}
+    //          r_{j}  = r_{j} - V_{j}*s
+    //          alphaj = alphaj + s_{j}
+    //
+    // The stopping criteria used for iterative refinement is
+    // discussed in Parlett's book SEP, page 107 and in Gragg &
+    // Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.
+    // Determine if we need to correct the residual. The goal is
+    // to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||
+
+    if (*rnorm > sq2o2*V->aitr_wnorm) { goto LINE100; }
+
+    //  Enter the Iterative refinement phase. If further
+    //  refinement is necessary, loop back here. The loop
+    //  variable is ITER. Perform a step of Classical
+    //  Gram-Schmidt using all the Arnoldi vectors V_{j}
+
+LINE80:
+
+    //  Compute V_{j}^T * B * r_{j}.
+    //  WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1).
+    tmp_int = V->aitr_j + 1;
+    dgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &workd[irj], &int1);
+
+    //  Compute the correction to the residual:
+    //  r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).
+    //  The correction to H is v(:,1:J)*H(1:J,1:J)
+    //  + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.
+
+    dgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &workd[irj], &int1, &dbl1, resid, &int1);
+
+    if ((V->aitr_j == 0) || (V->aitr_restart))
+    {
+        h[V->aitr_j] = 0.0;
+    }
+    h[V->aitr_j + ldh] += workd[irj + V->aitr_j];
+
+    V->aitr_orth2 = 1;
+
+    if (V->bmat)
+    {
+        dcopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}.
+        //  r_{j} is the corrected residual.
+
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE90:
+
+    //  Back from reverse communication if ORTH2 = .true.
+
+    //  Compute the B-norm of the corrected residual r_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_rnorm1 = ddot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_rnorm1 = sqrt(fabs(V->aitr_rnorm1));
+    } else {
+        V->aitr_rnorm1 = dnrm2_(&n, resid, &int1);
+    }
+
+    //  Determine if we need to perform another
+    //  step of re-orthogonalization.
+
+    if (V->aitr_rnorm1 > sq2o2*(*rnorm))
+    {
+
+        //  No need for further refinement.
+
+        *rnorm = V->aitr_rnorm1;
+
+    } else {
+
+        // Another step of iterative refinement step is required.
+
+        *rnorm = V->aitr_rnorm1;
+        V->aitr_iter += 1;
+        if (V->aitr_iter < 2) { goto LINE80; }
+
+        //  Otherwise RESID is numerically in the span of V
+
+        for (jj = 0; jj < n; jj++)
+        {
+            resid[jj] = 0.0;
+        }
+        *rnorm = 0.0;
+    }
+
+    // Branch here directly if iterative refinement
+    // wasn't necessary or after at most NITER_REF
+    // steps of iterative refinement.
+
+LINE100:
+
+    V->aitr_restart = 0;
+    V->aitr_orth2 = 0;
+
+    // Make sure the last off-diagonal element is non negative
+    // If not perform a similarity transformation on H(1:j,1:j)
+    // and scale v(:,j) by -1.
+
+    if (h[V->aitr_j] < 0.0)
+    {
+        h[V->aitr_j] = -h[V->aitr_j];
+        if (V->aitr_j < k + np - 1)
+        {
+            dscal_(&n, &dblm1, &v[V->aitr_j + 1], &int1);
+        } else {
+            dscal_(&n, &dblm1, resid, &int1);
+        }
+    }
+
+    // STEP 6: Update  j = j+1;  Continue
+
+    V->aitr_j += 1;
+    if (V->aitr_j >= k + np)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    // Loop back to extend the factorization by another step.
+
+    goto LINE1000;
+
+}
+
+
+void
+dsapps(int n, int* kev, int np, double* shift, double* v, int ldv, double* h, int ldh,
+       double* resid, double* q, int ldq, double* workd)
+{
+    int i, iend, istart, jj, kplusp, tmp_int, int1 = 1;
+    double a1, a2, a3, a4, c, f, g, r, s, sigma, tst1;
+    double dbl0 = 0.0, dbl1 = 1.0, dblm1 = -1.0;
+
+    iend = 0;
+    kplusp = *kev + np;
+
+    // Initialize Q to the identity to accumulate
+    // the rotations and reflections
+
+    dlaset_("A", &kplusp, &kplusp, &dbl0, &dbl1, q, &ldq);
+
+    // Quick return if there are no shifts to apply
+
+    if (np == 0) { return; }
+
+    for (jj = 0; jj < np; jj++)
+    {
+        sigma = shift[jj];
+
+        // Check for splitting and deflation. Currently we consider
+        // an off-diagonal element h(i+1,1) negligible if
+        //         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )
+        // for i=1:KEV+NP-1.
+        // If above condition tests true then we set h(i+1,1) = 0.
+        // Note that h(1:KEV+NP,1) are assumed to be non negative.
+
+        istart = 0;
+        while (istart < kplusp - 1)
+        {
+
+            for (iend = istart; iend < kplusp - 1; iend++)
+            {
+                tst1 = fabs(h[iend + ldh]) + fabs(h[iend + 1 + ldh]);
+                if (h[iend + 1] <= ulp * tst1)
+                {
+                    h[iend + 1] = 0.0;
+                    break;
+                }
+            }
+
+            // Scalar block, skipping, correct the sign if necessary
+            if (istart == iend)
+            {
+                istart += 1;
+                if (h[iend] < 0.0)
+                {
+                    h[iend] = -h[iend];
+                    dscal_(&kplusp, &dblm1, &q[ldq*(iend)], &int1);
+                }
+                continue;
+            }
+
+            // We have a valid block [istart, iend] inclusive
+            f = h[istart + ldh] - sigma;
+            g = h[istart + 1];
+
+            for (i = istart; i < iend; i++)
+            {
+                // Applying the plane rotations that create and chase the bulge X
+                //
+                // [c,  s] [ x x        ] [c, -s]       [ x x X      ]
+                // [-s, c] [ x x x      ] [s,  c]       [ x x x      ]
+                //         [   x x x    ]          =>   [ X x x x    ]
+                //         [     x x x  ]               [     x x x  ]
+                //         [         ...]               [         ...]
+                //
+                // dlartgp (instead of dlartg) is used to make sure that the
+                // off-diagonal elements stay non-negative, (cf. F77 code for
+                // manual handling).
+
+                //                                  a1          a2
+                // [c,  s] [ k m ] [c, -s]    [ c*k + s*m,  s*k + c*m] [c, -s]
+                // [-s, c] [ m n ] [s,  c]    [-s*k + c*m, -s*m + c*n] [s,  c]
+                //                                  a3          a4
+
+                dlartgp_(&f, &g, &c, &s, &r);
+                if (i > istart)
+                {
+                    h[i] = r;
+                }
+                a1 = c*h[i + ldh]     + s*h[i + 1];
+                a2 = c*h[i + 1]       + s*h[i + 1 + ldh];
+                a4 = c*h[i + 1 + ldh] - s*h[i + 1];
+                a3 = c*h[i + 1]       - s*h[i + ldh];
+                h[i + ldh]     = c*a1 + s*a2;              // h[i  , i  ]
+                h[i + 1 + ldh] = c*a4 - s*a3;              // h[i+1, i+1]
+                h[i + 1]       = c*a3 + s*a4;              // h[i+1, i  ]
+
+                // Accumulate the rotation also in Q
+                tmp_int = (i + jj + 2 > kplusp ? kplusp : i + jj + 2);
+                drot_(&tmp_int, &q[ldq*i], &int1, &q[ldq*(i+1)], &int1, &c, &s);
+
+                if (i < iend - 1)
+                {
+                    // g is the bulge created by the rotation
+                    f = h[i + 1];
+                    g = s*h[i + 2];
+                    h[i + 2] = c*h[i + 2];
+                }
+            }
+            istart = iend + 1;
+            if (h[iend] < 0.0)
+            {
+                h[iend] = -h[iend];
+                dscal_(&kplusp, &dblm1, &q[ldq*(iend)], &int1);
+            }
+        }
+    }
+    // 90
+
+    // All shifts have been applied. Check for
+    // more possible deflation that might occur
+    // after the last shift is applied.
+
+    for (i = 0; i < kplusp - 1; i++)
+    {
+        tst1 = fabs(h[i + ldh]) + fabs(h[i+1 + ldh]);
+        if (h[i+1] <= ulp*tst1)
+        {
+            h[i+1] = 0.0;
+        }
+    }
+    // 100
+
+    // Compute the (kev+1)-st column of (V*Q) and
+    // temporarily store the result in WORKD(N+1:2*N).
+    // This is not necessary if h(kev+1,1) = 0.
+
+    if (h[*kev] > 0.0)
+    {
+        dgemv_("N", &n, &kplusp, &dbl1, v, &ldv, &q[ldq*(*kev)], &int1, &dbl0, &workd[n], &int1);
+    }
+
+    // Compute column 1 to kev of (V*Q) in backward order
+    // taking advantage that Q is an upper triangular matrix
+    // with lower bandwidth np.
+    // Place results in v(:,kplusp-kev:kplusp) temporarily.
+
+    for (i = 0; i < *kev; i++)
+    {
+        tmp_int = kplusp - i;
+        dgemv_("N", &n, &tmp_int, &dbl1, v, &ldv, &q[ldq*(*kev-i-1)], &int1, &dbl0, workd, &int1);
+        dcopy_(&n, workd, &int1, &v[ldv*(kplusp-i-1)], &int1);
+    }
+    // 130
+
+    // Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev).
+
+    for (i = 0; i < *kev; i++)
+    {
+        dcopy_(&n, &v[ldv*(np+i)], &int1, &v[ldv*i], &int1);
+    }
+    // 140
+
+    if (h[*kev] > 0.0)
+    {
+        dcopy_(&n, &workd[n], &int1, &v[ldv*(*kev)], &int1);
+    }
+
+    // Update the residual vector:
+    //    r <- sigmak*r + betak*v(:,kev+1)
+    // where
+    //    sigmak = (e_{kev+p}'*Q)*e_{kev}
+    //    betak = e_{kev+1}'*H*e_{kev}
+
+    dscal_(&n, &q[kplusp-1 + (*kev-1)*ldq], resid, &int1);
+    if (h[*kev] > 0.0)
+    {
+        daxpy_(&n, &h[*kev], &v[ldv*(*kev)], &int1, resid, &int1);
+    }
+
+    return;
+}
+
+
+void
+dsgets(struct ARPACK_arnoldi_update_vars_d *V, int* kev, int* np, double* ritz,
+       double* bounds, double* shifts)
+{
+    int kevd2, tmp1, tmp2, int1 = 1;
+    if (V->which == which_BE)
+    {
+        // Both ends of the spectrum are requested.
+        // Sort the eigenvalues into algebraically increasing
+        // order first then swap high end of the spectrum next
+        // to low end in appropriate locations.
+        // NOTE: when np < floor(kev/2) be careful not to swap
+        // overlapping locations.
+
+        dsortr(which_LA, 1, *kev + *np, ritz, bounds);
+        kevd2 = *kev / 2;
+        if (*kev > 1)
+        {
+            tmp1 = (kevd2 > *np ? *np : kevd2);
+            tmp2 = (kevd2 > *np ? kevd2 : *np);
+            dswap_(&tmp1, ritz, &int1, &ritz[tmp2], &int1);
+            dswap_(&tmp1, bounds, &int1, &bounds[tmp2], &int1);
+        }
+    } else {
+
+        // LM, SM, LA, SA case.
+        // Sort the eigenvalues of H into the desired order
+        // and apply the resulting order to BOUNDS.
+        // The eigenvalues are sorted so that the wanted part
+        // are always in the last KEV locations.
+
+        dsortr(V->which, 1, *kev + *np, ritz, bounds);
+    }
+
+    if ((V->shift == 1) && (*np > 0))
+    {
+
+        // Sort the unwanted Ritz values used as shifts so that
+        // the ones with largest Ritz estimates are first.
+        // This will tend to minimize the effects of the
+        // forward instability of the iteration when the shifts
+        // are applied in subroutine dsapps.
+
+        dsortr(which_SM, 1, *np, bounds, ritz);
+        dcopy_(np, ritz, &int1, shifts, &int1);
+    }
+}
+
+
+void
+dgetv0(struct ARPACK_arnoldi_update_vars_d *V, int initv, int n, int j,
+       double* v, int ldv, double* resid, double* rnorm, int* ipntr, double* workd)
+{
+    int jj, int1 = 1;
+    const double sq2o2 = sqrt(2.0) / 2.0;
+    double dbl1 = 1.0, dbl0 = 0.0, dblm1 = -1.0;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->info = 0;
+        V->getv0_iter = 0;
+        V->getv0_first = 0;
+        V->getv0_orth = 0;
+
+        //  Possibly generate a random starting vector in RESID
+        //  Skip if this the return of ido_RANDOM.
+
+        if (!(initv))
+        {
+            // Request a random vector from the user into resid
+            V->ido = ido_RANDOM;
+            return;
+        } else {
+            V->ido = ido_RANDOM;
+        }
+    }
+
+    // Back from random vector generation
+    if (V->ido == ido_RANDOM)
+    {
+        //  Force the starting vector into the range of OP to handle
+        //  the generalized problem when B is possibly (singular).
+
+        if (V->getv0_itry == 1)
+        {
+            ipntr[0] = 0;
+            ipntr[1] = n;
+            dcopy_(&n, resid, &int1, workd, &int1);
+            V->ido = ido_RANDOM_OPX;
+            return;
+        } else if ((V->getv0_itry > 1) && (V->bmat == 1))
+        {
+            dcopy_(&n, resid, &int1, &workd[n], &int1);
+        }
+    }
+
+    //  Back from computing OP*(initial-vector)
+
+    if (V->getv0_first) { goto LINE20; }
+
+    //  Back from computing OP*(orthogonalized-vector)
+
+    if (V->getv0_orth) { goto LINE40; }
+
+    //  Starting vector is now in the range of OP; r = OP*r;
+    //  Compute B-norm of starting vector.
+
+    V->getv0_first = 1;
+    if (V->getv0_itry == 1)
+    {
+        dcopy_(&n, &workd[n], &int1, resid, &int1);
+    }
+    if (V->bmat)
+    {
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE20:
+
+    V->getv0_first = 0;
+    if (V->bmat)
+    {
+        V->getv0_rnorm0 = ddot_(&n, resid, &int1, workd, &int1);
+        V->getv0_rnorm0 = sqrt(fabs(V->getv0_rnorm0));
+    } else {
+        V->getv0_rnorm0 = dnrm2_(&n, resid, &int1);
+    }
+    *rnorm = V->getv0_rnorm0;
+
+    //  Exit if this is the very first Arnoldi step
+
+    if (j == 0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //  Otherwise need to B-orthogonalize the starting vector against
+    //  the current Arnoldi basis using Gram-Schmidt with iter. ref.
+    //  This is the case where an invariant subspace is encountered
+    //  in the middle of the Arnoldi factorization.
+    //
+    //        s = V^{T}*B*r;   r = r - V*s;
+    //
+    //  Stopping criteria used for iter. ref. is discussed in
+    //  Parlett's book, page 107 and in Gragg & Reichel TOMS paper.
+
+    V->getv0_orth = 1;
+
+LINE30:
+
+    dgemv_("T", &n, &j, &dbl1, v, &ldv, workd, &int1, &dbl0, &workd[n], &int1);
+    dgemv_("N", &n, &j, &dblm1, v, &ldv, &workd[n], &int1, &dbl1, resid, &int1);
+
+    //  Compute the B-norm of the orthogonalized starting vector
+
+    if (V->bmat)
+    {
+        dcopy_(&n, resid, &int1, &workd[n], &int1);
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        dcopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE40:
+    if (V->bmat)
+    {
+        *rnorm = ddot_(&n, resid, &int1, workd, &int1);
+        *rnorm = sqrt(fabs(*rnorm));
+    } else {
+        *rnorm = dnrm2_(&n, resid, &int1);
+    }
+
+    //  Check for further orthogonalization.
+
+    if (*rnorm > sq2o2*V->getv0_rnorm0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->getv0_iter += 1;
+    if (V->getv0_iter < 5)
+    {
+
+        //  Perform iterative refinement step
+
+        V->getv0_rnorm0 = *rnorm;
+        goto LINE30;
+    } else {
+
+        //  Iterative refinement step "failed"
+
+        for (jj = 0; jj < n; jj++) { resid[jj] = 0.0; }
+        *rnorm = 0.0;
+        V->info = -1;
+    }
+
+    V->ido = ido_DONE;
+
+    return;
+}
+
+
+void
+dsortr(const enum ARPACK_which w, const int apply, const int n, double* x1, double* x2)
+{
+    int i, igap, j;
+    double temp;
+    ARPACK_compare_rfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortr_LM;
+            break;
+        case which_SM:
+            f = sortr_SM;
+            break;
+        case which_LA:
+            f = sortr_LA;
+            break;
+        case which_SA:
+            f = sortr_SA;
+            break;
+        default:
+            f = sortr_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(x1[j], x1[j+igap]))
+            {
+                if (j < 0) { break; }
+                temp = x1[j];
+                x1[j] = x1[j+igap];
+                x1[j+igap] = temp;
+
+                if (apply)
+                {
+                    temp = x2[j];
+                    x2[j] = x2[j+igap];
+                    x2[j+igap] = temp;
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+}
+
+
+void
+dsesrt(const enum ARPACK_which w, const int apply, const int n, double* x, int na, double* a, const int lda)
+{
+    int i, igap, j, int1 = 1;
+    double temp;
+    ARPACK_compare_rfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortr_LM;
+            break;
+        case which_SM:
+            f = sortr_SM;
+            break;
+        case which_LA:
+            f = sortr_LA;
+            break;
+        case which_SA:
+            f = sortr_SA;
+            break;
+        default:
+            f = sortr_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(x[j], x[j + igap]))
+            {
+                if (j < 0) { break; }
+                temp = x[j];
+                x[j] = x[j+igap];
+                x[j+igap] = temp;
+
+                if (apply)
+                {
+                    dswap_(&na, &a[lda*j], &int1, &a[lda*(j+igap)], &int1);
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+    // 10, 40, 70, 120
+}
+
+
+void
+dstqrb(int n, double* d, double* e, double* z, double* work, int* info)
+{
+    int int1 = 1, int0 = 0;
+    double eps2 = pow(ulp, 2.0);
+    double safmin = unfl;
+    double safmax = (1.0 / safmin);
+    double ssfmax = sqrt(safmax) / 3.0;
+    double ssfmin = sqrt(safmin) / eps2;
+
+    int nmaxit, jtot, i, ii, j, k, l1, m = 0, tmp_int = 0, l, lsv, lend, lendsv, iscale;
+    double anorm = 0.0, rt1 = 0.0, rt2 = 0.0, c = 0.0, s = 0.0, g = 0.0, r = 0.0, p = 0.0;
+    double b, f, tst;
+
+    *info = 0;
+    if (n == 0) { return; }
+    if (n == 1) { z[0] = 1.0; return; }
+
+    // Set z as the last row of identity matrix
+    for (i = 0; i < n-1; i++) { z[i] = 0.0; }
+    z[n-1] = 1.0;
+
+    nmaxit = n*30;
+    jtot = 0;
+
+    //  Determine where the matrix splits and choose QL or QR iteration
+    //  for each block, according to whether top or bottom diagonal
+    //  element is smaller.
+
+    // Translation Note:
+    // All indices are 1-based, since the F77 code is very complicated.
+    // Instead array indices are decremented where necessary.
+
+    l1 = 1;
+
+    while (jtot < nmaxit)
+    {
+        if (l1 > n) { break; }
+
+        if (l1 > 1) { e[l1 - 2] = 0.0; }
+        if (l1 <= n - 1)
+        {
+            for (m = l1; m <= n - 1; m++)
+            {
+                tst = fabs(e[m - 1]);
+                if (tst == 0.0) { break; }
+                if (tst <= (sqrt(fabs(d[m-1]))*sqrt(fabs(d[m])))*ulp)
+                {
+                    e[m-1] = 0.0;
+                    break;
+                }
+            }
+            // 20
+        } else {
+            m = n;
+        }
+        // 30
+
+        // m will mark the splitting point, if any.
+        l = l1;
+        lsv = l;
+        lend = m;
+        lendsv = lend;
+        l1 = m + 1;
+
+        // Scalar block, skipping
+        if (lend == l) { continue; }
+
+        // Scale submatrix in rows and columns L to LEND
+        tmp_int = lend - l + 1;
+        anorm = dlanst_("I", &tmp_int, &d[l-1], &e[l-1]);
+        iscale = 0;
+
+        if (anorm == 0.0) { continue; }
+
+        if (anorm > ssfmax)
+        {
+            iscale = 1;
+            dlascl_("G", &int0, &int0, &anorm, &ssfmax, &tmp_int, &int1, &d[l-1], &n, info);
+            tmp_int -= 1;
+            dlascl_("G", &int0, &int0, &anorm, &ssfmax, &tmp_int, &int1, &e[l-1], &n, info);
+        } else if (anorm < ssfmin) {
+            iscale = 2;
+            dlascl_("G", &int0, &int0, &anorm, &ssfmin, &tmp_int, &int1, &d[l-1], &n, info);
+            tmp_int -= 1;
+            dlascl_("G", &int0, &int0, &anorm, &ssfmin, &tmp_int, &int1, &e[l-1], &n, info);
+        }
+        // Choose between QL and QR iteration
+
+        if (fabs(d[lend-1]) < fabs(d[l-1]))
+        {
+            lend = lsv;
+            l = lendsv;
+        }
+        if (lend > l)
+        {
+            // QL Iteration
+            while (1)
+            {
+                // Look for small subdiagonal element.
+                // 40
+                if (l != lend)
+                {
+                    for (m = l; m < lend; m++)
+                    {
+                        tst = fabs(e[m-1]);
+                        tst = tst*tst;
+                        if (tst <= (eps2*fabs(d[m - 1]))*fabs(d[m]) + safmin) { break; }
+                        if (m == lend - 1) { m = lend; break; }  // No break condition
+                    }
+                    // 50, 60
+                } else {
+                    m = lend;
+                }
+                if (m < lend) { e[m - 1] = 0.0; }
+
+                p = d[l - 1];
+                if (m == l)
+                {
+                        // 80
+                        // Eigenvalue found
+                        d[l - 1] = p;
+                        l += 1;
+                        if (l <= lend) { continue; }  // Top of QL iteration
+                        break;  // go to 140 undo scaling
+                }
+                // If remaining matrix is 2x2, use dlaev2 to compute its eigensystem
+                if (m == l + 1)
+                {
+                    dlaev2_(&d[l - 1], &e[l - 1], &d[l], &rt1, &rt2, &c, &s);
+                    work[l - 1] = c;
+                    work[n - 1 + l - 1] = s;
+                    tst    = z[l];
+                    z[l]   = c*tst - s*z[l-1];
+                    z[l-1] = s*tst + c*z[l-1];
+                    d[l-1] = rt1;
+                    d[l]   = rt2;
+                    e[l-1] = 0.0;
+                    l += 2;
+                    if (l <= lend) { continue; }  // go to 40
+                    break;  // go to 140
+                }
+
+                if (jtot == nmaxit) { break; } // go to 140
+                jtot += 1;
+
+                // Form shift
+                g = (d[l]- p) / (2.0 * e[l-1]);
+                r = hypot(g, 1.0);
+                g = d[m-1] - p + (e[l-1] / (g + copysign(r, g)));
+
+                s = 1.0;
+                c = 1.0;
+                p = 0.0;
+
+                // Inner loop
+                for (i = m - 1; i >= l; i--)
+                {
+                    f = s * e[i-1];
+                    b = c * e[i-1];
+                    dlartg_(&g, &f, &c, &s, &r);
+                    if (i != m - 1) { e[i] = r; }
+                    g = d[i] - p;
+                    r = (d[i-1] - g)*s + 2.0*c*b;
+                    p = s*r;
+                    d[i] = g + p;
+                    g = c*r - b;
+                    work[i-1] = c;
+                    work[n-1+i-1] = -s;
+                }
+                // 70
+                tmp_int = m - l + 1;
+                dlasr_("R", "V", "B", &int1, &tmp_int, &work[l-1], &work[n-1+l-1], &z[l-1], &int1);
+
+                d[l-1] = d[l-1] - p;
+                e[l-1] = g;
+
+            }
+        } else {
+            // QR Iteration
+
+            // Look for small subdiagonal element.
+            while (1)
+            {
+                if (l != lend)
+                {
+                    for (m = l; m > lend; m--)
+                    {
+                        tst = fabs(e[m-2]);
+                        tst = tst*tst;
+                        if (tst <= (eps2*fabs(d[m-1]))*fabs(d[m-2]) + safmin) { break; }
+                        if (m == lend+1) { m = lend; break; }  // No break
+                    }
+                } else {
+                    m = lend;
+                }
+                // 100, 110
+                if (m > lend) { e[m-2] = 0.0; }
+                p = d[l-1];
+                if (m == l)
+                {
+                    // 130
+                    // Eigenvalue found
+                    d[l-1] = p;
+                    l -= 1;
+                    if (l >= lend) { continue; } // Top of QR iteration
+                    break; // go to 140 undo scaling
+                }
+                // If remaining matrix is 2x2, use dlaev2 to compute its eigensystem
+                if (m == l - 1)
+                {
+                    dlaev2_(&d[l-2], &e[l-2], &d[l-1], &rt1, &rt2, &c, &s);
+                    tst    = z[l-1];
+                    z[l-1] = c*tst - s*z[l-2];
+                    z[l-2] = s*tst + c*z[l-2];
+                    d[l-2] = rt1;
+                    d[l-1] = rt2;
+                    e[l-2] = 0.0;
+                    l -= 2;
+
+                    if (l >= lend) { continue; } // Top of QR iteration
+                    break; // go to 140 undo scaling
+                }
+
+                if (jtot == nmaxit) { break; }  // go to 140
+                jtot += 1;
+
+                // Form the shift
+                g = (d[l-2] - p) / (2.0*e[l-2]);
+                r = hypot(g, 1.0);
+                g = d[m-1] - p + (e[l-2] / (g + copysign(r, g)));
+
+                s = 1.0;
+                c = 1.0;
+                p = 0.0;
+
+                // Inner loop
+                for (i = m; i < l; i++)
+                {
+                    f = s * e[i-1];
+                    b = c * e[i-1];
+                    dlartg_(&g, &f, &c, &s, &r);
+                    if (i != m) { e[i-2] = r; }
+                    g = d[i-1] - p;
+                    r = (d[i] - g)*s + 2.0*c*b;
+                    p = s*r;
+                    d[i-1] = g + p;
+                    g = c*r - b;
+
+                    // Save rotations
+                    work[i-1] = c;
+                    work[n-1+i-1] = s;
+                }
+                // 120
+                // Apply saved rotations.
+                tmp_int = l - m + 1;
+                dlasr_("R", "V", "F", &int1, &tmp_int, &work[m-1], &work[n-1+m-1], &z[m-1], &int1);
+
+                d[l-1] = d[l-1] - p;
+                e[l - 2] = g;
+
+            }
+        }
+        // 140 Still in the outer while loop; it breaks at the top
+
+        // Undo scaling if necessary
+        tmp_int = lendsv-lsv+1;
+        if (iscale == 1)
+        {
+
+            dlascl_("G", &int0, &int0, &ssfmax, &anorm, &tmp_int, &int1, &d[lsv-1], &n, info);
+            tmp_int -= 1;
+            dlascl_("G", &int0, &int0, &ssfmax, &anorm, &tmp_int, &int1, &e[lsv-1], &n, info);
+
+        } else if (iscale == 2) {
+
+            dlascl_("G", &int0, &int0, &ssfmin, &anorm, &tmp_int, &int1, &d[lsv-1], &n, info);
+            tmp_int -= 1;
+            dlascl_("G", &int0, &int0, &ssfmin, &anorm, &tmp_int, &int1, &e[lsv-1], &n, info);
+
+        }
+
+        // Check for no convergence to an eigenvalue after a total of n*maxit iterations
+        if (jtot >= nmaxit)
+        {
+            for (i = 0; i < n-1; i++) { if (e[i] != 0.0) { *info += 1; } }
+            return;  // 150
+        }
+    }
+    // Out of the while loop
+
+    //  Order eigenvalues and eigenvectors.
+    //  Use selection sort to minimize swaps of eigenvectors.
+    for (ii = 1; ii < n; ii++)
+    {
+        i = ii - 1;
+        k = i;
+        p = d[i];
+
+        for (j = ii; j < n; j++)
+        {
+            if (d[j] < p)
+            {
+                k = j;
+                p = d[j];
+            }
+        }
+        // 170
+        if (k != i)
+        {
+            d[k] = d[i];
+            d[i] = p;
+            p = z[k];
+            z[k] = z[i];
+            z[i] = p;
+        }
+    }
+    // 180
+
+    return;
+}
+
+
+int sortr_LM(const double x1, const double x2) { return (fabs(x1) > fabs(x2)); }
+int sortr_SM(const double x1, const double x2) { return (fabs(x1) < fabs(x2)); }
+int sortr_LA(const double x1, const double x2) { return (x1 > x2); }
+int sortr_SA(const double x1, const double x2) { return (x1 < x2); }
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.h
new file mode 100644
index 0000000000..f0fb145cfb
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_double.h
@@ -0,0 +1,31 @@
+#ifndef _ARPACK_S_DOUBLE_H
+#define _ARPACK_S_DOUBLE_H
+
+#include "_arpack.h"
+
+// BLAS Routines used
+void daxpy_(int* n, double* alpha, double* x, int* incx, double* y, int* incy);
+void dcopy_(int* n, double* x, int* incx, double* y, int* incy);
+double ddot_(int* n, double* x, int* incx, double* y, int* incy);
+void dgemv_(char* trans, int* m, int* n, double* alpha, double* a, int* lda, double* x, int* incx, double* beta, double* y, int* incy);
+void dger_(int* m, int* n, double* alpha, double* x, int* incx, double* y, int* incy, double* a, int* lda);
+double dnrm2_(int* n, double* x, int* incx);
+void drot_(int* n, double* sx, int* incx, double* sy, int* incy, double* c, double* s);
+void dscal_(int* n, double* alpha, double* x, int* incx);
+void dswap_(int* n, double* x, int* incx, double* y, int* incy);
+void dtrmm_(char* side, char* uplo, char* transa, char* diag, int* m, int* n, double* alpha, double* a, int* lda, double* b, int* ldb);
+
+// LAPACK Routines used
+void dgeqr2_(int* m, int* n, double* a, int* lda, double* tau, double* work, int* info);
+void dlacpy_(char* uplo, int* m, int* n, double* a, int* lda, double* b, int* ldb);
+void dlaev2_(double* a, double* b, double* c, double* rt1, double* rt2, double* cs1, double* sn1);
+double dlanst_(char* norm, int* n, double* d, double* e);
+void dlartg_(double* f, double* g, double* c, double* s, double* r);
+void dlartgp_(double* f, double* g, double* c, double* s, double* r);
+void dlascl_(char* mtype, int* kl, int* ku, double* cfrom, double* cto, int* m, int* n, double* a, int* lda, int* info);
+void dlaset_(char* uplo, int* m, int* n, double* alpha, double* beta, double* a, int* lda);
+void dlasr_(char* side, char* pivot, char* direct, int* m, int* n, double* c, double* s, double* a, int* lda);
+void dorm2r_(char* side, char* trans, int* m, int* n, int* k, double* a, int* lda, double* tau, double* c, int* ldc, double* work, int* info);
+void dsteqr_(char* compz, int* n, double* d, double* e, double* z, int* ldz, double* work, int* info);
+
+#endif
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.c b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.c
new file mode 100644
index 0000000000..ac3d5471bf
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.c
@@ -0,0 +1,2238 @@
+#include "_arpack_s_single.h"
+
+typedef int ARPACK_compare_rfunc(const float, const float);
+
+static int sortr_LM(const float, const float);
+static int sortr_SM(const float, const float);
+static int sortr_LA(const float, const float);
+static int sortr_SA(const float, const float);
+
+static const float unfl = 1.1754943508222875e-38;
+static const float ulp = 1.1920928955078125e-07;
+
+static void ssaup2(struct ARPACK_arnoldi_update_vars_s*, float*, float*, int, float*, int, float*, float*, float*, int, float*, int*, float*);
+static void ssconv(int, float*, float*, float, int*);
+static void sseigt(float, int, float*, int, float*, float*, float*, int*);
+static void ssaitr(struct ARPACK_arnoldi_update_vars_s*, int, int, float*, float*, float*, int, float*, int, int*, float*);
+static void ssapps(int, int*, int, float*, float*, int, float*, int, float*, float* , int, float*);
+static void ssgets(struct ARPACK_arnoldi_update_vars_s*, int*, int*, float*, float*, float*);
+static void sgetv0(struct ARPACK_arnoldi_update_vars_s *, int, int, int, float*, int, float*, float*, int*, float*);
+static void ssortr(const enum ARPACK_which w, const int apply, const int n, float* x1, float* x2);
+static void ssesrt(const enum ARPACK_which w, const int apply, const int n, float* x, int na, float* a, const int lda);
+static void sstqrb(int n, float* d, float* e, float* z, float* work, int* info);
+
+enum ARPACK_seupd_type {
+    REGULAR,
+    SHIFTI,
+    BUCKLE,
+    CAYLEY
+};
+
+
+void
+ARPACK_sseupd(struct ARPACK_arnoldi_update_vars_s *V, int rvec, int howmny, int* select,
+       float* d, float* z, int ldz, float sigma, float* resid, float* v,
+       int ldv, int* ipntr, float* workd, float* workl)
+{
+    const float eps23 = powf(ulp, 2.0f / 3.0f);
+    int j, jj, k;
+    int ibd, ih, ihb, ihd, iq, irz, iw, ldh, ldq, ritz, bounds, next, np;
+    int ierr = 0, int1 = 1, tmp_int = 0, numcnv, reord;
+    float bnorm2, rnorm, temp, temp1, dbl1 = 1.0f;
+
+    if (V->nconv == 0) { return; }
+
+    ierr = 0;
+    enum ARPACK_seupd_type TYP = REGULAR;
+
+    if (V->nconv <= 0) {
+        ierr = -14;
+    } else if (V->n <= 0) {
+        ierr = -1;
+    } else if (V->nev <= 0) {
+        ierr = -2;
+    } else if ((V->ncv <= V->nev) || (V->ncv > V->n)) {
+        ierr = -3;
+    } else if ((V->which != 0) &&
+               (V->which != 1) &&
+               (V->which != 6) &&
+               (V->which != 7) &&
+               (V->which != 8)) {
+        ierr = -5;
+    } else if ((V->bmat != 0) && (V->bmat != 1)) {
+        ierr = -6;
+    } else if ((rvec) && ((howmny < 0) || (howmny > 2))) {
+        ierr = -15;
+    } else if ((rvec) && (howmny == 2)) {
+        ierr = -16;  // NotImplementedError
+    }
+
+    if ((V->mode == 1) || (V->mode == 2)) {
+        TYP = REGULAR;
+    } else if (V->mode == 3) {
+        TYP = SHIFTI;
+    } else if (V->mode == 4) {
+        TYP = BUCKLE;
+    } else if (V->mode == 5) {
+        TYP = CAYLEY;
+    } else {
+        ierr = -10;
+    }
+
+    if ((V->mode == 1) && (V->bmat)) { ierr = -11; }
+    if ((V->nev == 1) && (V->which == which_BE)) { ierr = -12; }
+
+    if (ierr != 0) {
+        V->info = ierr;
+        return;
+    }
+
+
+    // Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    // etc... and the remaining workspace.
+    // Also update pointer to be used on output.
+    // Memory is laid out as follows:
+    // workl(1:2*ncv) := generated tridiagonal matrix H
+    //       The subdiagonal is stored in workl(2:ncv).
+    //       The dead spot is workl(1) but upon exiting
+    //       dsaupd  stores the B-norm of the last residual
+    //       vector in workl(1). We use this !!!
+    // workl(2*ncv+1:2*ncv+ncv) := ritz values
+    //       The wanted values are in the first NCONV spots.
+    // workl(3*ncv+1:3*ncv+ncv) := computed Ritz estimates
+    //       The wanted values are in the first NCONV spots.
+    // NOTE: workl(1:4*ncv) is set by dsaupd  and is not
+    //       modified by dseupd .
+    // ----------------------------------------------------
+    // The following is used and set by dseupd .
+    // workl(4*ncv+1:4*ncv+ncv) := used as workspace during
+    //       computation of the eigenvectors of H. Stores
+    //       the diagonal of H. Upon EXIT contains the NCV
+    //       Ritz values of the original system. The first
+    //       NCONV spots have the wanted values. If MODE =
+    //       1 or 2 then will equal workl(2*ncv+1:3*ncv).
+    // workl(5*ncv+1:5*ncv+ncv) := used as workspace during
+    //       computation of the eigenvectors of H. Stores
+    //       the subdiagonal of H. Upon EXIT contains the
+    //       NCV corresponding Ritz estimates of the
+    //       original system. The first NCONV spots have the
+    //       wanted values. If MODE = 1,2 then will equal
+    //       workl(3*ncv+1:4*ncv).
+    // workl(6*ncv+1:6*ncv+ncv*ncv) := orthogonal Q that is
+    //       the eigenvector matrix for H as returned by
+    //       dsteqr . Not referenced if RVEC = .False.
+    //       Ordering follows that of workl(4*ncv+1:5*ncv)
+    // workl(6*ncv+ncv*ncv+1:6*ncv+ncv*ncv+2*ncv) :=
+    //       Workspace. Needed by dsteqr  and by dseupd .
+    // GRAND total of NCV*(NCV+8) locations.
+
+    ih = ipntr[4];
+    ritz = ipntr[5];
+    bounds = ipntr[6];
+    ldh = V->ncv;
+    ldq = V->ncv;
+    ihd = bounds + ldh;
+    ihb = ihd    + ldh;
+    iq  = ihb    + ldh;
+    iw  = iq     + ldh*V->ncv;
+    next = iw    + 2*V->ncv;
+    ipntr[3] = next;
+    ipntr[7] = ihd;
+    ipntr[8] = ihb;
+    ipntr[9] = iq;
+
+    // irz points to the Ritz values computed
+    //     by _seigt before exiting _saup2.
+    // ibd points to the Ritz estimates
+    //     computed by _seigt before exiting
+    //     _saup2.
+
+    irz = ipntr[10] + V->ncv;
+    ibd = irz + V->ncv;
+
+    // RNORM is B-norm of the RESID(1:N).
+    // BNORM2 is the 2 norm of B*RESID(1:N).
+    // Upon exit of dsaupd  WORKD(1:N) has
+    // B*RESID(1:N).
+
+    rnorm = workl[ih];
+    if (V->bmat)
+    {
+        bnorm2 = snrm2_(&V->n, workd, &int1);
+    } else {
+        bnorm2 = rnorm;
+    }
+
+    if (rvec) {
+        reord = 0;
+
+        // Use the temporary bounds array to store indices
+        // These will be used to mark the select array later
+
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[bounds + j] = j;
+            select[j] = 0;
+        }
+        // 10
+
+        // Select the wanted Ritz values.
+        // Sort the Ritz values so that the
+        // wanted ones appear at the tailing
+        // NEV positions of workl(irr) and
+        // workl(iri).  Move the corresponding
+        // error estimates in workl(bound)
+        // accordingly.
+
+        np = V->ncv - V->nev;
+        V->shift = 0;
+        ssgets(V, &V->nev, &np, &workl[irz], &workl[bounds], workl);
+
+        //  Record indices of the converged wanted Ritz values
+        //  Mark the select array for possible reordering
+
+        numcnv = 0;
+        for (j = 1; j <= V->ncv; j++)
+        {
+            temp1 = fmaxf(eps23, fabsf(workl[irz + V->ncv - j]));
+
+            jj = (int)workl[bounds + V->ncv - j];
+
+            if ((numcnv < V->nconv) && (workl[ibd + jj] <= V->tol*temp1))
+            {
+                select[jj] = 1;
+                numcnv += 1;
+                if (jj > V->nconv - 1) { reord = 1; }
+            }
+        }
+        // 11
+
+        //  Check the count (numcnv) of converged Ritz values with
+        //  the number (nconv) reported by saupd.  If these two
+        //  are different then there has probably been an error
+        //  caused by incorrect passing of the saupd data.
+
+        if (numcnv != V->nconv)
+        {
+            V->info = -17;
+            return;
+        }
+
+        // Call LAPACK routine _steqr to compute the eigenvalues and
+        // eigenvectors of the final symmetric tridiagonal matrix H.
+        // Initialize the eigenvector matrix Q to the identity.
+
+        tmp_int = V->ncv - 1;
+        scopy_(&tmp_int, &workl[ih+1], &int1, &workl[ihb], &int1);
+        scopy_(&V->ncv, &workl[ih+ldh], &int1, &workl[ihd], &int1);
+
+        ssteqr_("I", &V->ncv, &workl[ihd], &workl[ihb], &workl[iq], &ldq, &workl[iw], &ierr);
+
+        if (ierr != 0)
+        {
+            V->info = -8;
+            return;
+        }
+
+        if (reord)
+        {
+
+            // Reordered the eigenvalues and eigenvectors
+            // computed by _steqr so that the "converged"
+            // eigenvalues appear in the first NCONV
+            // positions of workl(ihd), and the associated
+            // eigenvectors appear in the first NCONV
+            // columns.
+
+            int leftptr = 0;
+            int rightptr = V->ncv - 1;
+
+            if (V->ncv > 1)
+            {
+                do
+                {
+                    if (select[leftptr])
+                    {
+
+                        // Search, from the left, for the first non-converged Ritz value.
+
+                        leftptr += 1;
+
+                    } else if (!(select[rightptr])) {
+
+                        // Search, from the right, the first converged Ritz value
+
+                        rightptr -= 1;
+
+                    } else {
+
+                        // Swap the Ritz value on the left that has not
+                        // converged with the Ritz value on the right
+                        // that has converged.  Swap the associated
+                        // eigenvector of the tridiagonal matrix H as
+                        // well.
+
+                        temp = workl[ihd + leftptr];
+                        workl[ihd + leftptr] = workl[ihd + rightptr];
+                        workl[ihd + rightptr] = temp;
+
+                        scopy_(&V->ncv, &workl[iq + V->ncv*leftptr], &int1, &workl[iw], &int1);
+                        scopy_(&V->ncv, &workl[iq + V->ncv*rightptr], &int1, &workl[iq + V->ncv*leftptr], &int1);
+                        scopy_(&V->ncv, &workl[iw], &int1, &workl[iq + V->ncv*rightptr], &int1);
+
+                        leftptr += 1;
+                        rightptr -= 1;
+                    }
+                } while (leftptr < rightptr);
+            }
+        }
+
+        // Load the converged Ritz values into D.
+
+        scopy_(&V->nconv, &workl[ihd], &int1, d, &int1);
+
+    } else {
+
+        // Ritz vectors not required. Load Ritz values into D.
+
+        scopy_(&V->nconv, &workl[ritz], &int1, d, &int1);
+        scopy_(&V->ncv, &workl[ritz], &int1, &workl[ihd], &int1);
+    }
+
+    // Transform the Ritz values and possibly vectors and corresponding
+    // Ritz estimates of OP to those of A*x=lambda*B*x. The Ritz values
+    // (and corresponding data) are returned in ascending order.
+
+    if (TYP == REGULAR)
+    {
+
+        // Ascending sort of wanted Ritz values, vectors and error
+        // bounds. Not necessary if only Ritz values are desired.
+
+        if (rvec) {
+            ssesrt(which_LA, rvec, V->nconv, d, V->ncv, &workl[iq], ldq);
+        } else {
+            scopy_(&V->ncv, &workl[bounds], &int1, &workl[ihb], &int1);
+        }
+
+    } else {
+
+        // *  Make a copy of all the Ritz values.
+        // *  Transform the Ritz values back to the original system.
+        //    For TYPE = 'SHIFTI' the transformation is
+        //             lambda = 1/theta + sigma
+        //    For TYPE = 'BUCKLE' the transformation is
+        //             lambda = sigma * theta / ( theta - 1 )
+        //    For TYPE = 'CAYLEY' the transformation is
+        //             lambda = sigma * (theta + 1) / (theta - 1 )
+        //    where the theta are the Ritz values returned by dsaupd.
+        // NOTES:
+        // *The Ritz vectors are not affected by the transformation.
+        //  They are only reordered.
+
+        scopy_(&V->ncv, &workl[ihd], &int1, &workl[iw], &int1);
+        if (TYP == SHIFTI)
+        {
+            for (int k = 0; k < V->ncv; k++)
+            {
+                workl[ihd + k] = 1.0f / workl[ihd + k] + sigma;
+            }
+        } else if (TYP == BUCKLE) {
+            for (int k = 0; k < V->ncv; k++) {
+                workl[ihd + k] = sigma * workl[ihd + k] / (workl[ihd + k] - 1.0f);
+            }
+        } else if (TYP == CAYLEY) {
+            for (int k = 0; k < V->ncv; k++) {
+                workl[ihd + k] = sigma * (workl[ihd + k] + 1.0f) / (workl[ihd + k] - 1.0f);
+            }
+        }
+
+        // *  Store the wanted NCONV lambda values into D.
+        // *  Sort the NCONV wanted lambda in WORKL(IHD:IHD+NCONV-1)
+        //    into ascending order and apply sort to the NCONV theta
+        //    values in the transformed system. We will need this to
+        //    compute Ritz estimates in the original system.
+        // *  Finally sort the lambda`s into ascending order and apply
+        //    to Ritz vectors if wanted. Else just sort lambda`s into
+        //    ascending order.
+        // NOTES:
+        // *workl(iw:iw+ncv-1) contain the theta ordered so that they
+        //  match the ordering of the lambda. We`ll use them again for
+        //  Ritz vector purification.
+
+        scopy_(&V->nconv, &workl[ihd], &int1, d, &int1);
+        ssortr(which_LA, 1, V->nconv, &workl[ihd], &workl[iw]);
+        if (rvec) {
+            ssesrt(which_LA, rvec, V->nconv, d, V->ncv, &workl[iq], ldq);
+        } else {
+            scopy_(&V->ncv, &workl[bounds], &int1, &workl[ihb], &int1);
+            temp = bnorm2 / rnorm;
+            sscal_(&V->ncv, &temp, &workl[ihb], &int1);
+            ssortr(which_LA, 1, V->nconv, d, &workl[ihb]);
+        }
+    }
+
+    // Compute the Ritz vectors. Transform the wanted
+    // eigenvectors of the symmetric tridiagonal H by
+    // the Lanczos basis matrix V.
+
+    if ((rvec) && (howmny == 0))
+    {
+
+        // Compute the QR factorization of the matrix representing
+        // the wanted invariant subspace located in the first NCONV
+        // columns of workl(iq, ldq).
+
+        sgeqr2_(&V->ncv, &V->nconv, &workl[iq], &ldq, &workl[iw + V->ncv], &workl[ihb], &ierr);
+
+        // * Postmultiply V by Q.
+        // * Copy the first NCONV columns of VQ into Z.
+        // The N by NCONV matrix Z is now a matrix representation
+        // of the approximate invariant subspace associated with
+        // the Ritz values in workl(ihd).
+
+        sorm2r_("R", "N", &V->n, &V->ncv, &V->nconv, &workl[iq], &ldq, &workl[iw + V->ncv], v, &ldv, &workd[V->n], &ierr);
+        slacpy_("A", &V->n, &V->nconv, v, &ldv, z, &ldz);
+
+        // In order to compute the Ritz estimates for the Ritz
+        // values in both systems, need the last row of the
+        // eigenvector matrix. Remember, it's in factored form.
+
+        for (int j = 0; j < V->ncv - 1; j++)
+        {
+            workl[ihb + j] = 0.0f;
+        }
+        workl[ihb + V->ncv - 1] = 1.0f;
+        sorm2r_("L", "T", &V->ncv, &int1, &V->nconv, &workl[iq], &ldq, &workl[iw + V->ncv], &workl[ihb], &V->ncv, &temp, &ierr);
+
+        //  Make a copy of the last row into
+        //  workl(iw+ncv:iw+2*ncv), as it is needed again in
+        //  the Ritz vector purification step below
+
+        for (int j = 0; j < V->nconv; j++)
+        {
+            workl[iw + V->ncv + j] = workl[ihb + j];
+        }
+        // 67
+
+    } else if ((rvec) && (howmny == 2)) {
+        // Not yet implemented
+        ;
+    }
+
+    if ((TYP == REGULAR) && (rvec))
+    {
+        for (j = 0; j < V->ncv; j++)
+        {
+            workl[ihb + j] = rnorm * fabsf(workl[ihb + j]);
+        }
+
+    } else if ((TYP != REGULAR) && (rvec)) {
+
+        // *  Determine Ritz estimates of the theta.
+        //    If RVEC = .true. then compute Ritz estimates
+        //               of the theta.
+        //    If RVEC = .false. then copy Ritz estimates
+        //              as computed by dsaupd .
+        // *  Determine Ritz estimates of the lambda.
+
+
+        sscal_(&V->ncv, &bnorm2, &workl[ihb], &int1);
+
+        for (k = 0; k < V->ncv; k++)
+        {
+            if (TYP == SHIFTI)
+            {
+                workl[ihb + k] = fabsf(workl[ihb + k]) / powf(workl[iw + k], 2.0f);
+            } else if (TYP == BUCKLE) {
+                workl[ihb + k] = sigma * fabsf(workl[ihb + k]) / powf(workl[iw + k] - 1.0f, 2.0f);
+            } else if (TYP == CAYLEY) {
+                workl[ihb + k] = fabsf(workl[ihb + k] / workl[iw + k] * (workl[iw + k] - 1.0f));
+            }
+        }
+        // 80, 90, 100
+    }
+
+    // Ritz vector purification step. Formally perform
+    // one of inverse subspace iteration. Only used
+    // for MODE = 3,4,5. See reference 7
+
+    if ((rvec) && ((TYP == SHIFTI) || (TYP == CAYLEY)))
+    {
+        for (k = 0; k < V->nconv; k++)
+        {
+            workl[iw + k] = workl[iw + V->ncv + k] / workl[iw + k];
+        }
+        // 110
+    } else if ((rvec) && (TYP == BUCKLE))
+    {
+        for (k = 0; k < V->nconv; k++)
+        {
+            workl[iw + k] = workl[iw + V->ncv + k] / (workl[iw + k] - 1.0f);
+        }
+        // 120
+    }
+
+    if ((rvec) && (TYP != REGULAR))
+    {
+        sger_(&V->n, &V->nconv, &dbl1, resid, &int1, &workl[iw], &int1, z, &ldz);
+    }
+
+    return;
+}
+
+
+void
+ARPACK_ssaupd(struct ARPACK_arnoldi_update_vars_s *V, float* resid, float* v, int ldv,
+       int* ipntr, float* workd, float* workl)
+{
+
+    int bounds = 0, ih = 0, iq = 0, iw = 0, j = 0, ldh = 0, ldq = 0, next = 0, ritz = 0;
+
+    if (V->ido == ido_FIRST)
+    {
+        if (V->n <= 0) {
+            V->info = -1;
+        } else if (V->nev <= 0) {
+            V->info = -2;
+        } else if ((V->ncv < V->nev + 1) || (V->ncv > V->n)) {
+            V->info = -3;
+        } else if (V->maxiter <= 0) {
+            V->info = -4;
+        } else if ((V->which != 0) &&
+            (V->which != 1) &&
+            (V->which != 6) &&
+            (V->which != 7) &&
+            (V->which != 8)) {
+            V->info = -5;
+        } else if ((V->bmat != 0) && (V->bmat != 1)) {
+            V->info = -6;
+        } else if ((V->mode < 1) || (V->mode > 5)) {
+            V->info = -10;
+        } else if ((V->mode == 1) && (V->bmat == 1)) {
+            V->info = -11;
+        } else if ((V->shift != 0) && (V->shift != 1)) {
+            V->info = -12;
+        } else if ((V->nev == 1) && (V->which == which_BE)) {
+            V->info = -13;
+        }
+
+        if (V->info < 0)
+        {
+            V->ido = ido_DONE;
+            return;
+        }
+
+        if (V->tol <= 0.0f) { V->tol = ulp; }
+
+        // NP is the number of additional steps to
+        // extend the length NEV Lanczos factorization.
+        V->np = V->ncv - V->nev;
+
+        // Zero out internal workspace
+        for (j = 0; j < (V->ncv)*((V->ncv) + 8); j++) { workl[j] = 0.0f; }
+    }
+
+    // Pointer into WORKL for address of H, RITZ, BOUNDS, Q
+    // etc... and the remaining workspace.
+    // Also update pointer to be used on output.
+    // Memory is laid out as follows:
+    // workl(1:2*ncv) := generated tridiagonal matrix
+    // workl(2*ncv+1:2*ncv+ncv) := ritz values
+    // workl(3*ncv+1:3*ncv+ncv) := computed error bounds
+    // workl(4*ncv+1:4*ncv+ncv*ncv) := rotation matrix Q
+    // workl(4*ncv+ncv*ncv+1:7*ncv+ncv*ncv) := workspace
+
+    ldh = V->ncv;
+    ldq = V->ncv;
+    ih = 0;
+    ritz = ih + 2*ldh;
+    bounds = ritz + V->ncv;
+    iq = bounds + V->ncv;
+    iw = iq + (V->ncv)*(V->ncv);
+    next = iw + 3*(V->ncv);
+
+    ipntr[3] = next;
+    ipntr[4] = ih;
+    ipntr[5] = ritz;
+    ipntr[6] = bounds;
+    ipntr[10] = iw;
+
+    // Carry out the Implicitly restarted Lanczos Iteration.
+    ssaup2(V, resid, v, ldv, &workl[ih], ldh, &workl[ritz], &workl[bounds],
+           &workl[iq], ldq, &workl[iw], ipntr, workd);
+
+     /*-------------------------------------------------*
+     | ido .ne. 99 implies use of reverse communication |
+     | to compute operations involving OP or shifts.    |
+     *-------------------------------------------------*/
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info < 0) { return; }
+    if (V->info == 2) { V->info = 3; }
+
+    return;
+}
+
+
+void
+ssaup2(struct ARPACK_arnoldi_update_vars_s *V, float* resid, float* v, int ldv,
+       float* h, int ldh, float* ritz, float* bounds,
+       float* q, int ldq, float* workl, int* ipntr, float* workd)
+{
+    int int1 = 1, j, tmp_int, nevd2, nevm2;
+    const float eps23 = powf(ulp, 2.0f / 3.0f);
+    float temp = 0.0f;
+    // Initialize to silence the compiler warning
+    enum ARPACK_which temp_which = which_LM;
+
+    if (V->ido == ido_FIRST)
+    {
+        // nev0 and np0 are integer variables hold the initial values of NEV & NP
+        V->aup2_nev0 = V->nev;
+        V->aup2_np0 = V->np;
+
+        // kplusp is the bound on the largest Lanczos factorization built.
+        // nconv is the current number of "converged" eigenvalues.
+        // iter is the counter on the current iteration step.
+        V->aup2_kplusp = V->nev + V->np;
+        V->nconv = 0;
+        V->aup2_iter = 0;
+
+        // Set flags for computing the first NEV steps of the Lanczos factorization.               |
+
+        V->aup2_getv0 = 1;
+        V->aup2_update = 0;
+        V->aup2_cnorm = 0;
+        V->aup2_ushift = 0;
+
+        if (V->info != 0)
+        {
+            // User provides the initial residual vector.
+            V->aup2_initv = 1;
+            V->info = 0;
+        } else {
+            V->aup2_initv = 0;
+        }
+    }
+
+    // Get a possibly random starting vector and
+    // force it into the range of the operator OP.
+
+    if (V->aup2_getv0)
+    {
+        V->getv0_itry = 1;
+        sgetv0(V, V->aup2_initv, V->n, 0, v, ldv, resid, &V->aup2_rnorm, ipntr, workd);
+        if (V->ido != ido_DONE) { return; }
+        if (V->aup2_rnorm == 0.0f)
+        {
+            V->info = -9;
+            V->ido = ido_DONE;
+            return;
+        }
+        V->aup2_getv0 = 0;
+        V->ido = ido_FIRST;
+    }
+
+    // Back from reverse communication :
+    // continue with update step
+
+    if (V->aup2_update) { goto LINE20; }
+
+    //  Back from computing user specified shifts
+
+    if (V->aup2_ushift) { goto LINE50; }
+
+    //  Back from computing residual norm
+    //  at the end of the current iteration
+
+    if (V->aup2_cnorm) { goto LINE100; }
+
+    //  Compute the first NEV steps of the Arnoldi factorization
+
+    ssaitr(V, 0, V->aup2_nev0, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+    //  ido .ne. 99 implies use of reverse communication
+    //  to compute operations involving OP and possibly B
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //
+    //            M A I N  ARNOLDI  I T E R A T I O N  L O O P
+    //            Each iteration implicitly restarts the Arnoldi
+    //            factorization in place.
+    //
+
+LINE1000:
+
+    V->aup2_iter += 1;
+
+    // Compute NP additional steps of the Lanczos factorization.
+
+    V->ido = ido_FIRST;
+
+LINE20:
+    V->aup2_update = 1;
+
+    ssaitr(V, V->nev, V->np, resid, &V->aup2_rnorm, v, ldv, h, ldh, ipntr, workd);
+
+     /*--------------------------------------------------*
+     | ido .ne. 99 implies use of reverse communication  |
+     | to compute operations involving OP and possibly B |
+     *--------------------------------------------------*/
+
+    if (V->ido != ido_DONE) { return; }
+
+    if (V->info > 0)
+    {
+        V->np = V->info;
+        V->iter = V->aup2_iter;
+        V->info = -9999;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->aup2_update = 0;
+
+    // Compute the eigenvalues and corresponding error bounds
+    // of the current symmetric tridiagonal matrix.
+    sseigt(V->aup2_rnorm, V->aup2_kplusp, h, ldh, ritz, bounds, workl, &V->info);
+
+    if (V->info != 0)
+    {
+        V->info = -8;
+        V->ido = ido_DONE;
+        return;
+    }
+
+    // Make a copy of eigenvalues and corresponding error
+    // bounds obtained from _seigt.
+
+    scopy_(&V->aup2_kplusp, ritz, &int1, &workl[V->aup2_kplusp], &int1);
+    scopy_(&V->aup2_kplusp, bounds, &int1, &workl[2*V->aup2_kplusp], &int1);
+
+    // Select the wanted Ritz values and their bounds
+    // to be used in the convergence test.
+    // The selection is based on the requested number of
+    // eigenvalues instead of the current NEV and NP to
+    // prevent possible misconvergence.
+    // * Wanted Ritz values := RITZ(NP+1:NEV+NP)
+    // * Shifts := RITZ(1:NP) := WORKL(1:NP)
+
+    V->nev = V->aup2_nev0;
+    V->np = V->aup2_np0;
+
+    ssgets(V, &V->nev, &V->np, ritz, bounds, workl);
+
+    // Convergence test
+
+    scopy_(&V->nev, &bounds[V->np], &int1, &workl[V->np], &int1);
+    ssconv(V->nev, &ritz[V->np], &workl[V->np], V->tol, &V->nconv);
+
+    // Count the number of unwanted Ritz values that have zero
+    // Ritz estimates. If any Ritz estimates are equal to zero
+    // then a leading block of H of order equal to at least
+    // the number of Ritz values with zero Ritz estimates has
+    // split off. None of these Ritz values may be removed by
+    // shifting. Decrease NP the number of shifts to apply. If
+    // no shifts may be applied, then prepare to exit
+
+    tmp_int = V->np;
+    for (j = 0; j < tmp_int; j++)
+    {
+        if (bounds[j] == 0.0f)
+        {
+            V->np -= 1;
+            V->nev += 1;
+        }
+    }
+    // 30
+
+    if ((V->nconv >= V->aup2_nev0) || (V->aup2_iter > V->maxiter) || (V->np == 0))
+    {
+        // Prepare to exit. Put the converged Ritz values
+        // and corresponding bounds in RITZ(1:NCONV) and
+        // BOUNDS(1:NCONV) respectively. Then sort. Be
+        // careful when NCONV > NP since we don't want to
+        // swap overlapping locations.
+
+        if (V->which == which_BE)
+        {
+
+            // Both ends of the spectrum are requested.
+            // Sort the eigenvalues into algebraically decreasing
+            // order first then swap low end of the spectrum next
+            // to high end in appropriate locations.
+            // NOTE: when np < floor(nev/2) be careful not to swap
+            // overlapping locations.
+
+            ssortr(which_SA, 1, V->aup2_kplusp, ritz, bounds);
+            nevd2 = V->aup2_nev0 / 2;
+            nevm2 = V->aup2_nev0 - nevd2;
+            if (V->nev > 1)
+            {
+                V->np = V->aup2_kplusp - V->aup2_nev0;
+
+                tmp_int = (nevd2 < V->np ? nevd2 : V->np);
+                int tmp_int2 = V->aup2_kplusp - tmp_int;
+
+                sswap_(&tmp_int, &ritz[nevm2], &int1, &ritz[tmp_int2], &int1);
+                sswap_(&tmp_int, &bounds[nevm2], &int1, &bounds[tmp_int2], &int1);
+            }
+
+        } else {
+
+            // LM, SM, LA, SA case.
+            // Sort the eigenvalues of H into the an order that
+            // is opposite to WHICH, and apply the resulting
+            // order to BOUNDS.  The eigenvalues are sorted so
+            // that the wanted part are always within the first
+            // NEV locations.
+
+            if (V->which == which_LM) { temp_which = which_SM; }
+            if (V->which == which_SM) { temp_which = which_LM; }
+            if (V->which == which_LA) { temp_which = which_SA; }
+            if (V->which == which_SA) { temp_which = which_LA; }
+
+            ssortr(temp_which, 1, V->aup2_kplusp, ritz, bounds);
+        }
+
+        // Scale the Ritz estimate of each Ritz value
+        // by 1 / max(eps23,magnitude of the Ritz value).
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmaxf(eps23, fabsf(ritz[j]));
+            bounds[j] = bounds[j] / temp;
+        }
+        // 35
+
+        // Sort the Ritz values according to the scaled Ritz
+        // estimates.  This will push all the converged ones
+        // towards the front of ritzr, ritzi, bounds
+        // (in the case when NCONV < NEV.)
+
+        ssortr(which_LA, 1, V->aup2_nev0, bounds, ritz);
+
+        // Scale the Ritz estimate back to its original
+        // value.
+
+        for (j = 0; j < V->aup2_nev0; j++)
+        {
+            temp = fmaxf(eps23, fabsf(ritz[j]));
+            bounds[j] = bounds[j] * temp;
+        }
+        // 40
+
+        // Sort the "converged" Ritz values again so that
+        // the "threshold" values and their associated Ritz
+        // estimates appear at the appropriate position in
+        // ritz and bound.
+
+        if (V->which == which_BE)
+        {
+
+            // Sort the "converged" Ritz values in increasing
+            // order.  The "threshold" values are in the
+            // middle.
+
+            ssortr(which_LA, 1, V->nconv, ritz, bounds);
+        } else {
+
+            // In LM, SM, LA, SA case, sort the "converged"
+            // Ritz values according to WHICH so that the
+            // "threshold" value appears at the front of
+            // ritz.
+
+            ssortr(V->which, 1, V->nconv, ritz, bounds);
+        }
+
+        //  Use h( 1,1 ) as storage to communicate
+        //  rnorm to _seupd if needed
+
+        h[0] = V->aup2_rnorm;
+
+        // Max iterations have been exceeded.
+
+        if ((V->aup2_iter > V->maxiter) && (V->nconv < V->nev))
+        {
+            V->info = 1;
+        }
+
+        // No shifts to apply.
+
+        if ((V->np ==  0) && (V->nconv < V->aup2_nev0))
+        {
+            V->info = 2;
+        }
+
+        V->np = V->nconv;
+        V->nev = V->nconv;
+        V->iter = V->aup2_iter;
+        V->ido = ido_DONE;
+        return;
+
+    } else if ((V->nconv < V->nev) && (V->shift == 1)) {
+
+        // Do not have all the requested eigenvalues yet.
+        // To prevent possible stagnation, adjust the number
+        // of Ritz values and the shifts.
+
+        int nevbef = V->nev;
+        V->nev += (V->nconv > (V->np / 2) ? (V->np / 2) : V->nconv);
+        if ((V->nev == 1) && (V->aup2_kplusp >= 6))
+        {
+            V->nev = V->aup2_kplusp / 2;
+        } else if ((V->nev == 1) && (V->aup2_kplusp > 2))
+        {
+            V->nev = 2;
+        }
+        V->np = V->aup2_kplusp - V->nev;
+
+        // If the size of NEV was just increased resort the eigenvalues.
+
+        if (nevbef < V->nev)
+        {
+            ssgets(V, &V->nev, &V->np, ritz, bounds, workl);
+        }
+    }
+
+    if (V->shift == 0)
+    {
+        // User specified shifts: reverse communication to
+        // compute the shifts. They are returned in the first
+        // NP locations of WORKL.
+
+        V->aup2_ushift = 1;
+        V->ido = ido_USER_SHIFT;
+        return;
+    }
+
+LINE50:
+
+    // Back from reverse communication;
+    // User specified shifts are returned
+    // in WORKL(1:*NP)
+
+    V->aup2_ushift = 0;
+
+    // Move the NP shifts to the first NP locations of RITZ to
+    // free up WORKL.  This is for the non-exact shift case;
+    // in the exact shift case, dsgets already handles this.
+
+    if (V->shift == 0) { scopy_(&V->np, workl, &int1, ritz, &int1); }
+
+     /*--------------------------------------------------------*
+     | Apply the NP0 implicit shifts by QR bulge chasing.      |
+     | Each shift is applied to the entire tridiagonal matrix. |
+     | The first 2*N locations of WORKD are used as workspace. |
+     | After dsapps is done, we have a Lanczos                 |
+     | factorization of length NEV.                            |
+     *--------------------------------------------------------*/
+
+    ssapps(V->n, &V->nev, V->np, ritz, v, ldv, h, ldh, resid, q, ldq, workd);
+
+    // Compute the B-norm of the updated residual.
+    // Keep B*RESID in WORKD(1:N) to be used in
+    // the first step of the next call to dsaitr.
+
+    V->aup2_cnorm = 1;
+
+    if (V->bmat)
+    {
+        scopy_(&V->n, resid, &int1, &workd[V->n], &int1);
+        ipntr[0] = V->n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*RESID
+
+        return;
+    } else {
+        scopy_(&V->n, resid, &int1, workd, &int1);
+    }
+
+LINE100:
+
+     /*---------------------------------*
+     | Back from reverse communication; |
+     | WORKD(1:N) := B*RESID            |
+     *---------------------------------*/
+
+    if (V->bmat)
+    {
+        V->aup2_rnorm = sqrtf(fabsf(sdot_(&V->n, resid, &int1, workd, &int1)));
+    } else {
+        V->aup2_rnorm = snrm2_(&V->n, resid, &int1);
+    }
+
+    V->aup2_cnorm = 0;
+
+    goto LINE1000;
+
+    //
+    //   E N D     O F     M A I N     I T E R A T I O N     L O O P
+    //
+
+}
+
+
+void
+ssconv(int n, float *ritz, float *bounds, float tol, int* nconv)
+{
+    const float eps23 = powf(ulp, 2.0f / 3.0f);
+    float temp = 0.0f;
+
+    *nconv = 0;
+    // Convergence test
+    for (int i = 0; i < n; i++)
+    {
+        temp = fmaxf(eps23, fabsf(ritz[i]));
+        if (fabsf(bounds[i]) <= tol * temp) { *nconv += 1; }
+    }
+
+    return;
+}
+
+
+void
+sseigt(float rnorm, int n, float* h, int ldh, float* eig, float* bounds,
+       float* workl, int* ierr)
+{
+    int int1 = 1, tmp_int;
+    scopy_(&n, &h[ldh], &int1, eig, &int1);
+    tmp_int = n - 1;
+    scopy_(&tmp_int, &h[1], &int1, workl, &int1);
+    sstqrb(n, eig, workl, bounds, &workl[n], ierr);
+    if (*ierr != 0) { return; }
+    for (int k = 0; k < n; k++) { bounds[k] = rnorm * fabsf(bounds[k]); }
+    return;
+}
+
+
+void
+ssaitr(struct ARPACK_arnoldi_update_vars_s *V, int k, int np, float* resid, float* rnorm,
+       float* v, int ldv, float* h, int ldh, int* ipntr, float* workd)
+{
+    int i, infol, ipj, irj, ivj, jj, n, tmp_int;
+    const float sq2o2 = sqrtf(2.0f) / 2.0f;
+
+    int int1 = 1;
+    float dbl1 = 1.0f, dbl0 = 0.0f, dblm1 = -1.0f, temp1;
+
+    n = V->n;  // n is constant, this is just for typing convenience
+    ipj = 0;
+    irj = ipj + n;
+    ivj = irj + n;
+
+    if (V->ido == ido_FIRST)
+    {
+
+        // Initial call to this routine
+
+        V->aitr_j = k;
+        V->info = 0;
+        V->aitr_step3 = 0;
+        V->aitr_step4 = 0;
+        V->aitr_orth1 = 0;
+        V->aitr_orth2 = 0;
+        V->aitr_restart = 0;
+    }
+
+    // When in reverse communication mode one of:
+    // STEP3, STEP4, ORTH1, ORTH2, RSTART
+    // will be .true. when ....
+    // STEP3: return from computing OP*v_{j}.
+    // STEP4: return from computing B-norm of OP*v_{j}
+    // ORTH1: return from computing B-norm of r_{j+1}
+    // ORTH2: return from computing B-norm of
+    //        correction to the residual vector.
+    // RSTART: return from OP computations needed by
+    //         dgetv0.
+
+    if (V->aitr_step3) { goto LINE50; }
+    if (V->aitr_step4) { goto LINE60; }
+    if (V->aitr_orth1) { goto LINE70; }
+    if (V->aitr_orth2) { goto LINE90; }
+    if (V->aitr_restart) { goto LINE30; }
+
+    //  Else this is the first step
+
+    //
+    //         A R N O L D I     I T E R A T I O N     L O O P
+    //
+    //  Note:  B*r_{j-1} is already in WORKD(1:N)=WORKD(IPJ:IPJ+N-1)
+
+LINE1000:
+
+        // Check for exact zero. Equivalent to determining whether
+        // a j-step Arnoldi factorization is present.
+
+    if (*rnorm > 0.0f) { goto LINE40; }
+
+        // Invariant subspace found, generate a new starting
+        // vector which is orthogonal to the current Arnoldi
+        // basis and continue the iteration.
+
+    V->getv0_itry = 1;
+
+LINE20:
+    V->aitr_restart = 1;
+    V->ido = ido_FIRST;
+
+LINE30:
+
+    // If in reverse communication mode and aitr_restart = 1, flow returns here.
+
+    sgetv0(V, 0, n, V->aitr_j, v, ldv, resid, rnorm, ipntr, workd);
+
+    if (V->ido != ido_DONE) { return; }
+    V->aitr_ierr = V->info;
+    if (V->aitr_ierr < 0)
+    {
+        V->getv0_itry += 1;
+        if (V->getv0_itry <= 3) { goto LINE20; }
+
+        //  Give up after several restart attempts.
+        //  Set INFO to the size of the invariant subspace
+        //  which spans OP and exit.
+
+        V->info = V->aitr_j;
+        V->ido = ido_DONE;
+        return;
+    }
+
+LINE40:
+
+    //  STEP 2:  v_{j} = r_{j-1}/rnorm and p_{j} = p_{j}/rnorm
+    //  Note that p_{j} = B*r_{j-1}. In order to avoid overflow
+    //  when reciprocating a small RNORM, test against lower
+    //  machine bound.
+
+    scopy_(&n, resid, &int1, &v[ldv*(V->aitr_j)], &int1);
+    if (*rnorm >= unfl)
+    {
+        temp1 = 1.0f / *rnorm;
+        sscal_(&n, &temp1, &v[ldv*(V->aitr_j)], &int1);
+        sscal_(&n, &temp1, &workd[ipj], &int1);
+    } else {
+        slascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &v[ldv*(V->aitr_j)], &n, &infol);
+        slascl_("G", &i, &i, rnorm, &dbl1, &n, &int1, &workd[ipj], &n, &infol);
+    }
+
+    //  STEP 3:  r_{j} = OP*v_{j}; Note that p_{j} = B*v_{j}
+    //  Note that this is not quite yet r_{j}. See STEP 4
+
+    V->aitr_step3 = 1;
+    scopy_(&n, &v[ldv*(V->aitr_j)], &int1, &workd[ivj], &int1);
+    ipntr[0] = ivj;
+    ipntr[1] = irj;
+    ipntr[2] = ipj;
+    V->ido = ido_OPX;
+
+    //  Exit in order to compute OP*v_{j}
+
+    return;
+
+LINE50:
+
+    //  Back from reverse communication;
+    //  WORKD(IRJ:IRJ+N-1) := OP*v_{j}
+
+    V->aitr_step3 = 0;
+
+    // Put another copy of OP*v_{j} into RESID.
+
+    scopy_(&n, &workd[irj], &int1, resid, &int1);
+
+    // STEP 4:  Finish extending the symmetric
+    //          Arnoldi to length j. If MODE = 2
+    //          then B*OP = B*inv(B)*A = A and
+    //          we don't need to compute B*OP.
+    // NOTE: If MODE = 2 WORKD(IVJ:IVJ+N-1) is
+    // assumed to have A*v_{j}.
+
+    if (V->mode == 2) { goto LINE65; }
+    if (V->bmat)
+    {
+        V->aitr_step4 = 1;
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*OP*v_{j}
+
+        return;
+    } else {
+        scopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE60:
+
+    // Back from reverse communication;
+    // WORKD(IPJ:IPJ+N-1) := B*OP*v_{j}.
+
+    V->aitr_step4 = 0;
+
+    //  The following is needed for STEP 5.
+    //  Compute the B-norm of OP*v_{j}.
+
+LINE65:
+
+    if (V->mode == 2)
+    {
+
+        // Note that the B-norm of OP*v_{j}
+        // is the inv(B)-norm of A*v_{j}.
+
+        V->aitr_wnorm = sdot_(&n, resid, &int1, &workd[ivj], &int1);
+        V->aitr_wnorm = sqrtf(fabsf(V->aitr_wnorm));
+    } else if (V->bmat) {
+        V->aitr_wnorm = sdot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_wnorm = sqrtf(fabsf(V->aitr_wnorm));
+    } else {
+        V->aitr_wnorm = snrm2_(&n, resid, &int1);
+    }
+
+    //  Compute the j-th residual corresponding
+    //  to the j step factorization.
+    //  Use Classical Gram Schmidt and compute:
+    //  w_{j} <-  V_{j}^T * B * OP * v_{j}
+    //  r_{j} <-  OP*v_{j} - V_{j} * w_{j}
+
+    //  Compute the j Fourier coefficients w_{j}
+    //  WORKD(IPJ:IPJ+N-1) contains B*OP*v_{j}.
+    tmp_int = V->aitr_j + 1;
+    if (V->mode != 2)
+    {
+        sgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &workd[irj], &int1);
+    } else {
+        sgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ivj], &int1, &dbl0, &workd[irj], &int1);
+    }
+
+    //  Orthogonalize r_{j} against V_{j}.
+    //  RESID contains OP*v_{j}. See STEP 3.
+
+    sgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &workd[irj], &int1, &dbl1, resid, &int1);
+
+    // Extend H to have j rows and columns.
+
+    h[V->aitr_j + ldh] = workd[irj + V->aitr_j];
+
+    if ((V->aitr_j == 0) || (V->aitr_restart))
+    {
+        h[V->aitr_j] = 0.0f;
+    } else {
+        h[V->aitr_j] = *rnorm;
+    }
+
+    V->aitr_orth1 = 1;
+    V->aitr_iter = 0;
+
+    if (V->bmat)
+    {
+        scopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}
+
+        return;
+    } else {
+        scopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE70:
+
+    //  Back from reverse communication if ORTH1 = .true.
+    //  WORKD(IPJ:IPJ+N-1) := B*r_{j}.
+
+    V->aitr_orth1 = 0;
+
+    //  Compute the B-norm of r_{j}.
+
+    if (V->bmat)
+    {
+        *rnorm = sdot_(&n, resid, &int1, &workd[ipj], &int1);
+        *rnorm = sqrtf(fabsf(*rnorm));
+    } else {
+        *rnorm = snrm2_(&n, resid, &int1);
+    }
+
+    // STEP 5: Re-orthogonalization / Iterative refinement phase
+    // Maximum NITER_ITREF tries.
+    //
+    //          s      = V_{j}^T * B * r_{j}
+    //          r_{j}  = r_{j} - V_{j}*s
+    //          alphaj = alphaj + s_{j}
+    //
+    // The stopping criteria used for iterative refinement is
+    // discussed in Parlett's book SEP, page 107 and in Gragg &
+    // Reichel ACM TOMS paper; Algorithm 686, Dec. 1990.
+    // Determine if we need to correct the residual. The goal is
+    // to enforce ||v(:,1:j)^T * r_{j}|| .le. eps * || r_{j} ||
+
+    if (*rnorm > sq2o2*V->aitr_wnorm) { goto LINE100; }
+
+    //  Enter the Iterative refinement phase. If further
+    //  refinement is necessary, loop back here. The loop
+    //  variable is ITER. Perform a step of Classical
+    //  Gram-Schmidt using all the Arnoldi vectors V_{j}
+
+LINE80:
+
+    //  Compute V_{j}^T * B * r_{j}.
+    //  WORKD(IRJ:IRJ+J-1) = v(:,1:J)'*WORKD(IPJ:IPJ+N-1).
+    tmp_int = V->aitr_j + 1;
+    sgemv_("T", &n, &tmp_int, &dbl1, v, &ldv, &workd[ipj], &int1, &dbl0, &workd[irj], &int1);
+
+    //  Compute the correction to the residual:
+    //  r_{j} = r_{j} - V_{j} * WORKD(IRJ:IRJ+J-1).
+    //  The correction to H is v(:,1:J)*H(1:J,1:J)
+    //  + v(:,1:J)*WORKD(IRJ:IRJ+J-1)*e'_j.
+
+    sgemv_("N", &n, &tmp_int, &dblm1, v, &ldv, &workd[irj], &int1, &dbl1, resid, &int1);
+
+    if ((V->aitr_j == 0) || (V->aitr_restart))
+    {
+        h[V->aitr_j] = 0.0f;
+    }
+    h[V->aitr_j + ldh] += workd[irj + V->aitr_j];
+
+    V->aitr_orth2 = 1;
+
+    if (V->bmat)
+    {
+        scopy_(&n, resid, &int1, &workd[irj], &int1);
+        ipntr[0] = irj;
+        ipntr[1] = ipj;
+        V->ido = ido_BX;
+
+        //  Exit in order to compute B*r_{j}.
+        //  r_{j} is the corrected residual.
+
+        return;
+    } else {
+        scopy_(&n, resid, &int1, &workd[ipj], &int1);
+    }
+
+LINE90:
+
+    //  Back from reverse communication if ORTH2 = .true.
+
+    //  Compute the B-norm of the corrected residual r_{j}.
+
+    if (V->bmat)
+    {
+        V->aitr_rnorm1 = sdot_(&n, resid, &int1, &workd[ipj], &int1);
+        V->aitr_rnorm1 = sqrtf(fabsf(V->aitr_rnorm1));
+    } else {
+        V->aitr_rnorm1 = snrm2_(&n, resid, &int1);
+    }
+
+    //  Determine if we need to perform another
+    //  step of re-orthogonalization.
+
+    if (V->aitr_rnorm1 > sq2o2*(*rnorm))
+    {
+
+        //  No need for further refinement.
+
+        *rnorm = V->aitr_rnorm1;
+
+    } else {
+
+        // Another step of iterative refinement step is required.
+
+        *rnorm = V->aitr_rnorm1;
+        V->aitr_iter += 1;
+        if (V->aitr_iter < 2) { goto LINE80; }
+
+        //  Otherwise RESID is numerically in the span of V
+
+        for (jj = 0; jj < n; jj++)
+        {
+            resid[jj] = 0.0f;
+        }
+        *rnorm = 0.0f;
+    }
+
+    // Branch here directly if iterative refinement
+    // wasn't necessary or after at most NITER_REF
+    // steps of iterative refinement.
+
+LINE100:
+
+    V->aitr_restart = 0;
+    V->aitr_orth2 = 0;
+
+    // Make sure the last off-diagonal element is non negative
+    // If not perform a similarity transformation on H(1:j,1:j)
+    // and scale v(:,j) by -1.
+
+    if (h[V->aitr_j] < 0.0f)
+    {
+        h[V->aitr_j] = -h[V->aitr_j];
+        if (V->aitr_j < k + np - 1)
+        {
+            sscal_(&n, &dblm1, &v[V->aitr_j + 1], &int1);
+        } else {
+            sscal_(&n, &dblm1, resid, &int1);
+        }
+    }
+
+    // STEP 6: Update  j = j+1;  Continue
+
+    V->aitr_j += 1;
+    if (V->aitr_j >= k + np)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    // Loop back to extend the factorization by another step.
+
+    goto LINE1000;
+
+}
+
+
+void
+ssapps(int n, int* kev, int np, float* shift, float* v, int ldv, float* h, int ldh,
+       float* resid, float* q, int ldq, float* workd)
+{
+    int i, iend, istart, jj, kplusp, tmp_int, int1 = 1;
+    float a1, a2, a3, a4, c, f, g, r, s, sigma, tst1;
+    float dbl0 = 0.0f, dbl1 = 1.0f, dblm1 = -1.0f;
+
+    iend = 0;
+    kplusp = *kev + np;
+
+    // Initialize Q to the identity to accumulate
+    // the rotations and reflections
+
+    slaset_("A", &kplusp, &kplusp, &dbl0, &dbl1, q, &ldq);
+
+    // Quick return if there are no shifts to apply
+
+    if (np == 0) { return; }
+
+    for (jj = 0; jj < np; jj++)
+    {
+        sigma = shift[jj];
+
+        // Check for splitting and deflation. Currently we consider
+        // an off-diagonal element h(i+1,1) negligible if
+        //         h(i+1,1) .le. epsmch*( |h(i,2)| + |h(i+1,2)| )
+        // for i=1:KEV+NP-1.
+        // If above condition tests true then we set h(i+1,1) = 0.
+        // Note that h(1:KEV+NP,1) are assumed to be non negative.
+
+        istart = 0;
+        while (istart < kplusp - 1)
+        {
+
+            for (iend = istart; iend < kplusp - 1; iend++)
+            {
+                tst1 = fabsf(h[iend + ldh]) + fabsf(h[iend + 1 + ldh]);
+                if (h[iend + 1] <= ulp * tst1)
+                {
+                    h[iend + 1] = 0.0f;
+                    break;
+                }
+            }
+
+            // Scalar block, skipping, correct the sign if necessary
+            if (istart == iend)
+            {
+                istart += 1;
+                if (h[iend] < 0.0f)
+                {
+                    h[iend] = -h[iend];
+                    sscal_(&kplusp, &dblm1, &q[ldq*(iend)], &int1);
+                }
+                continue;
+            }
+
+            // We have a valid block [istart, iend] inclusive
+            f = h[istart + ldh] - sigma;
+            g = h[istart + 1];
+
+            for (i = istart; i < iend; i++)
+            {
+                // Applying the plane rotations that create and chase the bulge X
+                //
+                // [c,  s] [ x x        ] [c, -s]       [ x x X      ]
+                // [-s, c] [ x x x      ] [s,  c]       [ x x x      ]
+                //         [   x x x    ]          =>   [ X x x x    ]
+                //         [     x x x  ]               [     x x x  ]
+                //         [         ...]               [         ...]
+                //
+                // dlartgp (instead of dlartg) is used to make sure that the
+                // off-diagonal elements stay non-negative, (cf. F77 code for
+                // manual handling).
+
+                //                                  a1          a2
+                // [c,  s] [ k m ] [c, -s]    [ c*k + s*m,  s*k + c*m] [c, -s]
+                // [-s, c] [ m n ] [s,  c]    [-s*k + c*m, -s*m + c*n] [s,  c]
+                //                                  a3          a4
+
+                slartgp_(&f, &g, &c, &s, &r);
+                if (i > istart)
+                {
+                    h[i] = r;
+                }
+                a1 = c*h[i + ldh]     + s*h[i + 1];
+                a2 = c*h[i + 1]       + s*h[i + 1 + ldh];
+                a4 = c*h[i + 1 + ldh] - s*h[i + 1];
+                a3 = c*h[i + 1]       - s*h[i + ldh];
+                h[i + ldh]     = c*a1 + s*a2;              // h[i  , i  ]
+                h[i + 1 + ldh] = c*a4 - s*a3;              // h[i+1, i+1]
+                h[i + 1]       = c*a3 + s*a4;              // h[i+1, i  ]
+
+                // Accumulate the rotation also in Q
+                tmp_int = (i + jj + 2 > kplusp ? kplusp : i + jj + 2);
+                srot_(&tmp_int, &q[ldq*i], &int1, &q[ldq*(i+1)], &int1, &c, &s);
+
+                if (i < iend - 1)
+                {
+                    // g is the bulge created by the rotation
+                    f = h[i + 1];
+                    g = s*h[i + 2];
+                    h[i + 2] = c*h[i + 2];
+                }
+            }
+            istart = iend + 1;
+            if (h[iend] < 0.0f)
+            {
+                h[iend] = -h[iend];
+                sscal_(&kplusp, &dblm1, &q[ldq*(iend)], &int1);
+            }
+        }
+    }
+    // 90
+
+    // All shifts have been applied. Check for
+    // more possible deflation that might occur
+    // after the last shift is applied.
+
+    for (i = 0; i < kplusp - 1; i++)
+    {
+        tst1 = fabsf(h[i + ldh]) + fabsf(h[i+1 + ldh]);
+        if (h[i+1] <= ulp*tst1)
+        {
+            h[i+1] = 0.0f;
+        }
+    }
+    // 100
+
+    // Compute the (kev+1)-st column of (V*Q) and
+    // temporarily store the result in WORKD(N+1:2*N).
+    // This is not necessary if h(kev+1,1) = 0.
+
+    if (h[*kev] > 0.0f)
+    {
+        sgemv_("N", &n, &kplusp, &dbl1, v, &ldv, &q[ldq*(*kev)], &int1, &dbl0, &workd[n], &int1);
+    }
+
+    // Compute column 1 to kev of (V*Q) in backward order
+    // taking advantage that Q is an upper triangular matrix
+    // with lower bandwidth np.
+    // Place results in v(:,kplusp-kev:kplusp) temporarily.
+
+    for (i = 0; i < *kev; i++)
+    {
+        tmp_int = kplusp - i;
+        sgemv_("N", &n, &tmp_int, &dbl1, v, &ldv, &q[ldq*(*kev-i-1)], &int1, &dbl0, workd, &int1);
+        scopy_(&n, workd, &int1, &v[ldv*(kplusp-i-1)], &int1);
+    }
+    // 130
+
+    // Move v(:,kplusp-kev+1:kplusp) into v(:,1:kev).
+
+    for (i = 0; i < *kev; i++)
+    {
+        scopy_(&n, &v[ldv*(np+i)], &int1, &v[ldv*i], &int1);
+    }
+    // 140
+
+    if (h[*kev] > 0.0f)
+    {
+        scopy_(&n, &workd[n], &int1, &v[ldv*(*kev)], &int1);
+    }
+
+    // Update the residual vector:
+    //    r <- sigmak*r + betak*v(:,kev+1)
+    // where
+    //    sigmak = (e_{kev+p}'*Q)*e_{kev}
+    //    betak = e_{kev+1}'*H*e_{kev}
+
+    sscal_(&n, &q[kplusp-1 + (*kev-1)*ldq], resid, &int1);
+    if (h[*kev] > 0.0f)
+    {
+        saxpy_(&n, &h[*kev], &v[ldv*(*kev)], &int1, resid, &int1);
+    }
+
+    return;
+}
+
+
+void
+ssgets(struct ARPACK_arnoldi_update_vars_s *V, int* kev, int* np, float* ritz,
+       float* bounds, float* shifts)
+{
+    int kevd2, tmp1, tmp2, int1 = 1;
+    if (V->which == which_BE)
+    {
+        // Both ends of the spectrum are requested.
+        // Sort the eigenvalues into algebraically increasing
+        // order first then swap high end of the spectrum next
+        // to low end in appropriate locations.
+        // NOTE: when np < floor(kev/2) be careful not to swap
+        // overlapping locations.
+
+        ssortr(which_LA, 1, *kev + *np, ritz, bounds);
+        kevd2 = *kev / 2;
+        if (*kev > 1)
+        {
+            tmp1 = (kevd2 > *np ? *np : kevd2);
+            tmp2 = (kevd2 > *np ? kevd2 : *np);
+            sswap_(&tmp1, ritz, &int1, &ritz[tmp2], &int1);
+            sswap_(&tmp1, bounds, &int1, &bounds[tmp2], &int1);
+        }
+    } else {
+
+        // LM, SM, LA, SA case.
+        // Sort the eigenvalues of H into the desired order
+        // and apply the resulting order to BOUNDS.
+        // The eigenvalues are sorted so that the wanted part
+        // are always in the last KEV locations.
+
+        ssortr(V->which, 1, *kev + *np, ritz, bounds);
+    }
+
+    if ((V->shift == 1) && (*np > 0))
+    {
+
+        // Sort the unwanted Ritz values used as shifts so that
+        // the ones with largest Ritz estimates are first.
+        // This will tend to minimize the effects of the
+        // forward instability of the iteration when the shifts
+        // are applied in subroutine dsapps.
+
+        ssortr(which_SM, 1, *np, bounds, ritz);
+        scopy_(np, ritz, &int1, shifts, &int1);
+    }
+}
+
+
+void
+sgetv0(struct ARPACK_arnoldi_update_vars_s *V, int initv, int n, int j,
+       float* v, int ldv, float* resid, float* rnorm, int* ipntr, float* workd)
+{
+    int jj, int1 = 1;
+    const float sq2o2 = sqrtf(2.0f) / 2.0f;
+    float dbl1 = 1.0f, dbl0 = 0.0f, dblm1 = -1.0f;
+
+    if (V->ido == ido_FIRST)
+    {
+        V->info = 0;
+        V->getv0_iter = 0;
+        V->getv0_first = 0;
+        V->getv0_orth = 0;
+
+        //  Possibly generate a random starting vector in RESID
+        //  Skip if this the return of ido_RANDOM.
+
+        if (!(initv))
+        {
+            // Request a random vector from the user into resid
+            V->ido = ido_RANDOM;
+            return;
+        } else {
+            V->ido = ido_RANDOM;
+        }
+    }
+
+    // Back from random vector generation
+    if (V->ido == ido_RANDOM)
+    {
+        //  Force the starting vector into the range of OP to handle
+        //  the generalized problem when B is possibly (singular).
+
+        if (V->getv0_itry == 1)
+        {
+            ipntr[0] = 0;
+            ipntr[1] = n;
+            scopy_(&n, resid, &int1, workd, &int1);
+            V->ido = ido_RANDOM_OPX;
+            return;
+        } else if ((V->getv0_itry > 1) && (V->bmat == 1))
+        {
+            scopy_(&n, resid, &int1, &workd[n], &int1);
+        }
+    }
+
+    //  Back from computing OP*(initial-vector)
+
+    if (V->getv0_first) { goto LINE20; }
+
+    //  Back from computing OP*(orthogonalized-vector)
+
+    if (V->getv0_orth) { goto LINE40; }
+
+    //  Starting vector is now in the range of OP; r = OP*r;
+    //  Compute B-norm of starting vector.
+
+    V->getv0_first = 1;
+    if (V->getv0_itry == 1)
+    {
+        scopy_(&n, &workd[n], &int1, resid, &int1);
+    }
+    if (V->bmat)
+    {
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        scopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE20:
+
+    V->getv0_first = 0;
+    if (V->bmat)
+    {
+        V->getv0_rnorm0 = sdot_(&n, resid, &int1, workd, &int1);
+        V->getv0_rnorm0 = sqrtf(fabsf(V->getv0_rnorm0));
+    } else {
+        V->getv0_rnorm0 = snrm2_(&n, resid, &int1);
+    }
+    *rnorm = V->getv0_rnorm0;
+
+    //  Exit if this is the very first Arnoldi step
+
+    if (j == 0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    //  Otherwise need to B-orthogonalize the starting vector against
+    //  the current Arnoldi basis using Gram-Schmidt with iter. ref.
+    //  This is the case where an invariant subspace is encountered
+    //  in the middle of the Arnoldi factorization.
+    //
+    //        s = V^{T}*B*r;   r = r - V*s;
+    //
+    //  Stopping criteria used for iter. ref. is discussed in
+    //  Parlett's book, page 107 and in Gragg & Reichel TOMS paper.
+
+    V->getv0_orth = 1;
+
+LINE30:
+
+    sgemv_("T", &n, &j, &dbl1, v, &ldv, workd, &int1, &dbl0, &workd[n], &int1);
+    sgemv_("N", &n, &j, &dblm1, v, &ldv, &workd[n], &int1, &dbl1, resid, &int1);
+
+    //  Compute the B-norm of the orthogonalized starting vector
+
+    if (V->bmat)
+    {
+        scopy_(&n, resid, &int1, &workd[n], &int1);
+        ipntr[0] = n;
+        ipntr[1] = 0;
+        V->ido = ido_BX;
+        return;
+    } else {
+        scopy_(&n, resid, &int1, workd, &int1);
+    }
+
+LINE40:
+    if (V->bmat)
+    {
+        *rnorm = sdot_(&n, resid, &int1, workd, &int1);
+        *rnorm = sqrtf(fabsf(*rnorm));
+    } else {
+        *rnorm = snrm2_(&n, resid, &int1);
+    }
+
+    //  Check for further orthogonalization.
+
+    if (*rnorm > sq2o2*V->getv0_rnorm0)
+    {
+        V->ido = ido_DONE;
+        return;
+    }
+
+    V->getv0_iter += 1;
+    if (V->getv0_iter < 5)
+    {
+
+        //  Perform iterative refinement step
+
+        V->getv0_rnorm0 = *rnorm;
+        goto LINE30;
+    } else {
+
+        //  Iterative refinement step "failed"
+
+        for (jj = 0; jj < n; jj++) { resid[jj] = 0.0f; }
+        *rnorm = 0.0f;
+        V->info = -1;
+    }
+
+    V->ido = ido_DONE;
+
+    return;
+}
+
+
+void
+ssortr(const enum ARPACK_which w, const int apply, const int n, float* x1, float* x2)
+{
+    int i, igap, j;
+    float temp;
+    ARPACK_compare_rfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortr_LM;
+            break;
+        case which_SM:
+            f = sortr_SM;
+            break;
+        case which_LA:
+            f = sortr_LA;
+            break;
+        case which_SA:
+            f = sortr_SA;
+            break;
+        default:
+            f = sortr_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(x1[j], x1[j+igap]))
+            {
+                if (j < 0) { break; }
+                temp = x1[j];
+                x1[j] = x1[j+igap];
+                x1[j+igap] = temp;
+
+                if (apply)
+                {
+                    temp = x2[j];
+                    x2[j] = x2[j+igap];
+                    x2[j+igap] = temp;
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+}
+
+
+void
+ssesrt(const enum ARPACK_which w, const int apply, const int n, float* x, int na, float* a, const int lda)
+{
+    int i, igap, j, int1 = 1;
+    float temp;
+    ARPACK_compare_rfunc *f;
+
+    switch (w)
+    {
+        case which_LM:
+            f = sortr_LM;
+            break;
+        case which_SM:
+            f = sortr_SM;
+            break;
+        case which_LA:
+            f = sortr_LA;
+            break;
+        case which_SA:
+            f = sortr_SA;
+            break;
+        default:
+            f = sortr_LM;
+            break;
+    }
+
+    igap = n / 2;
+
+    while (igap != 0)
+    {
+        j = 0;
+        for (i = igap; i < n; i++)
+        {
+            while (f(x[j], x[j + igap]))
+            {
+                if (j < 0) { break; }
+                temp = x[j];
+                x[j] = x[j+igap];
+                x[j+igap] = temp;
+
+                if (apply)
+                {
+                    sswap_(&na, &a[lda*j], &int1, &a[lda*(j+igap)], &int1);
+                }
+                j -= igap;
+            }
+            j = i - igap + 1;
+        }
+        igap = igap / 2;
+    }
+    // 10, 40, 70, 120
+}
+
+
+void
+sstqrb(int n, float* d, float* e, float* z, float* work, int* info)
+{
+    int int1 = 1, int0 = 0;
+    float eps2 = powf(ulp, 2.0f);
+    float safmin = unfl;
+    float safmax = (1.0f / safmin);
+    float ssfmax = sqrtf(safmax) / 3.0f;
+    float ssfmin = sqrtf(safmin) / eps2;
+
+    int nmaxit, jtot, i, ii, j, k, l1, m = 0, tmp_int = 0, l, lsv, lend, lendsv, iscale;
+    float anorm = 0.0f, rt1 = 0.0f, rt2 = 0.0f, c = 0.0f, s = 0.0f, g = 0.0f, r = 0.0f, p = 0.0f;
+    float b, f, tst;
+
+    *info = 0;
+    if (n == 0) { return; }
+    if (n == 1) { z[0] = 1.0f; return; }
+
+    // Set z as the last row of identity matrix
+    for (i = 0; i < n-1; i++) { z[i] = 0.0f; }
+    z[n-1] = 1.0f;
+
+    nmaxit = n*30;
+    jtot = 0;
+
+    //  Determine where the matrix splits and choose QL or QR iteration
+    //  for each block, according to whether top or bottom diagonal
+    //  element is smaller.
+
+    // Translation Note:
+    // All indices are 1-based, since the F77 code is very complicated.
+    // Instead array indices are decremented where necessary.
+
+    l1 = 1;
+
+    while (jtot < nmaxit)
+    {
+        if (l1 > n) { break; }
+
+        if (l1 > 1) { e[l1 - 2] = 0.0f; }
+        if (l1 <= n - 1)
+        {
+            for (m = l1; m <= n - 1; m++)
+            {
+                tst = fabsf(e[m - 1]);
+                if (tst == 0.0f) { break; }
+                if (tst <= (sqrtf(fabsf(d[m-1]))*sqrtf(fabsf(d[m])))*ulp)
+                {
+                    e[m-1] = 0.0f;
+                    break;
+                }
+            }
+            // 20
+        } else {
+            m = n;
+        }
+        // 30
+
+        // m will mark the splitting point, if any.
+        l = l1;
+        lsv = l;
+        lend = m;
+        lendsv = lend;
+        l1 = m + 1;
+
+        // Scalar block, skipping
+        if (lend == l) { continue; }
+
+        // Scale submatrix in rows and columns L to LEND
+        tmp_int = lend - l + 1;
+        anorm = slanst_("I", &tmp_int, &d[l-1], &e[l-1]);
+        iscale = 0;
+
+        if (anorm == 0.0f) { continue; }
+
+        if (anorm > ssfmax)
+        {
+            iscale = 1;
+            slascl_("G", &int0, &int0, &anorm, &ssfmax, &tmp_int, &int1, &d[l-1], &n, info);
+            tmp_int -= 1;
+            slascl_("G", &int0, &int0, &anorm, &ssfmax, &tmp_int, &int1, &e[l-1], &n, info);
+        } else if (anorm < ssfmin) {
+            iscale = 2;
+            slascl_("G", &int0, &int0, &anorm, &ssfmin, &tmp_int, &int1, &d[l-1], &n, info);
+            tmp_int -= 1;
+            slascl_("G", &int0, &int0, &anorm, &ssfmin, &tmp_int, &int1, &e[l-1], &n, info);
+        }
+        // Choose between QL and QR iteration
+
+        if (fabsf(d[lend-1]) < fabsf(d[l-1]))
+        {
+            lend = lsv;
+            l = lendsv;
+        }
+        if (lend > l)
+        {
+            // QL Iteration
+            while (1)
+            {
+                // Look for small subdiagonal element.
+                // 40
+                if (l != lend)
+                {
+                    for (m = l; m < lend; m++)
+                    {
+                        tst = fabsf(e[m-1]);
+                        tst = tst*tst;
+                        if (tst <= (eps2*fabsf(d[m - 1]))*fabsf(d[m]) + safmin) { break; }
+                        if (m == lend - 1) { m = lend; break; }  // No break condition
+                    }
+                    // 50, 60
+                } else {
+                    m = lend;
+                }
+                if (m < lend) { e[m - 1] = 0.0f; }
+
+                p = d[l - 1];
+                if (m == l)
+                {
+                        // 80
+                        // Eigenvalue found
+                        d[l - 1] = p;
+                        l += 1;
+                        if (l <= lend) { continue; }  // Top of QL iteration
+                        break;  // go to 140 undo scaling
+                }
+                // If remaining matrix is 2x2, use dlaev2 to compute its eigensystem
+                if (m == l + 1)
+                {
+                    slaev2_(&d[l - 1], &e[l - 1], &d[l], &rt1, &rt2, &c, &s);
+                    work[l - 1] = c;
+                    work[n - 1 + l - 1] = s;
+                    tst    = z[l];
+                    z[l]   = c*tst - s*z[l-1];
+                    z[l-1] = s*tst + c*z[l-1];
+                    d[l-1] = rt1;
+                    d[l]   = rt2;
+                    e[l-1] = 0.0f;
+                    l += 2;
+                    if (l <= lend) { continue; }  // go to 40
+                    break;  // go to 140
+                }
+
+                if (jtot == nmaxit) { break; } // go to 140
+                jtot += 1;
+
+                // Form shift
+                g = (d[l]- p) / (2.0f * e[l-1]);
+                r = hypotf(g, 1.0f);
+                g = d[m-1] - p + (e[l-1] / (g + copysignf(r, g)));
+
+                s = 1.0f;
+                c = 1.0f;
+                p = 0.0f;
+
+                // Inner loop
+                for (i = m - 1; i >= l; i--)
+                {
+                    f = s * e[i-1];
+                    b = c * e[i-1];
+                    slartg_(&g, &f, &c, &s, &r);
+                    if (i != m - 1) { e[i] = r; }
+                    g = d[i] - p;
+                    r = (d[i-1] - g)*s + 2.0f*c*b;
+                    p = s*r;
+                    d[i] = g + p;
+                    g = c*r - b;
+                    work[i-1] = c;
+                    work[n-1+i-1] = -s;
+                }
+                // 70
+                tmp_int = m - l + 1;
+                slasr_("R", "V", "B", &int1, &tmp_int, &work[l-1], &work[n-1+l-1], &z[l-1], &int1);
+
+                d[l-1] = d[l-1] - p;
+                e[l-1] = g;
+
+            }
+        } else {
+            // QR Iteration
+
+            // Look for small subdiagonal element.
+            while (1)
+            {
+                if (l != lend)
+                {
+                    for (m = l; m > lend; m--)
+                    {
+                        tst = fabsf(e[m-2]);
+                        tst = tst*tst;
+                        if (tst <= (eps2*fabsf(d[m-1]))*fabsf(d[m-2]) + safmin) { break; }
+                        if (m == lend+1) { m = lend; break; }  // No break
+                    }
+                } else {
+                    m = lend;
+                }
+                // 100, 110
+                if (m > lend) { e[m-2] = 0.0f; }
+                p = d[l-1];
+                if (m == l)
+                {
+                    // 130
+                    // Eigenvalue found
+                    d[l-1] = p;
+                    l -= 1;
+                    if (l >= lend) { continue; } // Top of QR iteration
+                    break; // go to 140 undo scaling
+                }
+                // If remaining matrix is 2x2, use dlaev2 to compute its eigensystem
+                if (m == l - 1)
+                {
+                    slaev2_(&d[l-2], &e[l-2], &d[l-1], &rt1, &rt2, &c, &s);
+                    tst    = z[l-1];
+                    z[l-1] = c*tst - s*z[l-2];
+                    z[l-2] = s*tst + c*z[l-2];
+                    d[l-2] = rt1;
+                    d[l-1] = rt2;
+                    e[l-2] = 0.0f;
+                    l -= 2;
+
+                    if (l >= lend) { continue; } // Top of QR iteration
+                    break; // go to 140 undo scaling
+                }
+
+                if (jtot == nmaxit) { break; }  // go to 140
+                jtot += 1;
+
+                // Form the shift
+                g = (d[l-2] - p) / (2.0*e[l-2]);
+                r = hypotf(g, 1.0f);
+                g = d[m-1] - p + (e[l-2] / (g + copysignf(r, g)));
+
+                s = 1.0f;
+                c = 1.0f;
+                p = 0.0f;
+
+                // Inner loop
+                for (i = m; i < l; i++)
+                {
+                    f = s * e[i-1];
+                    b = c * e[i-1];
+                    slartg_(&g, &f, &c, &s, &r);
+                    if (i != m) { e[i-2] = r; }
+                    g = d[i-1] - p;
+                    r = (d[i] - g)*s + 2.0f*c*b;
+                    p = s*r;
+                    d[i-1] = g + p;
+                    g = c*r - b;
+
+                    // Save rotations
+                    work[i-1] = c;
+                    work[n-1+i-1] = s;
+                }
+                // 120
+                // Apply saved rotations.
+                tmp_int = l - m + 1;
+                slasr_("R", "V", "F", &int1, &tmp_int, &work[m-1], &work[n-1+m-1], &z[m-1], &int1);
+
+                d[l-1] = d[l-1] - p;
+                e[l - 2] = g;
+
+            }
+        }
+        // 140 Still in the outer while loop; it breaks at the top
+
+        // Undo scaling if necessary
+        tmp_int = lendsv-lsv+1;
+        if (iscale == 1)
+        {
+
+            slascl_("G", &int0, &int0, &ssfmax, &anorm, &tmp_int, &int1, &d[lsv-1], &n, info);
+            tmp_int -= 1;
+            slascl_("G", &int0, &int0, &ssfmax, &anorm, &tmp_int, &int1, &e[lsv-1], &n, info);
+
+        } else if (iscale == 2) {
+
+            slascl_("G", &int0, &int0, &ssfmin, &anorm, &tmp_int, &int1, &d[lsv-1], &n, info);
+            tmp_int -= 1;
+            slascl_("G", &int0, &int0, &ssfmin, &anorm, &tmp_int, &int1, &e[lsv-1], &n, info);
+
+        }
+
+        // Check for no convergence to an eigenvalue after a total of n*maxit iterations
+        if (jtot >= nmaxit)
+        {
+            for (i = 0; i < n-1; i++) { if (e[i] != 0.0f) { *info += 1; } }
+            return;  // 150
+        }
+    }
+    // Out of the while loop
+
+    //  Order eigenvalues and eigenvectors.
+    //  Use selection sort to minimize swaps of eigenvectors.
+    for (ii = 1; ii < n; ii++)
+    {
+        i = ii - 1;
+        k = i;
+        p = d[i];
+
+        for (j = ii; j < n; j++)
+        {
+            if (d[j] < p)
+            {
+                k = j;
+                p = d[j];
+            }
+        }
+        // 170
+        if (k != i)
+        {
+            d[k] = d[i];
+            d[i] = p;
+            p = z[k];
+            z[k] = z[i];
+            z[i] = p;
+        }
+    }
+    // 180
+
+    return;
+}
+
+
+int sortr_LM(const float x1, const float x2) { return (fabsf(x1) > fabsf(x2)); }
+int sortr_SM(const float x1, const float x2) { return (fabsf(x1) < fabsf(x2)); }
+int sortr_LA(const float x1, const float x2) { return (x1 > x2); }
+int sortr_SA(const float x1, const float x2) { return (x1 < x2); }
diff --git a/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.h b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.h
new file mode 100644
index 0000000000..f7d9c8967c
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/ARPACK/_arpack_s_single.h
@@ -0,0 +1,31 @@
+#ifndef _ARPACK_S_SINGLE_H
+#define _ARPACK_S_SINGLE_H
+
+#include "_arpack.h"
+
+// BLAS Routines used
+void saxpy_(int* n, float* alpha, float* x, int* incx, float* y, int* incy);
+void scopy_(int* n, float* x, int* incx, float* y, int* incy);
+float sdot_(int* n, float* x, int* incx, float* y, int* incy);
+void sgemv_(char* trans, int* m, int* n, float* alpha, float* a, int* lda, float* x, int* incx, float* beta, float* y, int* incy);
+void sger_(int* m, int* n, float* alpha, float* x, int* incx, float* y, int* incy, float* a, int* lda);
+float snrm2_(int* n, float* x, int* incx);
+void srot_(int* n, float* sx, int* incx, float* sy, int* incy, float* c, float* s);
+void sscal_(int* n, float* alpha, float* x, int* incx);
+void sswap_(int* n, float* x, int* incx, float* y, int* incy);
+void strmm_(char* side, char* uplo, char* transa, char* diag, int* m, int* n, float* alpha, float* a, int* lda, float* b, int* ldb);
+
+// LAPACK Routines used
+void sgeqr2_(int* m, int* n, float* a, int* lda, float* tau, float* work, int* info);
+void slacpy_(char* uplo, int* m, int* n, float* a, int* lda, float* b, int* ldb);
+void slaev2_(float* a, float* b, float* c, float* rt1, float* rt2, float* cs1, float* sn1);
+float slanst_(char* norm, int* n, float* d, float* e);
+void slartg_(float* f, float* g, float* c, float* s, float* r);
+void slartgp_(float* f, float* g, float* c, float* s, float* r);
+void slascl_(char* mtype, int* kl, int* ku, float* cfrom, float* cto, int* m, int* n, float* a, int* lda, int* info);
+void slasr_(char* side, char* pivot, char* direct, int* m, int* n, float* c, float* s, float* a, int* lda);
+void slaset_(char* uplo, int* m, int* n, float* alpha, float* beta, float* a, int* lda);
+void sorm2r_(char* side, char* trans, int* m, int* n, int* k, float* a, int* lda, float* tau, float* c, int* ldc, float* work, int* info);
+void ssteqr_(char* compz, int* n, float* d, float* e, float* z, int* ldz, float* work, int* info);
+
+#endif
diff --git a/scipy/sparse/linalg/_eigen/arpack/README b/scipy/sparse/linalg/_eigen/arpack/README
deleted file mode 100644
index 6a729f4752..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/README
+++ /dev/null
@@ -1,91 +0,0 @@
-This is the ARPACK package from
-http://www.caam.rice.edu/software/ARPACK/
-
-Specifically the files are from
-http://www.caam.rice.edu/software/ARPACK/SRC/arpack96.tar.gz
-with the patch
-http://www.caam.rice.edu/software/ARPACK/SRC/patch.tar.gz
-
-The ARPACK README is at
-http://www.caam.rice.edu/software/ARPACK/SRC/readme.arpack
-
----
-
-ARPACK is a collection of Fortran77 subroutines designed to solve large 
-scale eigenvalue problems. 
-
-The package is designed to compute a few eigenvalues and corresponding 
-eigenvectors of a general n by n matrix A. It is most appropriate for large 
-sparse or structured matrices A where structured means that a matrix-vector
-product w <- Av requires order n rather than the usual order n**2 floating 
-point operations. This software is based upon an algorithmic variant of the
-Arnoldi process called the Implicitly Restarted Arnoldi Method (IRAM). When
-the matrix A is symmetric it reduces to a variant of the Lanczos process 
-called the Implicitly Restarted Lanczos Method (IRLM). These variants may be
-viewed as a synthesis of the Arnoldi/Lanczos process with the Implicitly 
-Shifted QR technique that is suitable for large scale problems. For many 
-standard problems, a matrix factorization is not required. Only the action
-of the matrix on a vector is needed.  ARPACK software is capable of solving
-large scale symmetric, nonsymmetric, and generalized eigenproblems from 
-significant application areas. The software is designed to compute a few (k)
-eigenvalues with user specified features such as those of largest real part 
-or largest magnitude.  Storage requirements are on the order of n*k locations.
-No auxiliary storage is required. A set of Schur basis vectors for the desired
-k-dimensional eigen-space is computed which is numerically orthogonal to working
-precision. Numerically accurate eigenvectors are available on request. 
-
-Important Features: 
-
-    o  Reverse Communication Interface. 
-    o  Single and Double Precision Real Arithmetic Versions for Symmetric,
-       Non-symmetric, Standard or Generalized Problems.
-    o  Single and Double Precision Complex Arithmetic Versions for Standard
-       or Generalized Problems. 
-    o  Routines for Banded Matrices - Standard or Generalized Problems. 
-    o  Routines for The Singular Value Decomposition. 
-    o  Example driver routines that may be used as templates to implement
-       numerous Shift-Invert strategies for all problem types, data types
-       and precision. 
-
----
-
-The ARPACK license is the BSD 3-clause license ("New BSD License")
-http://www.caam.rice.edu/software/ARPACK/RiceBSD.txt
-
----
-
-BSD Software License
-
-Pertains to ARPACK and P_ARPACK
-
-Copyright (c) 1996-2008 Rice University.
-Developed by D.C. Sorensen, R.B. Lehoucq, C. Yang, and K. Maschhoff.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-- Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright
-  notice, this list of conditions and the following disclaimer listed
-  in this license in the documentation and/or other materials
-  provided with the distribution.
-
-- Neither the name of the copyright holders nor the names of its
-  contributors may be used to endorse or promote products derived from
-  this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/scipy/sparse/linalg/_eigen/arpack/_arpackmodule.c b/scipy/sparse/linalg/_eigen/arpack/_arpackmodule.c
new file mode 100644
index 0000000000..10b448cbb2
--- /dev/null
+++ b/scipy/sparse/linalg/_eigen/arpack/_arpackmodule.c
@@ -0,0 +1,1078 @@
+/*
+ * Python bindings for SciPy usage
+ */
+
+#define PY_SSIZE_T_CLEAN
+#include "Python.h"
+#include "numpy/arrayobject.h"
+#include "ARPACK/_arpack.h"
+
+#if defined(_MSC_VER)
+    #define ARPACK_cplx(real, imag) ((_Dcomplex){real, imag})
+    #define ARPACK_cplxf(real, imag) ((_Fcomplex){real, imag})
+#else
+    #define ARPACK_cplx(real, imag) ((real) + (imag)*I)
+    #define ARPACK_cplxf(real, imag) ((real) + (imag)*I)
+#endif
+
+#define PYERR(errobj,message) {PyErr_SetString(errobj,message); return NULL;}
+static PyObject* arpack_error;
+
+// The following macros are used to define the field names in the ARPACK struct.
+#define STRUCT_INEXACT_FIELD_NAMES X(tol) X(getv0_rnorm0) X(aitr_betaj) X(aitr_rnorm1) X(aitr_wnorm) X(aup2_rnorm)
+#define STRUCT_INT_FIELD_NAMES X(ido) X(which) X(bmat) X(info) X(iter) X(maxiter) X(mode) \
+                               X(n) X(nconv) X(ncv) X(nev) X(np) \
+                               X(shift) X(getv0_first) X(getv0_iter) X(getv0_itry) X(getv0_orth) \
+                               X(aitr_iter) X(aitr_j) X(aitr_orth1) X(aitr_orth2) X(aitr_restart) \
+                               X(aitr_step3) X(aitr_step4) X(aitr_ierr) X(aup2_initv) X(aup2_iter) \
+                               X(aup2_getv0) X(aup2_cnorm) X(aup2_kplusp) X(aup2_nev0) X(aup2_np0) \
+                               X(aup2_numcnv) X(aup2_update) X(aup2_ushift)
+#define STRUCT_FIELD_NAMES STRUCT_INT_FIELD_NAMES STRUCT_INEXACT_FIELD_NAMES
+
+
+static PyObject*
+snaupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_v=NULL;
+    PyArrayObject* ap_ipntr=NULL;
+    PyArrayObject* ap_workd=NULL;
+    PyArrayObject* ap_workl=NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = PyArray_DATA(ap_ipntr);
+    float* resid = PyArray_DATA(ap_resid);
+    float* v = PyArray_DATA(ap_v);
+    float* workd = PyArray_DATA(ap_workd);
+    float* workl = PyArray_DATA(ap_workl);
+
+    // Map the input dict to the ARPACK structure
+
+    // Parse the dictionary, if the field is not found, raise an error.
+    // Do it separately for floats and ints.
+
+    // Declare and Initialize the ARPACK struct that will be populated from dict with zeros
+    struct ARPACK_arnoldi_update_vars_s Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (float)PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    // Call ARPACK function
+    ARPACK_snaupd(&Vars, resid, v, Vars.n, ipntr, workd, workl);
+
+    // Unpack the struct back to the dictionary
+    #define X(name) do { \
+            PyObject* tmp_##name = PyFloat_FromDouble((double)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+            Py_XDECREF(tmp_##name); \
+            PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) do { \
+            PyObject* tmp_##name = PyLong_FromLong((long)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+                Py_XDECREF(tmp_##name); \
+                PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+dnaupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_v=NULL;
+    PyArrayObject* ap_ipntr=NULL;
+    PyArrayObject* ap_workd=NULL;
+    PyArrayObject* ap_workl=NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    double* resid = (double*)PyArray_DATA(ap_resid);
+    double* v = (double*)PyArray_DATA(ap_v);
+    double* workd = (double*)PyArray_DATA(ap_workd);
+    double* workl = (double*)PyArray_DATA(ap_workl);
+
+    // Parse the dictionary, if the field is not found, raise an error.
+    // Do it separately for floats and ints.
+
+    // Declare and Initialize the ARPACK struct that will be populated from dict with zeros
+    struct ARPACK_arnoldi_update_vars_d Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+    PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+    if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+    Vars.name = PyFloat_AsDouble(name##_obj);
+    STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+    PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+    if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+    Vars.name = (int)PyLong_AsLong(name##_obj);
+    STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    // Call ARPACK function
+    ARPACK_dnaupd(&Vars, resid, v, Vars.n, ipntr, workd, workl);
+
+    // Unpack the struct back to the dictionary
+    #define X(name) do { \
+            PyObject* tmp_##name = PyFloat_FromDouble(Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+            Py_XDECREF(tmp_##name); \
+            PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) do { \
+            PyObject* tmp_##name = PyLong_FromLong((long)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+                Py_XDECREF(tmp_##name); \
+                PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+cnaupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_v=NULL;
+    PyArrayObject* ap_ipntr=NULL;
+    PyArrayObject* ap_workd=NULL;
+    PyArrayObject* ap_workl=NULL;
+    PyArrayObject* ap_rwork=NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl,   // O!
+        &PyArray_Type, (PyObject **)&ap_rwork    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    ARPACK_CPLXF_TYPE* resid = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_resid);
+    ARPACK_CPLXF_TYPE* v = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_v);
+    ARPACK_CPLXF_TYPE* workd = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_workd);
+    ARPACK_CPLXF_TYPE* workl = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_workl);
+    float* rwork = (float*)PyArray_DATA(ap_rwork);
+
+    // Map the input dict to the ARPACK structure
+
+    // Parse the dictionary, if the field is not found, raise an error.
+    // Do it separately for floats and ints.
+
+    // Declare and Initialize the ARPACK struct that will be populated from dict with zeros
+    struct ARPACK_arnoldi_update_vars_s Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (float)PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    // Call ARPACK function
+    ARPACK_cnaupd(&Vars, resid, v, Vars.n, ipntr, workd, workl, rwork);
+
+    // Unpack the struct back to the dictionary
+    #define X(name) do { \
+            PyObject* tmp_##name = PyFloat_FromDouble((double)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+            Py_XDECREF(tmp_##name); \
+            PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) do { \
+            PyObject* tmp_##name = PyLong_FromLong((long)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+                Py_XDECREF(tmp_##name); \
+                PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+znaupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_v=NULL;
+    PyArrayObject* ap_ipntr=NULL;
+    PyArrayObject* ap_workd=NULL;
+    PyArrayObject* ap_workl=NULL;
+    PyArrayObject* ap_rwork=NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl,   // O!
+        &PyArray_Type, (PyObject **)&ap_rwork    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    ARPACK_CPLX_TYPE* resid = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_resid);
+    ARPACK_CPLX_TYPE* v = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_v);
+    ARPACK_CPLX_TYPE* workd = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_workd);
+    ARPACK_CPLX_TYPE* workl = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_workl);
+    double* rwork = (double*)PyArray_DATA(ap_rwork);
+
+    // Parse the dictionary, if the field is not found, raise an error.
+    // Do it separately for floats and ints.
+
+    // Declare and Initialize the ARPACK struct that will be populated from dict with zeros
+    struct ARPACK_arnoldi_update_vars_d Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    // Call ARPACK function
+    ARPACK_znaupd(&Vars, resid, v, Vars.n, ipntr, workd, workl, rwork);
+
+    // Unpack the struct back to the dictionary
+    #define X(name) do { \
+            PyObject* tmp_##name = PyFloat_FromDouble(Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+            Py_XDECREF(tmp_##name); \
+            PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) do { \
+            PyObject* tmp_##name = PyLong_FromLong((long)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+                Py_XDECREF(tmp_##name); \
+                PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+sneupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+
+    PyObject* input_dict = NULL;
+    int want_ev = 0, howmny = 0, ldv = 0, ldz = 0;
+    PyArrayObject* ap_select = NULL;
+    float sigmar = 0.0;
+    float sigmai = 0.0;
+    PyArrayObject* ap_dr = NULL;
+    PyArrayObject* ap_di = NULL;
+    PyArrayObject* ap_v = NULL;
+    PyArrayObject* ap_z = NULL;
+    PyArrayObject* ap_workev = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_ipntr = NULL;
+    PyArrayObject* ap_workd = NULL;
+    PyArrayObject* ap_workl = NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!iiO!O!O!O!ffO!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &want_ev,                                // i
+        &howmny,                                 // i
+        &PyArray_Type, (PyObject **)&ap_select,  // O!
+        &PyArray_Type, (PyObject **)&ap_dr,      // O!
+        &PyArray_Type, (PyObject **)&ap_di,      // O!
+        &PyArray_Type, (PyObject **)&ap_z,       // O!
+        &sigmar,                                 // f
+        &sigmai,                                 // f
+        &PyArray_Type, (PyObject **)&ap_workev,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    int* select = (int*)PyArray_DATA(ap_select);
+    float* dr = (float*)PyArray_DATA(ap_dr);
+    float* di = (float*)PyArray_DATA(ap_di);
+    float* workev = (float*)PyArray_DATA(ap_workev);
+    float* z = (float*)PyArray_DATA(ap_z);
+    float* resid = (float*)PyArray_DATA(ap_resid);
+    float* v = (float*)PyArray_DATA(ap_v);
+    float* workd = (float*)PyArray_DATA(ap_workd);
+    float* workl = (float*)PyArray_DATA(ap_workl);
+    ldv = (int)PyArray_DIMS(ap_v)[0];
+    ldz = (int)PyArray_DIMS(ap_z)[0];
+
+    struct ARPACK_arnoldi_update_vars_s Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (float)PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+
+    ARPACK_sneupd(&Vars, want_ev, howmny, select, dr, di, z, ldz, sigmar, sigmai, workev, resid, v, ldv, ipntr, workd, workl);
+
+    Py_RETURN_NONE;
+
+}
+
+static PyObject*
+dneupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+
+    PyObject* input_dict = NULL;
+    int want_ev = 0, howmny = 0, ldv = 0, ldz = 0;
+    PyArrayObject* ap_select = NULL;
+    double sigmar = 0.0;
+    double sigmai = 0.0;
+    PyArrayObject* ap_dr = NULL;
+    PyArrayObject* ap_di = NULL;
+    PyArrayObject* ap_v = NULL;
+    PyArrayObject* ap_z = NULL;
+    PyArrayObject* ap_workev = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_ipntr = NULL;
+    PyArrayObject* ap_workd = NULL;
+    PyArrayObject* ap_workl = NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!iiO!O!O!O!ddO!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &want_ev,                                // i
+        &howmny,                                 // i
+        &PyArray_Type, (PyObject **)&ap_select,  // O!
+        &PyArray_Type, (PyObject **)&ap_dr,      // O!
+        &PyArray_Type, (PyObject **)&ap_di,      // O!
+        &PyArray_Type, (PyObject **)&ap_z,       // O!
+        &sigmar,                                 // d
+        &sigmai,                                 // d
+        &PyArray_Type, (PyObject **)&ap_workev,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    int* select = (int*)PyArray_DATA(ap_select);
+    double* dr = (double*)PyArray_DATA(ap_dr);
+    double* di = (double*)PyArray_DATA(ap_di);
+    double* workev = (double*)PyArray_DATA(ap_workev);
+    double* z = (double*)PyArray_DATA(ap_z);
+    double* resid = (double*)PyArray_DATA(ap_resid);
+    double* v = (double*)PyArray_DATA(ap_v);
+    double* workd = (double*)PyArray_DATA(ap_workd);
+    double* workl = (double*)PyArray_DATA(ap_workl);
+    ldv = (int)PyArray_DIMS(ap_v)[0];
+    ldz = (int)PyArray_DIMS(ap_z)[0];
+
+    struct ARPACK_arnoldi_update_vars_d Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    ARPACK_dneupd(&Vars, want_ev, howmny, select, dr, di, z, ldz, sigmar, sigmai, workev, resid, v, ldv, ipntr, workd, workl);
+
+    Py_RETURN_NONE;
+
+}
+
+
+static PyObject*
+cneupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    int want_ev = 0, howmny = 0, ldv = 0, ldz = 0;
+    PyArrayObject* ap_select = NULL;
+    Py_complex sigma = { .real = 0.0, .imag = 0.0 };
+    PyArrayObject* ap_d = NULL;
+    PyArrayObject* ap_v = NULL;
+    PyArrayObject* ap_z = NULL;
+    PyArrayObject* ap_workev = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_ipntr = NULL;
+    PyArrayObject* ap_workd = NULL;
+    PyArrayObject* ap_workl = NULL;
+    PyArrayObject* ap_rwork = NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!iiO!O!O!DO!O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &want_ev,                                // i
+        &howmny,                                 // i
+        &PyArray_Type, (PyObject **)&ap_select,  // O!
+        &PyArray_Type, (PyObject **)&ap_d,       // O!
+        &PyArray_Type, (PyObject **)&ap_z,       // O!
+        &sigma,                                  // D
+        &PyArray_Type, (PyObject **)&ap_workev,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl,   // O!
+        &PyArray_Type, (PyObject **)&ap_rwork    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    int* select = (int*)PyArray_DATA(ap_select);
+    ARPACK_CPLXF_TYPE* d = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_d);
+    ARPACK_CPLXF_TYPE* workev = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_workev);
+    ARPACK_CPLXF_TYPE* z = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_z);
+    ARPACK_CPLXF_TYPE* resid = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_resid);
+    ARPACK_CPLXF_TYPE* v = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_v);
+    ARPACK_CPLXF_TYPE* workd = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_workd);
+    ARPACK_CPLXF_TYPE* workl = (ARPACK_CPLXF_TYPE*)PyArray_DATA(ap_workl);
+    float* rwork = PyArray_DATA(ap_rwork);
+    ldv = (int)PyArray_DIMS(ap_v)[0];
+    ldz = (int)PyArray_DIMS(ap_z)[0];
+    ARPACK_CPLXF_TYPE sigmaC = ARPACK_cplxf((float)sigma.real, (float)sigma.imag);
+    struct ARPACK_arnoldi_update_vars_s Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (float)PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    ARPACK_cneupd(&Vars, want_ev, howmny, select, d, z, ldz, sigmaC, workev, resid, v, ldv, ipntr, workd, workl, rwork);
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+zneupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    int want_ev = 0, howmny = 0, ldv = 0, ldz = 0;
+    PyArrayObject* ap_select = NULL;
+    Py_complex sigma = { .real = 0.0, .imag = 0.0 };
+    PyArrayObject* ap_d = NULL;
+    PyArrayObject* ap_v = NULL;
+    PyArrayObject* ap_z = NULL;
+    PyArrayObject* ap_workev = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_ipntr = NULL;
+    PyArrayObject* ap_workd = NULL;
+    PyArrayObject* ap_workl = NULL;
+    PyArrayObject* ap_rwork = NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!iiO!O!O!DO!O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &want_ev,                                // i
+        &howmny,                                 // i
+        &PyArray_Type, (PyObject **)&ap_select,  // O!
+        &PyArray_Type, (PyObject **)&ap_d,       // O!
+        &PyArray_Type, (PyObject **)&ap_z,       // O!
+        &sigma,                                  // D
+        &PyArray_Type, (PyObject **)&ap_workev,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl,   // O!
+        &PyArray_Type, (PyObject **)&ap_rwork    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    int* select = (int*)PyArray_DATA(ap_select);
+    ARPACK_CPLX_TYPE* d = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_d);
+    ARPACK_CPLX_TYPE* workev = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_workev);
+    ARPACK_CPLX_TYPE* z = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_z);
+    ARPACK_CPLX_TYPE* resid = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_resid);
+    ARPACK_CPLX_TYPE* v = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_v);
+    ARPACK_CPLX_TYPE* workd = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_workd);
+    ARPACK_CPLX_TYPE* workl = (ARPACK_CPLX_TYPE*)PyArray_DATA(ap_workl);
+    double* rwork = PyArray_DATA(ap_rwork);
+    ldv = (int)PyArray_DIMS(ap_v)[0];
+    ldz = (int)PyArray_DIMS(ap_z)[0];
+    ARPACK_CPLX_TYPE sigmaC = ARPACK_cplx(sigma.real, sigma.imag);
+    struct ARPACK_arnoldi_update_vars_d Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    ARPACK_zneupd(&Vars, want_ev, howmny, select, d, z, ldz, sigmaC, workev, resid, v, ldv, ipntr, workd, workl, rwork);
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+ssaupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_v=NULL;
+    PyArrayObject* ap_ipntr=NULL;
+    PyArrayObject* ap_workd=NULL;
+    PyArrayObject* ap_workl=NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = PyArray_DATA(ap_ipntr);
+    float* resid = PyArray_DATA(ap_resid);
+    float* v = PyArray_DATA(ap_v);
+    float* workd = PyArray_DATA(ap_workd);
+    float* workl = PyArray_DATA(ap_workl);
+
+    // Map the input dict to the ARPACK structure
+
+    // Parse the dictionary, if the field is not found, raise an error.
+    // Do it separately for floats and ints.
+
+    // Declare and Initialize the ARPACK struct that will be populated from dict with zeros
+    struct ARPACK_arnoldi_update_vars_s Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (float)PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    // Call ARPACK function
+    ARPACK_ssaupd(&Vars, resid, v, Vars.n, ipntr, workd, workl);
+
+    // Unpack the struct back to the dictionary
+    #define X(name) do { \
+            PyObject* tmp_##name = PyFloat_FromDouble((double)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+            Py_XDECREF(tmp_##name); \
+            PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) do { \
+            PyObject* tmp_##name = PyLong_FromLong((long)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+                Py_XDECREF(tmp_##name); \
+                PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    Py_RETURN_NONE;
+}
+
+static PyObject*
+dsaupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_v=NULL;
+    PyArrayObject* ap_ipntr=NULL;
+    PyArrayObject* ap_workd=NULL;
+    PyArrayObject* ap_workl=NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!O!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    double* resid = (double*)PyArray_DATA(ap_resid);
+    double* v = (double*)PyArray_DATA(ap_v);
+    double* workd = (double*)PyArray_DATA(ap_workd);
+    double* workl = (double*)PyArray_DATA(ap_workl);
+
+    // Parse the dictionary, if the field is not found, raise an error.
+    // Do it separately for floats and ints.
+
+    // Declare and Initialize the ARPACK struct that will be populated from dict with zeros
+    struct ARPACK_arnoldi_update_vars_d Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+    PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+    if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+    Vars.name = PyFloat_AsDouble(name##_obj);
+    STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+    PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+    if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+    Vars.name = (int)PyLong_AsLong(name##_obj);
+    STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    // Call ARPACK function
+    ARPACK_dsaupd(&Vars, resid, v, Vars.n, ipntr, workd, workl);
+
+    // Unpack the struct back to the dictionary
+    #define X(name) do { \
+            PyObject* tmp_##name = PyFloat_FromDouble(Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+            Py_XDECREF(tmp_##name); \
+            PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) do { \
+            PyObject* tmp_##name = PyLong_FromLong((long)Vars.name); \
+            if ((!tmp_##name) || (PyDict_SetItemString(input_dict, #name, tmp_##name) < 0)) { \
+                Py_XDECREF(tmp_##name); \
+                PYERR(arpack_error, "Setting '" #name "' failed."); \
+            } \
+            Py_DECREF(tmp_##name); \
+        } while (0);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    Py_RETURN_NONE;
+}
+
+static PyObject*
+sseupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    int want_ev = 0, howmny = 0, ldv = 0, ldz = 0;
+    PyArrayObject* ap_select = NULL;
+    float sigma = 0.0;
+    PyArrayObject* ap_d = NULL;
+    PyArrayObject* ap_v = NULL;
+    PyArrayObject* ap_z = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_ipntr = NULL;
+    PyArrayObject* ap_workd = NULL;
+    PyArrayObject* ap_workl = NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!iiO!O!O!fO!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &want_ev,                                // i
+        &howmny,                                 // i
+        &PyArray_Type, (PyObject **)&ap_select,  // O!
+        &PyArray_Type, (PyObject **)&ap_d,       // O!
+        &PyArray_Type, (PyObject **)&ap_z,       // O!
+        &sigma,                                  // f
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    int* select = (int*)PyArray_DATA(ap_select);
+    float* d = (float*)PyArray_DATA(ap_d);
+    float* z = (float*)PyArray_DATA(ap_z);
+    float* resid = (float*)PyArray_DATA(ap_resid);
+    float* v = (float*)PyArray_DATA(ap_v);
+    float* workd = (float*)PyArray_DATA(ap_workd);
+    float* workl = (float*)PyArray_DATA(ap_workl);
+    ldv = (int)PyArray_DIMS(ap_v)[0];
+    ldz = (int)PyArray_DIMS(ap_z)[0];
+
+    struct ARPACK_arnoldi_update_vars_s Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (float)PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+
+    ARPACK_sseupd(&Vars, want_ev, howmny, select, d, z, ldz, sigma, resid, v, ldv, ipntr, workd, workl);
+
+    Py_RETURN_NONE;
+}
+
+
+static PyObject*
+dseupd_wrap(PyObject* Py_UNUSED(dummy), PyObject* args)
+{
+    PyObject* input_dict = NULL;
+    int want_ev = 0, howmny = 0, ldv = 0, ldz = 0;
+    PyArrayObject* ap_select = NULL;
+    double sigma = 0.0;
+    PyArrayObject* ap_d = NULL;
+    PyArrayObject* ap_v = NULL;
+    PyArrayObject* ap_z = NULL;
+    PyArrayObject* ap_resid = NULL;
+    PyArrayObject* ap_ipntr = NULL;
+    PyArrayObject* ap_workd = NULL;
+    PyArrayObject* ap_workl = NULL;
+
+    // Process input arguments
+    if (!PyArg_ParseTuple(args, "O!iiO!O!O!dO!O!O!O!O!",
+        &PyDict_Type, (PyObject **)&input_dict,  // O!
+        &want_ev,                                // i
+        &howmny,                                 // i
+        &PyArray_Type, (PyObject **)&ap_select,  // O!
+        &PyArray_Type, (PyObject **)&ap_d,       // O!
+        &PyArray_Type, (PyObject **)&ap_z,       // O!
+        &sigma,                                  // d
+        &PyArray_Type, (PyObject **)&ap_resid,   // O!
+        &PyArray_Type, (PyObject **)&ap_v,       // O!
+        &PyArray_Type, (PyObject **)&ap_ipntr,   // O!
+        &PyArray_Type, (PyObject **)&ap_workd,   // O!
+        &PyArray_Type, (PyObject **)&ap_workl    // O!
+        )
+    )
+    {
+        return NULL;
+    }
+
+    int* ipntr = (int*)PyArray_DATA(ap_ipntr);
+    int* select = (int*)PyArray_DATA(ap_select);
+    double* d = (double*)PyArray_DATA(ap_d);
+    double* z = (double*)PyArray_DATA(ap_z);
+    double* resid = (double*)PyArray_DATA(ap_resid);
+    double* v = (double*)PyArray_DATA(ap_v);
+    double* workd = (double*)PyArray_DATA(ap_workd);
+    double* workl = (double*)PyArray_DATA(ap_workl);
+    ldv = (int)PyArray_DIMS(ap_v)[0];
+    ldz = (int)PyArray_DIMS(ap_z)[0];
+
+    struct ARPACK_arnoldi_update_vars_d Vars = {0};
+
+    #define X(name) Vars.name = 0;
+    STRUCT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = PyFloat_AsDouble(name##_obj);
+        STRUCT_INEXACT_FIELD_NAMES
+    #undef X
+
+    #define X(name) \
+        PyObject* name##_obj = PyDict_GetItemString(input_dict, #name); \
+        if (!name##_obj) { PYERR(arpack_error, #name " not found in the dictionary."); } \
+        Vars.name = (int)PyLong_AsLong(name##_obj);
+        STRUCT_INT_FIELD_NAMES
+    #undef X
+
+    ARPACK_dseupd(&Vars, want_ev, howmny, select, d, z, ldz, sigma, resid, v, ldv, ipntr, workd, workl);
+
+    Py_RETURN_NONE;
+}
+
+
+static char doc_snaupd[] = ("");
+static char doc_dnaupd[] = ("");
+static char doc_cnaupd[] = ("");
+static char doc_znaupd[] = ("");
+static char doc_sneupd[] = ("");
+static char doc_dneupd[] = ("");
+static char doc_cneupd[] = ("");
+static char doc_zneupd[] = ("");
+static char doc_ssaupd[] = ("");
+static char doc_dsaupd[] = ("");
+static char doc_sseupd[] = ("");
+static char doc_dseupd[] = ("");
+
+
+// Sentinel terminated method list.
+static struct
+PyMethodDef arpacklib_module_methods[] = {
+    {"snaupd_wrap", snaupd_wrap, METH_VARARGS, doc_snaupd},
+    {"dnaupd_wrap", dnaupd_wrap, METH_VARARGS, doc_dnaupd},
+    {"cnaupd_wrap", cnaupd_wrap, METH_VARARGS, doc_cnaupd},
+    {"znaupd_wrap", znaupd_wrap, METH_VARARGS, doc_znaupd},
+    {"sneupd_wrap", sneupd_wrap, METH_VARARGS, doc_sneupd},
+    {"dneupd_wrap", dneupd_wrap, METH_VARARGS, doc_dneupd},
+    {"cneupd_wrap", cneupd_wrap, METH_VARARGS, doc_cneupd},
+    {"zneupd_wrap", zneupd_wrap, METH_VARARGS, doc_zneupd},
+    {"ssaupd_wrap", ssaupd_wrap, METH_VARARGS, doc_ssaupd},
+    {"dsaupd_wrap", dsaupd_wrap, METH_VARARGS, doc_dsaupd},
+    {"sseupd_wrap", sseupd_wrap, METH_VARARGS, doc_sseupd},
+    {"dseupd_wrap", dseupd_wrap, METH_VARARGS, doc_dseupd},
+    {NULL, NULL, 0, NULL}
+};
+
+
+static struct PyModuleDef_Slot arpacklib_module_slots[] = {
+#if PY_VERSION_HEX >= 0x030c00f0  // Python 3.12+
+    // signal that this module can be imported in isolated subinterpreters
+    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
+#endif
+#if PY_VERSION_HEX >= 0x030d00f0  // Python 3.13+
+    // signal that this module supports running without an active GIL
+    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
+#endif
+    {0, NULL},
+};
+
+
+static struct
+PyModuleDef moduledef = {
+    .m_base = PyModuleDef_HEAD_INIT,
+    .m_name = "_arpacklib",
+    .m_size = 0,
+    .m_methods = arpacklib_module_methods,
+    .m_slots = arpacklib_module_slots,
+};
+
+
+PyMODINIT_FUNC
+PyInit__arpacklib(void)
+{
+    import_array();
+    return PyModuleDef_Init(&moduledef);
+}
+
+
+#undef STRUCT_FIELD_NAMES
+#undef STRUCT_INT_FIELD_NAMES
+#undef STRUCT_INEXACT_FIELD_NAMES
diff --git a/scipy/sparse/linalg/_eigen/arpack/arpack.py b/scipy/sparse/linalg/_eigen/arpack/arpack.py
index f678deabe3..a5927fd847 100644
--- a/scipy/sparse/linalg/_eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/_eigen/arpack/arpack.py
@@ -44,10 +44,8 @@ from scipy.sparse._sputils import (
     convert_pydata_sparse_to_scipy, isdense, is_pydata_spmatrix,
 )
 from scipy.sparse.linalg import gmres, splu
-from scipy._lib._util import _aligned_zeros
-from scipy._lib._threadsafety import ReentrancyLock
-from . import _arpack
-arpack_int = _arpack.timing.nbx.dtype
+
+from . import _arpacklib
 
 __docformat__ = "restructuredtext en"
 
@@ -270,6 +268,13 @@ _SEUPD_WHICH = ['LM', 'SM', 'LA', 'SA', 'BE']
 # accepted values of parameter WHICH in _NAUPD
 _NEUPD_WHICH = ['LM', 'SM', 'LR', 'SR', 'LI', 'SI']
 
+# The enum values for the parameter WHICH in _NAUPD and _SEUPD
+WHICH_DICT = {
+    'LM': 0, 'SM': 1, 'LR': 2, 'SR': 3, 'LI': 4, 'SI': 5, 'LA': 6, 'SA': 7, 'BE': 8
+}
+
+# The enum values for the parameter HOWMNY in _NEUPD and _SEUPD
+HOWMNY_DICT = {'A': 0, 'P': 1, 'S': 2}
 
 class ArpackError(RuntimeError):
     """
@@ -313,8 +318,8 @@ def choose_ncv(k):
 
 
 class _ArpackParams:
-    def __init__(self, n, k, tp, mode=1, sigma=None,
-                 ncv=None, v0=None, maxiter=None, which="LM", tol=0):
+    def __init__(self, n, k, tp, rng, mode=1, sigma=None, ncv=None, v0=None,
+                 maxiter=None, which="LM", tol=0):
         if k <= 0:
             raise ValueError(f"k must be positive, k={k}")
 
@@ -332,11 +337,11 @@ class _ArpackParams:
 
         if v0 is not None:
             # ARPACK overwrites its initial resid,  make a copy
-            self.resid = np.array(v0, copy=True)
+            self.resid = np.array(v0, copy=True, dtype=tp)
             info = 1
         else:
             # ARPACK will use a random initial vector.
-            self.resid = np.zeros(n, tp)
+            self.resid = rng.uniform(low=-1.0, high=1.0, size=[n]).astype(tp)
             info = 0
 
         if sigma is None:
@@ -347,35 +352,65 @@ class _ArpackParams:
 
         if ncv is None:
             ncv = choose_ncv(k)
-        ncv = min(ncv, n)
-
+        self.ncv = min(ncv, n)
+        self.n = n
         self.v = np.zeros((n, ncv), tp)  # holds Ritz vectors
-        self.iparam = np.zeros(11, arpack_int)
+        self.which = which
 
         # set solver mode and parameters
-        ishfts = 1
         self.mode = mode
-        self.iparam[0] = ishfts
-        self.iparam[2] = maxiter
-        self.iparam[3] = 1
-        self.iparam[6] = mode
+        self.arpack_dict = {
+            'tol': tol,
+            'getv0_rnorm0': 0.0,
+            'aitr_betaj': 0.0,
+            'aitr_rnorm1': 0.0,
+            'aitr_wnorm': 0.0,
+            'aup2_rnorm': 0.0,
+            'ido': 0,
+            'which': WHICH_DICT[which],
+            'bmat': 0,
+            'info': info,
+            'iter': 0,
+            'maxiter': int(maxiter),
+            'mode': mode,
+            'n': n,
+            'nconv': 0,
+            'ncv': self.ncv,
+            'nev': k,
+            'np': 0,
+            'shift': 1,
+            'getv0_first': 0,
+            'getv0_iter': 0,
+            'getv0_itry': 0,
+            'getv0_orth': 0,
+            'aitr_iter': 0,
+            'aitr_j': 0,
+            'aitr_orth1': 0,
+            'aitr_orth2': 0,
+            'aitr_restart': 0,
+            'aitr_step3': 0,
+            'aitr_step4': 0,
+            'aitr_ierr': 0,
+            'aup2_initv': 0,
+            'aup2_iter': 0,
+            'aup2_getv0': 0,
+            'aup2_cnorm': 0,
+            'aup2_kplusp': 0,
+            'aup2_nev0': 0,
+            'aup2_np0': 0,
+            'aup2_numcnv': 0,
+            'aup2_update': 0,
+            'aup2_ushift': 0,
+        }
 
-        self.n = n
-        self.tol = tol
         self.k = k
-        self.maxiter = maxiter
-        self.ncv = ncv
-        self.which = which
         self.tp = tp
-        self.info = info
-
         self.converged = False
-        self.ido = 0
 
     def _raise_no_convergence(self):
         msg = "No convergence (%d iterations, %d/%d eigenvectors converged)"
-        k_ok = self.iparam[4]
-        num_iter = self.iparam[2]
+        k_ok = self.arpack_dict['nconv']
+        num_iter = self.arpack_dict['iter']
         try:
             ev, vec = self.extract(True)
         except ArpackError as err:
@@ -383,13 +418,15 @@ class _ArpackParams:
             ev = np.zeros((0,))
             vec = np.zeros((self.n, 0))
             k_ok = 0
-        raise ArpackNoConvergence(msg % (num_iter, k_ok, self.k), ev, vec)
+        raise ArpackNoConvergence(f"No convergence ({num_iter} iterations, "
+                                  f"{k_ok}/{self.k} eigenvectors converged)",
+                                  ev, vec)
 
 
 class _SymmetricArpackParams(_ArpackParams):
-    def __init__(self, n, k, tp, matvec, mode=1, M_matvec=None,
-                 Minv_matvec=None, sigma=None,
-                 ncv=None, v0=None, maxiter=None, which="LM", tol=0):
+    def __init__(self, n, k, tp, matvec, mode=1, M_matvec=None, Minv_matvec=None,
+                 sigma=None, ncv=None, v0=None, maxiter=None, which="LM", tol=0,
+                 rng=None):
         # The following modes are supported:
         #  mode = 1:
         #    Solve the standard eigenvalue problem:
@@ -518,40 +555,37 @@ class _SymmetricArpackParams(_ArpackParams):
         if k >= n:
             raise ValueError(f"k must be less than ndim(A), k={k}")
 
-        _ArpackParams.__init__(self, n, k, tp, mode, sigma,
-                               ncv, v0, maxiter, which, tol)
+        self.rng = np.random.default_rng(rng)
+        _ArpackParams.__init__(self, n, k, tp, self.rng, mode, sigma, ncv, v0,
+                               maxiter, which, tol)
+
+        self.arpack_dict['bmat'] = 0 if self.bmat == 'I' else 1
 
         if self.ncv > n or self.ncv <= k:
             raise ValueError(f"ncv must be k<ncv<=n, ncv={self.ncv}")
 
-        # Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1
-        self.workd = _aligned_zeros(3 * n, self.tp)
-        self.workl = _aligned_zeros(self.ncv * (self.ncv + 8), self.tp)
+        self.workd = np.zeros(3 * n, dtype=self.tp)
+        self.workl = np.zeros(self.ncv * (self.ncv + 8), dtype=self.tp)
 
         ltr = _type_conv[self.tp]
         if ltr not in ["s", "d"]:
             raise ValueError("Input matrix is not real-valued.")
 
-        self._arpack_solver = _arpack.__dict__[ltr + 'saupd']
-        self._arpack_extract = _arpack.__dict__[ltr + 'seupd']
+        self._arpack_solver = _arpacklib.__dict__[ltr + 'saupd_wrap']
+        self._arpack_extract = _arpacklib.__dict__[ltr + 'seupd_wrap']
 
         self.iterate_infodict = _SAUPD_ERRORS[ltr]
         self.extract_infodict = _SEUPD_ERRORS[ltr]
 
-        self.ipntr = np.zeros(11, arpack_int)
+        self.ipntr = np.zeros(11, dtype=np.int32)
 
     def iterate(self):
-        self.ido, self.tol, self.resid, self.v, self.iparam, self.ipntr, self.info = \
-            self._arpack_solver(self.ido, self.bmat, self.which, self.k,
-                                self.tol, self.resid, self.v, self.iparam,
-                                self.ipntr, self.workd, self.workl, self.info)
-
-        xslice = slice(self.ipntr[0] - 1, self.ipntr[0] - 1 + self.n)
-        yslice = slice(self.ipntr[1] - 1, self.ipntr[1] - 1 + self.n)
-        if self.ido == -1:
-            # initialization
-            self.workd[yslice] = self.OP(self.workd[xslice])
-        elif self.ido == 1:
+        self._arpack_solver(self.arpack_dict, self.resid, self.v, self.ipntr,
+                            self.workd, self.workl)
+
+        xslice = slice(self.ipntr[0], self.ipntr[0] + self.n)
+        yslice = slice(self.ipntr[1], self.ipntr[1] + self.n)
+        if self.arpack_dict['ido'] == 1:
             # compute y = Op*x
             if self.mode == 1:
                 self.workd[yslice] = self.OP(self.workd[xslice])
@@ -559,45 +593,62 @@ class _SymmetricArpackParams(_ArpackParams):
                 self.workd[xslice] = self.OPb(self.workd[xslice])
                 self.workd[yslice] = self.OPa(self.workd[xslice])
             elif self.mode == 5:
-                Bxslice = slice(self.ipntr[2] - 1, self.ipntr[2] - 1 + self.n)
+                Bxslice = slice(self.ipntr[2], self.ipntr[2] + self.n)
                 Ax = self.A_matvec(self.workd[xslice])
                 self.workd[yslice] = self.OPa(Ax + (self.sigma *
                                                     self.workd[Bxslice]))
             else:
-                Bxslice = slice(self.ipntr[2] - 1, self.ipntr[2] - 1 + self.n)
+                Bxslice = slice(self.ipntr[2], self.ipntr[2] + self.n)
                 self.workd[yslice] = self.OPa(self.workd[Bxslice])
-        elif self.ido == 2:
+
+        elif self.arpack_dict['ido'] == 2:
             self.workd[yslice] = self.B(self.workd[xslice])
-        elif self.ido == 3:
-            raise ValueError("ARPACK requested user shifts.  Assure ISHIFT==0")
+
+        elif self.arpack_dict['ido'] == 3:
+            raise ValueError("ARPACK requested user shifts. Assure ISHIFT==0")
+
+        elif self.arpack_dict['ido'] == 4:
+            # Generate random vector into resid
+            self.resid[:] = self.rng.uniform(low=-1.0, high=1.0,
+                                             size=[self.n]).astype(self.tp)
+
+        elif self.arpack_dict['ido'] == 5:
+            self.workd[yslice] = self.OP(self.workd[xslice])
+
         else:
             self.converged = True
 
-            if self.info == 0:
+            if self.arpack_dict['info'] == 0:
                 pass
-            elif self.info == 1:
+            elif self.arpack_dict['info'] == 1:
                 self._raise_no_convergence()
             else:
-                raise ArpackError(self.info, infodict=self.iterate_infodict)
+                raise ArpackError(self.arpack_dict['info'],
+                                  infodict=self.iterate_infodict)
 
     def extract(self, return_eigenvectors):
         rvec = return_eigenvectors
         ierr = 0
-        howmny = 'A'  # return all eigenvectors
-        sselect = np.zeros(self.ncv, 'int')  # unused
-        d, z, ierr = self._arpack_extract(rvec, howmny, sselect, self.sigma,
-                                          self.bmat, self.which, self.k,
-                                          self.tol, self.resid, self.v,
-                                          self.iparam[0:7], self.ipntr,
-                                          self.workd[0:2 * self.n],
-                                          self.workl, ierr)
+        self.arpack_dict['info'] = 0  # Clear, if any, previous error from naupd
+        howmny = HOWMNY_DICT["A"]  # return all eigenvectors
+        sselect = np.zeros(self.ncv, dtype=np.int32)
+        d = np.zeros(self.k, dtype=self.tp)
+        z = np.zeros((self.n, self.ncv), dtype=self.tp, order='F')
+
+        self._arpack_extract(
+            self.arpack_dict, rvec, howmny, sselect, d, z, self.sigma,
+            self.resid, self.v, self.ipntr, self.workd, #[0:2 * self.n],
+            self.workl
+        )
+
+        ierr = self.arpack_dict['info']
         if ierr != 0:
             raise ArpackError(ierr, infodict=self.extract_infodict)
-        k_ok = self.iparam[4]
+        k_ok = self.arpack_dict['nconv']
         d = d[:k_ok]
-        z = z[:, :k_ok]
 
         if return_eigenvectors:
+            z = z[:, :k_ok].copy(order='C')
             return d, z
         else:
             return d
@@ -606,7 +657,7 @@ class _SymmetricArpackParams(_ArpackParams):
 class _UnsymmetricArpackParams(_ArpackParams):
     def __init__(self, n, k, tp, matvec, mode=1, M_matvec=None,
                  Minv_matvec=None, sigma=None,
-                 ncv=None, v0=None, maxiter=None, which="LM", tol=0):
+                 ncv=None, v0=None, maxiter=None, which="LM", tol=0, rng=None):
         # The following modes are supported:
         #  mode = 1:
         #    Solve the standard eigenvalue problem:
@@ -696,101 +747,120 @@ class _UnsymmetricArpackParams(_ArpackParams):
             raise ValueError(f"mode={mode} not implemented")
 
         if which not in _NEUPD_WHICH:
-            raise ValueError(f"Parameter which must be one of {' '.join(_NEUPD_WHICH)}")
+            raise ValueError("Parameter which must be one of"
+                             f" {' '.join(_NEUPD_WHICH)}")
         if k >= n - 1:
             raise ValueError(f"k must be less than ndim(A)-1, k={k}")
 
-        _ArpackParams.__init__(self, n, k, tp, mode, sigma,
-                               ncv, v0, maxiter, which, tol)
+        self.rng = np.random.default_rng(rng)
+        _ArpackParams.__init__(self, n, k, tp, rng, mode, sigma, ncv, v0, maxiter,
+                               which, tol)
+
+        self.arpack_dict['bmat'] = 0 if self.bmat == 'I' else 1
 
         if self.ncv > n or self.ncv <= k + 1:
             raise ValueError(f"ncv must be k+1<ncv<=n, ncv={self.ncv}")
 
-        # Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1
-        self.workd = _aligned_zeros(3 * n, self.tp)
-        self.workl = _aligned_zeros(3 * self.ncv * (self.ncv + 2), self.tp)
+        self.workd = np.zeros(3 * n, dtype=self.tp)
+        self.workl = np.zeros(3 * self.ncv * (self.ncv + 2), dtype=self.tp)
 
         ltr = _type_conv[self.tp]
-        self._arpack_solver = _arpack.__dict__[ltr + 'naupd']
-        self._arpack_extract = _arpack.__dict__[ltr + 'neupd']
+        self._arpack_solver = _arpacklib.__dict__[ltr + 'naupd_wrap']
+        self._arpack_extract = _arpacklib.__dict__[ltr + 'neupd_wrap']
 
         self.iterate_infodict = _NAUPD_ERRORS[ltr]
         self.extract_infodict = _NEUPD_ERRORS[ltr]
 
-        self.ipntr = np.zeros(14, arpack_int)
+        self.ipntr = np.zeros(14, dtype=np.int32)
 
         if self.tp in 'FD':
-            # Use _aligned_zeros to work around a f2py bug in Numpy 1.9.1
-            self.rwork = _aligned_zeros(self.ncv, self.tp.lower())
+            self.rwork = np.zeros(self.ncv, dtype=self.tp.lower())
         else:
             self.rwork = None
 
     def iterate(self):
         if self.tp in 'fd':
-            results = self._arpack_solver(self.ido, self.bmat, self.which, self.k,
-                                          self.tol, self.resid, self.v, self.iparam,
-                                          self.ipntr, self.workd, self.workl, self.info)
-            self.ido, self.tol, self.resid, self.v, \
-                self.iparam, self.ipntr, self.info = results
+            self._arpack_solver(
+                self.arpack_dict, self.resid, self.v, self.ipntr, self.workd,
+                self.workl
+            )
 
         else:
-            results = self._arpack_solver(self.ido, self.bmat, self.which, self.k,
-                                          self.tol, self.resid, self.v, self.iparam,
-                                          self.ipntr, self.workd, self.workl,
-                                          self.rwork, self.info)
-            self.ido, self.tol, self.resid, self.v, \
-                self.iparam, self.ipntr, self.info = results
-
-
-        xslice = slice(self.ipntr[0] - 1, self.ipntr[0] - 1 + self.n)
-        yslice = slice(self.ipntr[1] - 1, self.ipntr[1] - 1 + self.n)
-        if self.ido == -1:
-            # initialization
-            self.workd[yslice] = self.OP(self.workd[xslice])
-        elif self.ido == 1:
+            self._arpack_solver(
+                self.arpack_dict, self.resid, self.v, self.ipntr, self.workd,
+                self.workl, self.rwork
+            )
+
+        xslice = slice(self.ipntr[0], self.ipntr[0] + self.n)
+        yslice = slice(self.ipntr[1], self.ipntr[1] + self.n)
+
+        if self.arpack_dict['ido'] == 1:
             # compute y = Op*x
             if self.mode in (1, 2):
                 self.workd[yslice] = self.OP(self.workd[xslice])
             else:
-                Bxslice = slice(self.ipntr[2] - 1, self.ipntr[2] - 1 + self.n)
+                Bxslice = slice(self.ipntr[2], self.ipntr[2] + self.n)
                 self.workd[yslice] = self.OPa(self.workd[Bxslice])
-        elif self.ido == 2:
+
+        elif self.arpack_dict['ido'] == 2:
             self.workd[yslice] = self.B(self.workd[xslice])
-        elif self.ido == 3:
-            raise ValueError("ARPACK requested user shifts.  Assure ISHIFT==0")
+
+        elif self.arpack_dict['ido'] == 3:
+            raise ValueError("ARPACK requested user shifts. Assure ISHIFT==0")
+
+        elif self.arpack_dict['ido'] == 4:
+            if self.tp in 'fd':
+                # Generate random vector into resid
+                self.resid[:] = self.rng.uniform(low=-1.0, high=1.0,
+                                                 size=[self.n]).astype(self.tp)
+            else:
+                # Generate complex random vector into resid
+                self.resid[:] = self.rng.uniform(low=-1.0, high=1.0, size=[self.n, 2]
+                ).view(np.complex128).astype(self.tp).ravel()
+
+        elif self.arpack_dict['ido'] == 5:
+            self.workd[yslice] = self.OP(self.workd[xslice])
+
         else:
             self.converged = True
 
-            if self.info == 0:
+            if self.arpack_dict['info'] == 0:
                 pass
-            elif self.info == 1:
+            elif self.arpack_dict['info'] == 1:
                 self._raise_no_convergence()
             else:
-                raise ArpackError(self.info, infodict=self.iterate_infodict)
+                raise ArpackError(info=self.arpack_dict['info'],
+                                  infodict=self.iterate_infodict)
 
     def extract(self, return_eigenvectors):
         k, n = self.k, self.n
 
         ierr = 0
-        howmny = 'A'  # return all eigenvectors
-        sselect = np.zeros(self.ncv, 'int')  # unused
-        sigmar = np.real(self.sigma)
-        sigmai = np.imag(self.sigma)
+        self.arpack_dict['info'] = 0  # Clear, if any, previous error from naupd
+        howmny = HOWMNY_DICT['A']  # return all eigenvectors
+        sselect = np.zeros(self.ncv, dtype=np.int32)
+        sigmar = float(np.real(self.sigma))
+        sigmai = float(np.imag(self.sigma))
         workev = np.zeros(3 * self.ncv, self.tp)
 
         if self.tp in 'fd':
-            dr = np.zeros(k + 1, self.tp)
-            di = np.zeros(k + 1, self.tp)
-            zr = np.zeros((n, k + 1), self.tp)
-            dr, di, zr, ierr = \
-                self._arpack_extract(return_eigenvectors,
-                       howmny, sselect, sigmar, sigmai, workev,
-                       self.bmat, self.which, k, self.tol, self.resid,
-                       self.v, self.iparam, self.ipntr,
-                       self.workd, self.workl, self.info)
+            dr = np.zeros([k + 1], dtype=self.tp)
+            di = np.zeros([k + 1], dtype=self.tp)
+            # Using a Fortran ordered array for NumPy parse the result correctly
+            zr = np.zeros([n, k + 1], dtype=self.tp, order='F')
+
+            # ARPACK _neupd call
+            self._arpack_extract(
+                self.arpack_dict, return_eigenvectors, howmny, sselect, dr, di,
+                zr, sigmar, sigmai, workev, self.resid, self.v, self.ipntr,
+                self.workd, self.workl
+            )
+
+            ierr = self.arpack_dict['info']
+
             if ierr != 0:
                 raise ArpackError(ierr, infodict=self.extract_infodict)
-            nreturned = self.iparam[4]  # number of good eigenvalues returned
+            nreturned = self.arpack_dict['nconv']  # number of good eigs returned
 
             # Build complex eigenvalues from real and imaginary parts
             d = dr + 1.0j * di
@@ -885,18 +955,19 @@ class _UnsymmetricArpackParams(_ArpackParams):
                 d = d[ind]
                 z = z[:, ind]
         else:
-            # complex is so much simpler...
-            d, z, ierr =\
-                    self._arpack_extract(return_eigenvectors,
-                           howmny, sselect, self.sigma, workev,
-                           self.bmat, self.which, k, self.tol, self.resid,
-                           self.v, self.iparam, self.ipntr,
-                           self.workd, self.workl, self.rwork, ierr)
+            d = np.zeros([k], dtype=self.tp)
+            z = np.zeros([n, k], dtype=self.tp, order='F')
+            self._arpack_extract(
+                self.arpack_dict, return_eigenvectors, howmny, sselect, d, z,
+                self.sigma, workev, self.resid, self.v, self.ipntr, self.workd,
+                self.workl, self.rwork)
+
+            ierr = self.arpack_dict['info']
 
             if ierr != 0:
                 raise ArpackError(ierr, infodict=self.extract_infodict)
 
-            k_ok = self.iparam[4]
+            k_ok = self.arpack_dict['nconv']
             d = d[:k_ok]
             z = z[:, :k_ok]
 
@@ -1096,15 +1167,9 @@ def get_OPinv_matvec(A, M, sigma, hermitian=False, tol=0):
             return SpLuInv(OP).matvec
 
 
-# ARPACK is not threadsafe or reentrant (SAVE variables), so we need a
-# lock and a re-entering check.
-_ARPACK_LOCK = ReentrancyLock("Nested calls to eigs/eighs not allowed: "
-                              "ARPACK is not re-entrant")
-
-
 def eigs(A, k=6, M=None, sigma=None, which='LM', v0=None,
          ncv=None, maxiter=None, tol=0, return_eigenvectors=True,
-         Minv=None, OPinv=None, OPpart=None):
+         Minv=None, OPinv=None, OPpart=None, rng=None):
     """
     Find k eigenvalues and eigenvectors of the square matrix A.
 
@@ -1207,6 +1272,11 @@ def eigs(A, k=6, M=None, sigma=None, which='LM', v0=None,
         See notes in sigma, above.
     OPpart : {'r' or 'i'}, optional
         See notes in sigma, above
+    rng : `numpy.random.Generator`, optional
+        Pseudorandom number generator state. When `rng` is None, a new
+        `numpy.random.Generator` is created using entropy from the
+        operating system. Types other than `numpy.random.Generator` are
+        passed to `numpy.random.default_rng` to instantiate a ``Generator``.
 
     Returns
     -------
@@ -1336,7 +1406,8 @@ def eigs(A, k=6, M=None, sigma=None, which='LM', v0=None,
 
         matvec = aslinearoperator(A).matvec
         if Minv is not None:
-            raise ValueError("Minv should not be specified when sigma is")
+            raise ValueError("Minv should not be specified when sigma is"
+                             "specified.")
         if OPinv is None:
             Minv_matvec = get_OPinv_matvec(A, M, sigma,
                                            hermitian=False, tol=tol)
@@ -1348,20 +1419,20 @@ def eigs(A, k=6, M=None, sigma=None, which='LM', v0=None,
         else:
             M_matvec = aslinearoperator(M).matvec
 
+    rng = np.random.default_rng(rng)
     params = _UnsymmetricArpackParams(n, k, A.dtype.char, matvec, mode,
                                       M_matvec, Minv_matvec, sigma,
-                                      ncv, v0, maxiter, which, tol)
+                                      ncv, v0, maxiter, which, tol, rng)
 
-    with _ARPACK_LOCK:
-        while not params.converged:
-            params.iterate()
+    while not params.converged:
+        params.iterate()
 
-        return params.extract(return_eigenvectors)
+    return params.extract(return_eigenvectors)
 
 
 def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
           ncv=None, maxiter=None, tol=0, return_eigenvectors=True,
-          Minv=None, OPinv=None, mode='normal'):
+          Minv=None, OPinv=None, mode='normal', rng=None):
     """
     Find k eigenvalues and eigenvectors of the real symmetric square matrix
     or complex Hermitian matrix A.
@@ -1374,8 +1445,8 @@ def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
     with corresponding eigenvectors x[i].
 
     Note that there is no specialized routine for the case when A is a complex
-    Hermitian matrix. In this case, ``eigsh()`` will call ``eigs()`` and return the
-    real parts of the eigenvalues thus obtained.
+    Hermitian matrix. In this case, ``eigsh()`` will call ``eigs()`` and return
+    the real parts of the eigenvalues thus obtained.
 
     Parameters
     ----------
@@ -1528,6 +1599,11 @@ def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
         The choice of mode will affect which eigenvalues are selected by
         the keyword 'which', and can also impact the stability of
         convergence (see [2] for a discussion).
+    rng : `numpy.random.Generator`, optional
+        Pseudorandom number generator state. When `rng` is None, a new
+        `numpy.random.Generator` is created using entropy from the
+        operating system. Types other than `numpy.random.Generator` are
+        passed to `numpy.random.default_rng` to instantiate a ``Generator``.
 
     Raises
     ------
@@ -1626,16 +1702,14 @@ def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
         matvec = A.matvec
 
         if OPinv is not None:
-            raise ValueError("OPinv should not be specified "
-                             "with sigma = None.")
+            raise ValueError("OPinv should not be specified with sigma = None.")
         if M is None:
             #standard eigenvalue problem
             mode = 1
             M_matvec = None
             Minv_matvec = None
             if Minv is not None:
-                raise ValueError("Minv should not be "
-                                 "specified with M = None.")
+                raise ValueError("Minv should not be specified with M = None.")
         else:
             #general eigenvalue problem
             mode = 2
@@ -1648,7 +1722,8 @@ def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
     else:
         # sigma is not None: shift-invert mode
         if Minv is not None:
-            raise ValueError("Minv should not be specified when sigma is")
+            raise ValueError("Minv should not be specified when sigma is "
+                             "specified.")
 
         # normal mode
         if mode == 'normal':
@@ -1694,13 +1769,12 @@ def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
         # unrecognized mode
         else:
             raise ValueError(f"unrecognized mode '{mode}'")
-
+    rng = np.random.default_rng(rng)
     params = _SymmetricArpackParams(n, k, A.dtype.char, matvec, mode,
                                     M_matvec, Minv_matvec, sigma,
-                                    ncv, v0, maxiter, which, tol)
+                                    ncv, v0, maxiter, which, tol, rng)
 
-    with _ARPACK_LOCK:
-        while not params.converged:
-            params.iterate()
+    while not params.converged:
+        params.iterate()
 
-        return params.extract(return_eigenvectors)
+    return params.extract(return_eigenvectors)
diff --git a/scipy/sparse/linalg/_eigen/arpack/arpack.pyf.src b/scipy/sparse/linalg/_eigen/arpack/arpack.pyf.src
deleted file mode 100644
index 64640d4e81..0000000000
--- a/scipy/sparse/linalg/_eigen/arpack/arpack.pyf.src
+++ /dev/null
@@ -1,213 +0,0 @@
-!    -*- f90 -*-
-! Note: the context of this file is case sensitive.
-
-python module _arpack ! in 
-    <_rd=real,double precision>
-    <_cd=complex,double complex>
-    interface  ! in :_arpack
-        subroutine <s,d>saupd(ido,bmat,n,which,nev,tol,resid,ncv,v,ldv,iparam,ipntr,workd,workl,lworkl,info) ! in :_arpack:src/ssaupd.f
-            threadsafe   ! it's not really threadsafe, but we use a lock on the Python side, so keeping GIL is not needed
-            integer intent(in,out):: ido
-            character*1 :: bmat
-            integer optional,check(len(resid)>=n),depend(resid) :: n=len(resid)
-            character*2 :: which
-            integer :: nev
-            <_rd>, intent(in,out) :: tol
-            <_rd> dimension(n),intent(in,out) :: resid
-            integer optional,check(shape(v,1)==ncv),depend(v) :: ncv=shape(v,1)
-            <_rd> dimension(ldv,ncv),intent(in,out) :: v
-            integer optional,check(shape(v,0)==ldv),depend(v) :: ldv=shape(v,0)
-            integer dimension(11),intent(in,out) :: iparam
-            integer dimension(11),intent(in,out) :: ipntr
-            <_rd> dimension(3 * n),depend(n),intent(inout) :: workd
-            <_rd> dimension(lworkl),intent(inout) :: workl
-            integer optional,check(len(workl)>=lworkl),depend(workl) :: lworkl=len(workl)
-            integer intent(in,out):: info
-        end subroutine <s,d>saupd
-
-        subroutine <s,d>seupd(rvec,howmny,select,d,z,ldz,sigma,bmat,n,which,nev,tol,resid,ncv,v,ldv,iparam,ipntr,workd,workl,lworkl,info) ! in :_arpack:src/sseupd.f
-            threadsafe   ! it's not really threadsafe, but we use a lock on the Python side, so keeping GIL is not needed
-            logical :: rvec
-            character :: howmny
-            logical dimension(ncv) :: select
-            <_rd> dimension(nev),intent(out),depend(nev) :: d
-            <_rd> dimension(n,nev),intent(out),depend(n,nev) :: z
-            integer optional,check(shape(z,0)==ldz),depend(z) :: ldz=shape(z,0)
-            <_rd> :: sigma
-            character :: bmat
-            integer optional,check(len(resid)>=n),depend(resid) :: n=len(resid)
-            character*2 :: which
-            integer :: nev 
-            <_rd> :: tol
-            <_rd> dimension(n) :: resid
-            integer optional,check(len(select)>=ncv),depend(select) :: ncv=len(select)
-            <_rd> dimension(ldv,ncv),depend(ncv) :: v
-            integer optional,check(shape(v,0)==ldv),depend(v) :: ldv=shape(v,0)
-            integer dimension(7) :: iparam
-            integer dimension(11) :: ipntr
-            <_rd> dimension(2 * n),depend(n) :: workd
-            <_rd> dimension(lworkl) :: workl
-            integer optional,check(len(workl)>=lworkl),depend(workl) :: lworkl=len(workl)
-            integer intent(in,out):: info
-        end subroutine <s,d>seupd
-
-        subroutine <s,d>naupd(ido,bmat,n,which,nev,tol,resid,ncv,v,ldv,iparam,ipntr,workd,workl,lworkl,info) ! in :_arpack:src/snaupd.f
-            threadsafe   ! it's not really threadsafe, but we use a lock on the Python side, so keeping GIL is not needed
-            integer intent(in,out):: ido
-            character*1 :: bmat
-            integer optional,check(len(resid)>=n),depend(resid) :: n=len(resid)
-            character*2 :: which
-            integer :: nev
-            <_rd>, intent(in,out) :: tol
-            <_rd> dimension(n),intent(in,out) :: resid
-            integer optional,check(shape(v,1)==ncv),depend(v) :: ncv=shape(v,1)
-            <_rd> dimension(ldv,ncv),intent(in,out) :: v
-            integer optional,check(shape(v,0)==ldv),depend(v) :: ldv=shape(v,0)
-            integer dimension(11),intent(in,out) :: iparam
-            integer dimension(14),intent(in,out) :: ipntr
-            <_rd> dimension(3 * n),depend(n),intent(inout) :: workd
-            <_rd> dimension(lworkl),intent(inout) :: workl
-            integer optional,check(len(workl)>=lworkl),depend(workl) :: lworkl=len(workl)
-            integer intent(in,out):: info
-        end subroutine <s,d>naupd
-
-        subroutine <s,d>neupd(rvec,howmny,select,dr,di,z,ldz,sigmar,sigmai,workev,bmat,n,which,nev,tol,resid,ncv,v,ldv,iparam,ipntr,workd,workl,lworkl,info) ! in ARPACK/SRC/sneupd.f
-            threadsafe   ! it's not really threadsafe, but we use a lock on the Python side, so keeping GIL is not needed
-            logical :: rvec
-            character :: howmny
-            logical dimension(ncv) :: select
-            <_rd> dimension(nev + 1),depend(nev),intent(out) :: dr
-            <_rd> dimension(nev + 1),depend(nev),intent(out) :: di
-            <_rd> dimension(n,nev+1),depend(n,nev),intent(out) :: z
-            integer optional,check(shape(z,0)==ldz),depend(z) :: ldz=shape(z,0)
-            <_rd> :: sigmar
-            <_rd> :: sigmai
-            <_rd> dimension(3 * ncv),depend(ncv) :: workev
-            character :: bmat
-            integer optional,check(len(resid)>=n),depend(resid) :: n=len(resid)
-            character*2 :: which
-            integer :: nev
-            <_rd> :: tol
-            <_rd> dimension(n) :: resid
-            integer optional,check(len(select)>=ncv),depend(select) :: ncv=len(select)
-            <_rd> dimension(n,ncv),depend(n,ncv) :: v
-            integer optional,check(shape(v,0)==ldv),depend(v) :: ldv=shape(v,0)
-            integer dimension(11) :: iparam
-            integer dimension(14) :: ipntr
-            <_rd> dimension(3 * n),depend(n):: workd
-            <_rd> dimension(lworkl) :: workl
-            integer optional,check(len(workl)>=lworkl),depend(workl) :: lworkl=len(workl)
-            integer intent(in,out):: info
-        end subroutine <s,d>neupd
-
-        subroutine <c,z>naupd(ido,bmat,n,which,nev,tol,resid,ncv,v,ldv,iparam,ipntr,workd,workl,lworkl,rwork,info) ! in :_arpack:src/snaupd.f
-            threadsafe   ! it's not really threadsafe, but we use a lock on the Python side, so keeping GIL is not needed
-            integer intent(in,out):: ido
-            character*1 :: bmat
-            integer optional,check(len(resid)>=n),depend(resid) :: n=len(resid)
-            character*2 :: which
-            integer :: nev
-            <_rd>, intent(in,out) :: tol
-            <_cd> dimension(n),intent(in,out) :: resid
-            integer optional,check(shape(v,1)==ncv),depend(v) :: ncv=shape(v,1)
-            <_cd> dimension(ldv,ncv),intent(in,out) :: v
-            integer optional,check(shape(v,0)==ldv),depend(v) :: ldv=shape(v,0)
-            integer dimension(11),intent(in,out) :: iparam
-            integer dimension(14),intent(in,out) :: ipntr
-            <_cd> dimension(3 * n),depend(n),intent(inout) :: workd
-            <_cd> dimension(lworkl),intent(inout) :: workl
-            integer optional,check(len(workl)>=lworkl),depend(workl) :: lworkl=len(workl)
-            <_rd> dimension(ncv),depend(ncv),intent(inout) :: rwork
-            integer intent(in,out):: info
-        end subroutine <c,z>naupd
-
-        subroutine <c,z>neupd(rvec,howmny,select,d,z,ldz,sigma,workev,bmat,n,which,nev,tol,resid,ncv,v,ldv,iparam,ipntr,workd,workl,lworkl,rwork,info) ! in :_arpack:src/sneupd.f
-            threadsafe   ! it's not really threadsafe, but we use a lock on the Python side, so keeping GIL is not needed
-            logical :: rvec
-            character :: howmny
-            logical dimension(ncv) :: select
-            <_cd> dimension(nev),depend(nev),intent(out) :: d
-            <_cd> dimension(n,nev), depend(n,nev),intent(out) :: z
-            integer optional,check(shape(z,0)==ldz),depend(z) :: ldz=shape(z,0)
-            <_cd> :: sigma
-            <_cd> dimension(3 * ncv),depend(ncv) :: workev
-            character :: bmat
-            integer optional,check(len(resid)>=n),depend(resid) :: n=len(resid)
-            character*2 :: which
-            integer :: nev 
-            <_rd> :: tol
-            <_cd> dimension(n) :: resid
-            integer optional,check(len(select)>=ncv),depend(select) :: ncv=len(select)
-            <_cd> dimension(ldv,ncv),depend(ncv) :: v
-            integer optional,check(shape(v,0)==ldv),depend(v) :: ldv=shape(v,0)
-            integer dimension(11) :: iparam
-            integer dimension(14) :: ipntr
-            <_cd> dimension(3 * n),depend(n) :: workd
-            <_cd> dimension(lworkl) :: workl
-            integer optional,check(len(workl)>=lworkl),depend(workl) :: lworkl=len(workl)
-            <_rd> dimension(ncv),depend(ncv) :: rwork
-            integer intent(in,out):: info
-        end subroutine <c,z>neupd
-            integer :: logfil
-            integer :: ndigit
-            integer :: mgetv0
-            integer :: msaupd
-            integer :: msaup2
-            integer :: msaitr
-            integer :: mseigt
-            integer :: msapps
-            integer :: msgets
-            integer :: mseupd
-            integer :: mnaupd
-            integer :: mnaup2
-            integer :: mnaitr
-            integer :: mneigh
-            integer :: mnapps
-            integer :: mngets
-            integer :: mneupd
-            integer :: mcaupd
-            integer :: mcaup2
-            integer :: mcaitr
-            integer :: mceigh
-            integer :: mcapps
-            integer :: mcgets
-            integer :: mceupd
-            integer :: nopx
-            integer :: nbx
-            integer :: nrorth
-            integer :: nitref
-            integer :: nrstrt
-            real :: tsaupd
-            real :: tsaup2
-            real :: tsaitr
-            real :: tseigt
-            real :: tsgets
-            real :: tsapps
-            real :: tsconv
-            real :: tnaupd
-            real :: tnaup2
-            real :: tnaitr
-            real :: tneigh
-            real :: tngets
-            real :: tnapps
-            real :: tnconv
-            real :: tcaupd
-            real :: tcaup2
-            real :: tcaitr
-            real :: tceigh
-            real :: tcgets
-            real :: tcapps
-            real :: tcconv
-            real :: tmvopx
-            real :: tmvbx
-            real :: tgetv0
-            real :: titref
-            real :: trvec
-            common /debug/ logfil,ndigit,mgetv0,msaupd,msaup2,msaitr,mseigt,msapps,msgets,mseupd,mnaupd,mnaup2,mnaitr,mneigh,mnapps,mngets,mneupd,mcaupd,mcaup2,mcaitr,mceigh,mcapps,mcgets,mceupd
-            common /timing/ nopx,nbx,nrorth,nitref,nrstrt,tsaupd,tsaup2,tsaitr,tseigt,tsgets,tsapps,tsconv,tnaupd,tnaup2,tnaitr,tneigh,tngets,tnapps,tnconv,tcaupd,tcaup2,tcaitr,tceigh,tcgets,tcapps,tcconv,tmvopx,tmvbx,tgetv0,titref,trvec
-
-    end interface 
-end python module _arpack
-
-! This file was auto-generated with f2py (version:2_3198).
-! See http://cens.ioc.ee/projects/f2py2e/
diff --git a/scipy/sparse/linalg/_eigen/arpack/meson.build b/scipy/sparse/linalg/_eigen/arpack/meson.build
index 52c8ab968b..c183fcfa88 100644
--- a/scipy/sparse/linalg/_eigen/arpack/meson.build
+++ b/scipy/sparse/linalg/_eigen/arpack/meson.build
@@ -1,120 +1,36 @@
 arpack_sources = [
-  'ARPACK/SRC/ccdotc.f',
-  'ARPACK/SRC/cgetv0.f',
-  'ARPACK/SRC/cnaitr.f',
-  'ARPACK/SRC/cnapps.f',
-  'ARPACK/SRC/cnaup2.f',
-  'ARPACK/SRC/cnaupd.f',
-  'ARPACK/SRC/cneigh.f',
-  'ARPACK/SRC/cneupd.f',
-  'ARPACK/SRC/cngets.f',
-  'ARPACK/SRC/csortc.f',
-  'ARPACK/SRC/cstatn.f',
-  'ARPACK/SRC/dgetv0.f',
-  'ARPACK/SRC/dnaitr.f',
-  'ARPACK/SRC/dnapps.f',
-  'ARPACK/SRC/dnaup2.f',
-  'ARPACK/SRC/dnaupd.f',
-  'ARPACK/SRC/dnconv.f',
-  'ARPACK/SRC/dneigh.f',
-  'ARPACK/SRC/dneupd.f',
-  'ARPACK/SRC/dngets.f',
-  'ARPACK/SRC/dsaitr.f',
-  'ARPACK/SRC/dsapps.f',
-  'ARPACK/SRC/dsaup2.f',
-  'ARPACK/SRC/dsaupd.f',
-  'ARPACK/SRC/dsconv.f',
-  'ARPACK/SRC/dseigt.f',
-  'ARPACK/SRC/dsesrt.f',
-  'ARPACK/SRC/dseupd.f',
-  'ARPACK/SRC/dsgets.f',
-  'ARPACK/SRC/dsortc.f',
-  'ARPACK/SRC/dsortr.f',
-  'ARPACK/SRC/dstatn.f',
-  'ARPACK/SRC/dstats.f',
-  'ARPACK/SRC/dstqrb.f',
-  'ARPACK/SRC/sgetv0.f',
-  'ARPACK/SRC/snaitr.f',
-  'ARPACK/SRC/snapps.f',
-  'ARPACK/SRC/snaup2.f',
-  'ARPACK/SRC/snaupd.f',
-  'ARPACK/SRC/snconv.f',
-  'ARPACK/SRC/sneigh.f',
-  'ARPACK/SRC/sneupd.f',
-  'ARPACK/SRC/sngets.f',
-  'ARPACK/SRC/ssaitr.f',
-  'ARPACK/SRC/ssapps.f',
-  'ARPACK/SRC/ssaup2.f',
-  'ARPACK/SRC/ssaupd.f',
-  'ARPACK/SRC/ssconv.f',
-  'ARPACK/SRC/sseigt.f',
-  'ARPACK/SRC/ssesrt.f',
-  'ARPACK/SRC/sseupd.f',
-  'ARPACK/SRC/ssgets.f',
-  'ARPACK/SRC/ssortc.f',
-  'ARPACK/SRC/ssortr.f',
-  'ARPACK/SRC/sstatn.f',
-  'ARPACK/SRC/sstats.f',
-  'ARPACK/SRC/sstqrb.f',
-  'ARPACK/SRC/zgetv0.f',
-  'ARPACK/SRC/znaitr.f',
-  'ARPACK/SRC/znapps.f',
-  'ARPACK/SRC/znaup2.f',
-  'ARPACK/SRC/znaupd.f',
-  'ARPACK/SRC/zneigh.f',
-  'ARPACK/SRC/zneupd.f',
-  'ARPACK/SRC/zngets.f',
-  'ARPACK/SRC/zsortc.f',
-  'ARPACK/SRC/zstatn.f',
-  'ARPACK/SRC/zzdotc.f',
-  'ARPACK/UTIL/cmout.f',
-  'ARPACK/UTIL/cvout.f',
-  'ARPACK/UTIL/dmout.f',
-  'ARPACK/UTIL/dvout.f',
-  'ARPACK/UTIL/icnteq.f',
-  'ARPACK/UTIL/icopy.f',
-  'ARPACK/UTIL/iset.f',
-  'ARPACK/UTIL/iswap.f',
-  'ARPACK/UTIL/ivout.f',
-  'ARPACK/UTIL/second_NONE.f',
-  'ARPACK/UTIL/smout.f',
-  'ARPACK/UTIL/svout.f',
-  'ARPACK/UTIL/zmout.f',
-  'ARPACK/UTIL/zvout.f'
+  'ARPACK/_arpack.h',
+  'ARPACK/_arpack_n_single.c',
+  'ARPACK/_arpack_n_double.c',
+  'ARPACK/_arpack_n_single_complex.c',
+  'ARPACK/_arpack_n_double_complex.c',
+  'ARPACK/_arpack_s_single.c',
+  'ARPACK/_arpack_s_double.c',
+  'ARPACK/_arpack_n_single.h',
+  'ARPACK/_arpack_n_double.h',
+  'ARPACK/_arpack_n_single_complex.h',
+  'ARPACK/_arpack_n_double_complex.h',
+  'ARPACK/_arpack_s_double.h',
+  'ARPACK/_arpack_s_single.h'
 ]
 
-# Building ARPACK yields a ton of rank mismatch (scalar and rank-1) warnings
-# that cannot be suppressed with a more specific flag.
-_suppress_all_warnings = ff.get_supported_arguments('-w')
-
-arpack_lib = static_library('arpack_lib',
+arpack_lib = static_library('_arpack',
   arpack_sources,
-  fortran_args: [fortran_ignore_warnings, _suppress_all_warnings],
-  include_directories: ['ARPACK/SRC'],
-  override_options: ['b_lto=false'],
-  gnu_symbol_visibility: 'hidden',
-)
-
-arpack_module = custom_target('arpack_module',
-  output: ['_arpackmodule.c', '_arpack-f2pywrappers.f'],
-  input: 'arpack.pyf.src',
-  command: [generate_f2pymod, '@INPUT@', '-o', '@OUTDIR@'] + f2py_freethreading_arg,
+  dependencies: [m_dep, lapack_dep, blas_dep],
 )
 
-_arpack = py3.extension_module('_arpack',
-  arpack_module,
+py3.extension_module('_arpacklib',
+  '_arpackmodule.c',
   link_with: arpack_lib,
+  dependencies: [np_dep],
   link_args: version_link_args,
-  dependencies: [lapack_dep, blas_dep, fortranobject_dep],
   install: true,
-  link_language: 'fortran',
-  subdir: 'scipy/sparse/linalg/_eigen/arpack'
+  subdir: 'scipy/sparse/linalg/_eigen/arpack',
 )
 
 py3.install_sources([
     '__init__.py',
     'arpack.py',
-    'ARPACK/COPYING'
   ],
   subdir: 'scipy/sparse/linalg/_eigen/arpack'
 )
diff --git a/scipy/sparse/linalg/_eigen/arpack/tests/test_arpack.py b/scipy/sparse/linalg/_eigen/arpack/tests/test_arpack.py
index e962798a9f..6b50890c32 100644
--- a/scipy/sparse/linalg/_eigen/arpack/tests/test_arpack.py
+++ b/scipy/sparse/linalg/_eigen/arpack/tests/test_arpack.py
@@ -1,9 +1,3 @@
-__usage__ = """
-To run tests locally:
-  python tests/test_arpack.py [-l<int>] [-v<int>]
-
-"""
-
 import threading
 import itertools
 
@@ -13,7 +7,7 @@ from numpy.testing import assert_allclose, assert_equal, suppress_warnings
 from pytest import raises as assert_raises
 import pytest
 
-from numpy import dot, conj, random
+from numpy import dot, conj
 from scipy.linalg import eig, eigh
 from scipy.sparse import csc_array, csr_array, diags_array, random_array
 from scipy.sparse.linalg import LinearOperator, aslinearoperator
@@ -189,7 +183,7 @@ def argsort_which(eigenvalues, typ, k, which,
 
 
 def eval_evec(symmetric, d, typ, k, which, v0=None, sigma=None,
-              mattype=np.asarray, OPpart=None, mode='normal'):
+              mattype=np.asarray, OPpart=None, mode='normal', rng=None):
     general = ('bmat' in d)
 
     if symmetric:
@@ -220,7 +214,7 @@ def eval_evec(symmetric, d, typ, k, which, v0=None, sigma=None,
     exact_eval = exact_eval[ind]
 
     # compute arpack eigenvalues
-    kwargs = dict(which=which, v0=v0, sigma=sigma)
+    kwargs = dict(which=which, v0=v0, sigma=sigma, rng=rng)
     if eigs_func is eigsh:
         kwargs['mode'] = mode
     else:
@@ -399,45 +393,38 @@ class NonSymmetricParams:
 
 
 @pytest.mark.iterations(1)
-@pytest.mark.thread_unsafe
-def test_symmetric_modes(num_parallel_threads):
+@pytest.mark.parametrize("sigma, mode", [(None, 'normal'), (0.5, 'normal'),
+                                         (0.5, 'buckling'), (0.5, 'cayley')])
+@pytest.mark.parametrize("mattype", [csr_array, aslinearoperator, np.asarray])
+@pytest.mark.parametrize("which", ['LM', 'SM', 'LA', 'SA', 'BE'])
+@pytest.mark.parametrize("typ", ['f', 'd'])
+@pytest.mark.parametrize("D", SymmetricParams().real_test_cases)
+def test_symmetric_modes(num_parallel_threads, D, typ, which, mattype,
+                         sigma, mode):
     assert num_parallel_threads == 1
-    params = SymmetricParams()
+    rng = np.random.default_rng(1749531508689996)
     k = 2
-    symmetric = True
-    for D in params.real_test_cases:
-        for typ in 'fd':
-            for which in params.which:
-                for mattype in params.mattypes:
-                    for (sigma, modes) in params.sigmas_modes.items():
-                        for mode in modes:
-                            eval_evec(symmetric, D, typ, k, which,
-                                      None, sigma, mattype, None, mode)
-
-
-def test_hermitian_modes():
-    params = SymmetricParams()
+    eval_evec(True, D, typ, k, which, None, sigma, mattype, None, mode, rng=rng)
+
+
+@pytest.mark.parametrize("sigma", [None, 0.5])
+@pytest.mark.parametrize("mattype", [csr_array, aslinearoperator, np.asarray])
+@pytest.mark.parametrize("which", ['LM', 'SM', 'LA', 'SA'])
+@pytest.mark.parametrize("typ", ['F', 'D'])
+@pytest.mark.parametrize("D", SymmetricParams().complex_test_cases)
+def test_hermitian_modes(D, typ, which, mattype, sigma):
+    rng = np.random.default_rng(1749531706842957)
     k = 2
-    symmetric = True
-    for D in params.complex_test_cases:
-        for typ in 'FD':
-            for which in params.which:
-                if which == 'BE':
-                    continue  # BE invalid for complex
-                for mattype in params.mattypes:
-                    for sigma in params.sigmas_modes:
-                        eval_evec(symmetric, D, typ, k, which,
-                                  None, sigma, mattype)
-
-
-def test_symmetric_starting_vector():
-    params = SymmetricParams()
-    symmetric = True
-    for k in [1, 2, 3, 4, 5]:
-        for D in params.real_test_cases:
-            for typ in 'fd':
-                v0 = random.rand(len(D['v0'])).astype(typ)
-                eval_evec(symmetric, D, typ, k, 'LM', v0)
+    eval_evec(True, D, typ, k, which, None, sigma, mattype, rng=rng)
+
+
+@pytest.mark.parametrize("typ", ['f', 'd'])
+@pytest.mark.parametrize("D", SymmetricParams().real_test_cases)
+@pytest.mark.parametrize("k", [1, 2, 3, 4, 5])
+def test_symmetric_starting_vector(k, D, typ):
+    rng = np.random.default_rng(1749532110418901)
+    v0 = rng.uniform(size=len(D['v0'])).astype(typ)
+    eval_evec(True, D, typ, k, 'LM', v0, rng=rng)
 
 
 def test_symmetric_no_convergence():
@@ -455,57 +442,39 @@ def test_symmetric_no_convergence():
         assert_allclose(dot(m, v), w * v, rtol=rtol, atol=atol)
 
 
-def test_real_nonsymmetric_modes():
-    params = NonSymmetricParams()
+@pytest.mark.parametrize("sigma, OPpart", [(None, None), (0.1, 'r'),
+                                            (0.1 + 0.1j, 'r'), (0.1 + 0.1j, 'i')])
+@pytest.mark.parametrize("mattype", [csr_array, aslinearoperator, np.asarray])
+@pytest.mark.parametrize("which", ['LM', 'LR', 'LI'])
+@pytest.mark.parametrize("typ", ['f', 'd'])
+@pytest.mark.parametrize("D", NonSymmetricParams().real_test_cases)
+def test_real_nonsymmetric_modes(D, typ, which, mattype,
+                                 sigma, OPpart):
+    rng = np.random.default_rng(174953334412726)
     k = 2
-    symmetric = False
-    for D in params.real_test_cases:
-        for typ in 'fd':
-            for which in params.which:
-                for mattype in params.mattypes:
-                    for sigma, OPparts in params.sigmas_OPparts.items():
-                        for OPpart in OPparts:
-                            eval_evec(symmetric, D, typ, k, which,
-                                      None, sigma, mattype, OPpart)
-
-
-def test_complex_nonsymmetric_modes():
-    params = NonSymmetricParams()
+    eval_evec(False, D, typ, k, which, None, sigma, mattype, OPpart, rng=rng)
+
+
+@pytest.mark.parametrize("sigma", [None, 0.1, 0.1 + 0.1j])
+@pytest.mark.parametrize("mattype", [csr_array, aslinearoperator, np.asarray])
+@pytest.mark.parametrize("which", ['LM', 'LR', 'LI'])
+@pytest.mark.parametrize("typ", ['F', 'D'])
+@pytest.mark.parametrize("D", NonSymmetricParams().complex_test_cases)
+def test_complex_nonsymmetric_modes(D, typ, which, mattype, sigma):
+    rng = np.random.default_rng(1749533536274527)
     k = 2
-    symmetric = False
-    for D in params.complex_test_cases:
-        for typ in 'DF':
-            for which in params.which:
-                for mattype in params.mattypes:
-                    for sigma in params.sigmas_OPparts:
-                        eval_evec(symmetric, D, typ, k, which,
-                                  None, sigma, mattype)
-
-
-def test_standard_nonsymmetric_starting_vector():
-    params = NonSymmetricParams()
-    sigma = None
-    symmetric = False
-    for k in [1, 2, 3, 4]:
-        for d in params.complex_test_cases:
-            for typ in 'FD':
-                A = d['mat']
-                n = A.shape[0]
-                v0 = random.rand(n).astype(typ)
-                eval_evec(symmetric, d, typ, k, "LM", v0, sigma)
-
-
-def test_general_nonsymmetric_starting_vector():
-    params = NonSymmetricParams()
-    sigma = None
-    symmetric = False
-    for k in [1, 2, 3, 4]:
-        for d in params.complex_test_cases:
-            for typ in 'FD':
-                A = d['mat']
-                n = A.shape[0]
-                v0 = random.rand(n).astype(typ)
-                eval_evec(symmetric, d, typ, k, "LM", v0, sigma)
+    eval_evec(False, D, typ, k, which, None, sigma, mattype, rng=rng)
+
+
+@pytest.mark.parametrize("typ", ['F', 'D'])
+@pytest.mark.parametrize("D", NonSymmetricParams().complex_test_cases)
+@pytest.mark.parametrize("k", [1, 2, 3, 4])
+def test_nonsymmetric_starting_vector(k, D, typ):
+    rng = np.random.default_rng(174953366983161)
+    A = D['mat']
+    n = A.shape[0]
+    v0 = rng.uniform(size=n).astype(typ)
+    eval_evec(False, D, typ, k, "LM", v0, sigma=None, rng=rng)
 
 
 def test_standard_nonsymmetric_no_convergence():
@@ -578,7 +547,6 @@ def test_linearoperator_deallocation():
         pass
 
 
-@pytest.mark.thread_unsafe
 def test_parallel_threads():
     results = []
     v0 = np.random.rand(50)
@@ -608,12 +576,17 @@ def test_reentering():
     def A_matvec(x):
         x = diags_array([1, -2, 1], offsets=[-1, 0, 1], shape=(50, 50))
         w, v = eigs(x, k=1)
-        return v / w[0]
+        return v.real / w[0].real
     A = LinearOperator(matvec=A_matvec, dtype=float, shape=(50, 50))
 
+    # ================= Old Fortran tests ==================
     # The Fortran code is not reentrant, so this fails (gracefully, not crashing)
-    assert_raises(RuntimeError, eigs, A, k=1)
-    assert_raises(RuntimeError, eigsh, A, k=1)
+    # assert_raises(RuntimeError, eigs, A, k=1)
+    # assert_raises(RuntimeError, eigsh, A, k=1)
+    #
+    # These should not crash upon reentrance
+    eigs(A, k=1)
+    eigsh(A, k=1)
 
 
 def test_regression_arpackng_1315():
-- 
2.39.5 (Apple Git-154)

